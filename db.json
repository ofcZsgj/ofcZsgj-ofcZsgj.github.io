{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME.txt","path":"CNAME.txt","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon16.ico","path":"images/favicon16.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon32.ico","path":"images/favicon32.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/header1.jpg","path":"images/header1.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/clipboard-use.js","path":"js/src/clipboard-use.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/clipboard.js","path":"js/src/clipboard.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/love.js","path":"js/src/love.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/header.jpg","path":"images/header.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551014496000},{"_id":"source/.DS_Store","hash":"fa4777fd3c6e3dc8a9c98979348bdd62f293749e","modified":1578925547450},{"_id":"source/CNAME.txt","hash":"577fa3a5461d230eb33bb1c134236dadedd30c5c","modified":1550829000000},{"_id":"themes/next/.DS_Store","hash":"affc38776afb12c74de3b7e14b97f3f5e5d7138e","modified":1578969990876},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1550759374000},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1550759374000},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1550759374000},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1550759374000},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1550759374000},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1550759374000},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1550759374000},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1550759374000},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1550759374000},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1550759374000},{"_id":"themes/next/README.cn.md","hash":"16e033833fb97de42df47fdae704432e833f07f3","modified":1578924308413},{"_id":"themes/next/README.md","hash":"919edbcca4ab0ce95a56a2e8608d9a73e933fd13","modified":1578924308411},{"_id":"themes/next/_config.yml","hash":"c4ff4af18001a679b723aa49e8a2f96737321c8a","modified":1563985134000},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1550759374000},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1550759374000},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1550759374000},{"_id":"source/404/index.md","hash":"d6cd47ba4ab178269d9e7be773e521a3f74a738b","modified":1551014850000},{"_id":"source/_posts/2019-Holiday-Note-01.md","hash":"6e262425f2be00ade5e7f570e4e6a83601ce9460","modified":1563200940000},{"_id":"source/_posts/2019-Holiday-Note-02.md","hash":"969edd0669358044e9a6a808fa533506cbe67e8f","modified":1563200942000},{"_id":"source/_posts/2019-Holiday-Note-04.md","hash":"7291a629bb06bf0580f7d401df11bbf84cf034cd","modified":1563288028000},{"_id":"source/_posts/2019-Holiday-Note-03.md","hash":"990f037e4018a462530e701296c627fc012410a1","modified":1563201642000},{"_id":"source/_posts/2019-Holiday-Note-05.md","hash":"738981cb3f292cf3c9c9ff55ca1a5bebea354a06","modified":1563369074000},{"_id":"source/_posts/2019-Holiday-Note-06.md","hash":"ee4ad840d362d6822ac99b9e2e7621c11cfb6a0f","modified":1563443972000},{"_id":"source/_posts/2019-Holiday-Note-07.md","hash":"91f385dee20df7ce703ea9fd365d93c1733d54a3","modified":1563544742000},{"_id":"source/_posts/2019-Holiday-Note-08.md","hash":"e7728cec1fa3574d629a5b3ed45fcd5284e52aa8","modified":1563630336000},{"_id":"source/_posts/2019-Holiday-Note-09.md","hash":"5e88d4ed4e1cdd94959c1235d988a6075069f1f5","modified":1563712582000},{"_id":"source/_posts/2019-Holiday-Note-10.md","hash":"2ed9266914b3c5dff62a43dd4a37c853b54f608a","modified":1563981192000},{"_id":"source/_posts/2019-Holiday-Note-11.md","hash":"52cbc4074f7e25fafdec9a66352452f4260fc5e9","modified":1563981188000},{"_id":"source/_posts/2019-Holiday-Note-12.md","hash":"e95a76ca1e68d5657fee7822b5ff0adebef9dafd","modified":1563981184000},{"_id":"source/_posts/2019-Holiday-Note-13.md","hash":"62d8e90a9905d54c1553233e0fde7bd3c85792d3","modified":1564067212000},{"_id":"source/_posts/2019-Holiday-Note-14.md","hash":"6358883af28c45f509b5d5c9dd5438a7a5b90fe1","modified":1564151824000},{"_id":"source/_posts/2019-Holiday-Note-15.md","hash":"307b3e1a3ecbedb05215314c22e9dcf660a92651","modified":1564236046000},{"_id":"source/_posts/2019-Holiday-Note-16.md","hash":"3721dc70b5573902a328fc706d8b64e6409de763","modified":1564329352000},{"_id":"source/_posts/2019-Holiday-Note-17.md","hash":"fe883a6e9336914c5b59dc5194fcdc38e559613f","modified":1564413258000},{"_id":"source/_posts/2019-Holiday-Note-18.md","hash":"cba441664fed9f01c22987c24b410b812d799067","modified":1564491276000},{"_id":"source/_posts/Intro.md","hash":"44c50b68e4416cbcf372cd6548f6000781fab24d","modified":1550849250000},{"_id":"source/_posts/XBB01.md","hash":"578a513f11ce8c4fdc5dd9087b9f39d69d6916a3","modified":1563670942000},{"_id":"source/_posts/笑傲江湖DEMO.md","hash":"7ad603b5a7f9be3ede6886ded8dbba88acd82c06","modified":1563287534000},{"_id":"source/categories/index.md","hash":"e69a06846c5f2d6d3a8adb04e3227c28bf9e2c06","modified":1550824662000},{"_id":"source/about/index.md","hash":"020c97b38eaff120d91310f6b9106ca099835c23","modified":1563358580000},{"_id":"source/tags/index.md","hash":"c2214a20756f8736fa545a4ce114a51491f8c2c1","modified":1563981238000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1550759374000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1550759374000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1550759374000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1550759374000},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1550759374000},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1550759374000},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1550759374000},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1550759374000},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1550759374000},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1550759374000},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1550759374000},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1550759374000},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1550759374000},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1550759374000},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1550759374000},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1550759374000},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1550759374000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1550759374000},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1550759374000},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1550759374000},{"_id":"themes/next/layout/_layout.swig","hash":"1354d659a78559b3e734225bba9c89c701b0cd19","modified":1551015968000},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1550759374000},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1550759374000},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1550759374000},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1550759374000},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1550759374000},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1550759374000},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1550759374000},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1550759374000},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1550759374000},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1550759374000},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1550759374000},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1550759374000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550759374000},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1550759374000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1550759374000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1550759374000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1550759374000},{"_id":"themes/next/layout/_macro/post.swig","hash":"afbe5342c51e1f40a5c1f8a0f6a1529dab7f1a9c","modified":1551012016000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1550759374000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1550759374000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1550759374000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1550759374000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"26e93336dc57a39590ba8dc80564a1d2ad5ff93b","modified":1550829676000},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1550759374000},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1550759374000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1550759374000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1550759374000},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1550759374000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1550759374000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1550759374000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1550759374000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1550759374000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1550759374000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1550759374000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1550759374000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1550759374000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1550759374000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1550759374000},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1550759374000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1550759374000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1550759374000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1550759374000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1550759374000},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1550759374000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1550759374000},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1550759374000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1550759374000},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1550759374000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1550759374000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1550759374000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1550759374000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1550759374000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1550759374000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1550759374000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1550759374000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1550759374000},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1550759374000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1550759374000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1550759374000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1550759374000},{"_id":"themes/next/source/images/favicon16.ico","hash":"5f7f51427098cb68ceb0512f73052888555a7ea3","modified":1550837614000},{"_id":"themes/next/source/images/favicon32.ico","hash":"2014575bbdfed7813ff93c310992e965b0c4b006","modified":1550837336000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550759374000},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1550759374000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550759374000},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1550759374000},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1550759374000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1550759374000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550759374000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550759374000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550759374000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550759374000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550759374000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550759374000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1550759374000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1550759374000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1550759374000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1550759374000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1550759374000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1550759374000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1550759374000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1550759374000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1550759374000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1550759374000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1550759374000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1550759374000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1550759374000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1550759374000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1550759374000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1550759374000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1550759374000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1550759374000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1550759374000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1550759374000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1550759374000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1550759374000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1550759374000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1550759374000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1550759374000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1550759374000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"ca7687456fb237b3dba1617b97117c6354944774","modified":1551014012000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1550759374000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1550759374000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1550759374000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1550759374000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1550759374000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1550759374000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1550759374000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"b4932ede94e91a1ce9fc54f2e5d3dd1be3d0df76","modified":1563985384000},{"_id":"themes/next/source/images/header1.jpg","hash":"4c7302b8bf8b58a99e3cb3386f59821b2a2da94b","modified":1550844842000},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1550759374000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1550759374000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1550759374000},{"_id":"themes/next/source/js/src/clipboard-use.js","hash":"3b0352a7e14c932621bc29ae22e2d273b0f9b399","modified":1551013982000},{"_id":"themes/next/source/js/src/clipboard.js","hash":"5dbdb9eea7a4e7ef65938ce5a555e516ae30fadd","modified":1551013912000},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1550759374000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1550759374000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1550759374000},{"_id":"themes/next/source/js/src/love.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1551015940000},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1550759374000},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1550759374000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1550759374000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1550759374000},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1550759374000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1550759374000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1550759374000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1550759374000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1550759374000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1550759374000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1550759374000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1550759374000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1550759374000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1550759374000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1550759374000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1550759374000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1550759374000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1550759374000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1550759374000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1550759374000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1550759374000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1550759374000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1550759374000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1550759374000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1550759374000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1550759374000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1550759374000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1550759374000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1550759374000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1550759374000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1550759374000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1550759374000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1550759374000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1550759374000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1550759374000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1550759374000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1550759374000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1550759374000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1550759374000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1550759374000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1550759374000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1550759374000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1550759374000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1550759374000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1550759374000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1550759374000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1550759374000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1550759374000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1550759374000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a076bb4f0e6064de037288dd35192c3b852339ad","modified":1551011818000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"7cf841f23e2da3b6966ef19a9fda2a0d297b9fe4","modified":1551011674000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1550759374000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1550759374000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1550759374000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1550759374000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1550759374000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1550759374000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1550759374000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1550759374000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1550759374000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1550759374000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1550759374000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1550759374000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1550759374000},{"_id":"themes/next/source/images/header.jpg","hash":"7c4caab92c94ccb8f919df3a55e08433feee8d86","modified":1551015628000}],"Category":[{"name":"C","_id":"ck5dbbih90006smjbg7mt3dyj"},{"name":"C++","_id":"ck5dbbihn000xsmjb834n7ajp"},{"name":"Life","_id":"ck5dbbihx001tsmjbkvyv9du5"}],"Data":[],"Page":[{"_content":"","source":"README.md","raw":"","date":"2020-01-14T02:41:24.678Z","updated":"2019-02-24T13:21:36.000Z","path":"README.html","title":"","comments":1,"layout":"page","_id":"ck5dbbid00000smjbhd4p55zc","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","source":"404/index.md","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","date":"2020-01-14T02:41:24.679Z","updated":"2019-02-24T13:27:30.000Z","path":"404/index.html","title":"","comments":1,"layout":"page","_id":"ck5dbbie10001smjbhmuq9nnl","content":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>"},{"title":"categories","date":"2019-02-22T08:36:31.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-02-22 16:36:31\ntype: \"categories\"\n---\n","updated":"2019-02-22T08:37:42.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck5dbbih60003smjbfngp2euk","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"定风波","date":"2019-02-22T10:34:12.000Z","_content":"<h4 style=\"text-align:center\">苏轼 <h3>\n<h5 style=\"text-align:center\">三月七日沙湖道中遇雨。 <h4>\n<h5 style=\"text-align:center\">雨具先去，同行皆狼狈，余独不觉。<h4>\n<h5 style=\"text-align:center\">已而遂晴，故作此词。<h4>\n<h5 style=\"text-align:center\">莫听穿林打叶声，何妨吟啸且徐行。 <h5>\n<h5 style=\"text-align:center\">竹杖芒鞋轻胜马，谁怕？<h5>\n<h5 style=\"text-align:center\">一蓑烟雨任平生。<h5>\n<h5 style=\"text-align:center\">料峭春风吹酒醒，微冷，山头斜照却相迎。<h5>\n<h5 style=\"text-align:center\">回首向来萧瑟处，归去，也无风雨也无晴。 <h5>\n\n\n","source":"about/index.md","raw":"---\ntitle: 定风波\ndate: 2019-02-22 18:34:12\n---\n<h4 style=\"text-align:center\">苏轼 <h3>\n<h5 style=\"text-align:center\">三月七日沙湖道中遇雨。 <h4>\n<h5 style=\"text-align:center\">雨具先去，同行皆狼狈，余独不觉。<h4>\n<h5 style=\"text-align:center\">已而遂晴，故作此词。<h4>\n<h5 style=\"text-align:center\">莫听穿林打叶声，何妨吟啸且徐行。 <h5>\n<h5 style=\"text-align:center\">竹杖芒鞋轻胜马，谁怕？<h5>\n<h5 style=\"text-align:center\">一蓑烟雨任平生。<h5>\n<h5 style=\"text-align:center\">料峭春风吹酒醒，微冷，山头斜照却相迎。<h5>\n<h5 style=\"text-align:center\">回首向来萧瑟处，归去，也无风雨也无晴。 <h5>\n\n\n","updated":"2019-07-17T10:16:20.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck5dbbih80005smjba7ftn8vi","content":"<h4 style=\"text-align:center\">苏轼 <h3>\n<h5 style=\"text-align:center\">三月七日沙湖道中遇雨。 <h4>\n<h5 style=\"text-align:center\">雨具先去，同行皆狼狈，余独不觉。<h4>\n<h5 style=\"text-align:center\">已而遂晴，故作此词。<h4>\n<h5 style=\"text-align:center\">莫听穿林打叶声，何妨吟啸且徐行。 <h5>\n<h5 style=\"text-align:center\">竹杖芒鞋轻胜马，谁怕？<h5>\n<h5 style=\"text-align:center\">一蓑烟雨任平生。<h5>\n<h5 style=\"text-align:center\">料峭春风吹酒醒，微冷，山头斜照却相迎。<h5>\n<h5 style=\"text-align:center\">回首向来萧瑟处，归去，也无风雨也无晴。 <h5>\n\n\n</h5></h5></h5></h5></h5></h5></h5></h5></h5></h5></h4></h5></h4></h5></h4></h5></h3></h4>","site":{"data":{}},"excerpt":"","more":"<h4 style=\"text-align:center\">苏轼 <h3>\n<h5 style=\"text-align:center\">三月七日沙湖道中遇雨。 <h4>\n<h5 style=\"text-align:center\">雨具先去，同行皆狼狈，余独不觉。<h4>\n<h5 style=\"text-align:center\">已而遂晴，故作此词。<h4>\n<h5 style=\"text-align:center\">莫听穿林打叶声，何妨吟啸且徐行。 <h5>\n<h5 style=\"text-align:center\">竹杖芒鞋轻胜马，谁怕？<h5>\n<h5 style=\"text-align:center\">一蓑烟雨任平生。<h5>\n<h5 style=\"text-align:center\">料峭春风吹酒醒，微冷，山头斜照却相迎。<h5>\n<h5 style=\"text-align:center\">回首向来萧瑟处，归去，也无风雨也无晴。 <h5>\n\n\n</h5></h5></h5></h5></h5></h5></h5></h5></h5></h5></h4></h5></h4></h5></h4></h5></h3></h4>"},{"title":"tags","date":"2019-02-22T08:39:34.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-02-22 16:39:34\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2019-07-24T15:13:58.000Z","path":"tags/index.html","comments":1,"_id":"ck5dbbihc0009smjbf0ox1659","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Holiday Note_01","date":"2019-07-13T09:54:39.000Z","_content":"\n# Holiday Note_01\n\n今天是学校放假的第一天，趁着这个暑假，把丢了一个学期的博客捡起来。每晚花点时间总结下白天学到的知识点，这样不至于出现学一天忘两天的尴尬情况，也方便以后复习，目前计划是一天一篇📒📘📗📕📔📙，以上。\n\n<!-- more -->\n\n先做个总结，今天学的不算是新知识了，大都是对以前学过知识的拓展补充因此学习起来难度并不是很大，比如数据类型的一些新使用场景和方式，自增语句以及判断语句 (++i，if(NULL == p)) 的优化写法，内存四区模型的拓展，栈区和堆区使用的注意要点（堆区的使用还是挺有讲究的这是一个重难点尤其是二级指针作为参数去操作时，使用不当，不仅内存泄露，还会出现野指针），其中关于栈和函数调用流程特别重要，写程序一定要清楚的知道自己写的哪些数据分别在哪个区内，什么时候会被回收，否则可能带来非常多的bug，最后就是指针的步长（这一块比较难以理解，而且是重点，理解后就可以写出各种花里胡哨的指针表示了哈哈），新学到的不过就是宏函数和调用惯例难度不大也不是重点了。\n\n---\n\n## 数据类型\n### typedef的新用法\n~~~\n    char *p1,p2;\n    //此写法将只有p1为指针类型，p2仍为char类型\n    \n    //解决方法如下\n    typedef char * pchar;\n    pchar p3,p4,p5;\n\n    //且使用typedef有利于程序的移植性\n~~~\n\n### void *\n~~~\n    /*\n        1、是所有类型指针的祖宗，又称万能指针\n        2、任何类型的指针都不需要经过强制转换为void*\n        3、主要用于数据结构的封装,基本上封装的函数参数均为void*\n    */\n~~~\n\n### unsigned int\n~~~\n    /*\n        1、sizeof()返回的值是unsigned int\n        2、一般情况，unsigned int与int进行运算得到的是前者,如 int i=10,j=20; i-j结果为10\n        3、切记数组在作为函数参数时会退化为指向数组首元素的指针，当使用sizeof() 求大小时，求得的值实际为指针占用大小\n    */\n~~~\n\n### 内存分区的的一些补充\n- 数据区包括：堆，栈，全局/静态存储区。\n- 全局/静态存储区包括：常量区，全局区、静态区。\n- 常量区包括：字符串常量区、常变量区。\n- 代码区：存放程序编译后的二进制代码，不可寻址区。\n\n可以说，C/C++内存分区其实只有两个，即代码区和数据区。且全局const变量，字符串常量于常量区，无法通过直接或间接修改，局部const位于栈区，可以通过间接修改\n\n---\n\n## 内存分区知识点\n\n### 程序运行前\n首先需要了解，C程序在运行之前，要经过如下所示四个步骤:\n\n|步骤|内容|\n|:-:|:-:|\n|预处理|宏定义展开、头文件展开、条件编译，这里并不会检查语法|\n|编译|检查语法，将预处理后文件编译生成汇编文件|\n|汇编|将汇编文件生成目标文件(二进制文件)|\n|链接|将目标文件链接为可执行程序|\n\n生成可执行性文件后在Linux下可以通过size命令查看可执行性程序的基本情况\n\n即在程序为被加载到内存中前，程序内部已经分好了三段区域\n- 代码区（text）注意代码区通常是只读的，共享的。其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。\n- 数据区（data）该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。\n- 未初始化数据区（bss）存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。\n\n### 程序运行后\n程序运行之后，代码区，数据区以及未初始化数据区的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。\n\n#### 栈区（stack）\n栈区使用不当可能会造成程序运行结果出错，以下为两个错误示例，需要十分注意，\n~~~\n//栈区内存自动释放，不需要程序手动管理，\n\nint * myFunc() {\n\tint a = 10;//临时变量a存于栈上\n\treturn &a;\n}\n\n\n//不要返回局部变量的地址\nvoid test01() {\n\tint* p = myFunc();\n\tprintf(\"%d\\n\", *p);\n}\n\nchar *getString() {\n\tchar str[] = \"Hello World!\";//str在getString()结束后被销毁\n\treturn str;\n}\n\nvoid test02() {\n\tchar* s = NULL;\n\ts = getString();\n\tprintf(\"s=%s\", s);\n}\n\nint main() {\n\t//此使已经不关心值是多少，因为局部变量a的内存空间已经被回收\n\ttest01();\n\n\t//Hello World!被存入常量区，但是str存在与栈区，getString（）结束后被回收，str地址存放值不再是HelloWorld\n\ttest02();\n}\n~~~\n以下为栈的生长方向示意图，向低地址生长，压栈（push）使得栈顶元素的地址变小，出栈（pop）使得栈顶元素的地址变大。\n![8edce2a9aae27a724903e.jpg](https://miao.su/images/2019/07/13/8edce2a9aae27a724903e.jpg)\n\n~~~\n//栈和内存生长方式的理解代码\n//1. 栈的生长方向\nvoid test01(){\n\n\tint a = 10;\n\tint b = 20;\n\tint c = 30;\n\tint d = 40;\n\n\tprintf(\"a = %d\\n\", &a);\n\tprintf(\"b = %d\\n\", &b);\n\tprintf(\"c = %d\\n\", &c);\n\tprintf(\"d = %d\\n\", &d);\n\n\t//a的地址大于b的地址，故而生长方向向下\n}\n\n//2. 内存生长方向(小端模式)\nvoid test02(){\n\t\n\t//高位字节 -> 地位字节\n\tint num = 0xaabbccdd;\n\tunsigned char* p = &num;\n\n\t//从首地址开始的第一个字节\n\tprintf(\"%x\\n\",*p);\n\tprintf(\"%x\\n\", *(p + 1));\n\tprintf(\"%x\\n\", *(p + 2));\n\n~~~\n\n### 堆区（heap）\n以下为堆区使用的两个错误例子，导致了内存泄露，且堆释放不当还可能造成野指针，因此需要十分注意！\n~~~\nint* getSpace() {\n\tint* p = malloc(sizeof(int) * 5);//p是在栈上，但是malloc分配的20个字节在堆上\n\n\tif (NULL == p) {//该写法NULL放前边防止出现写成p=NULL且不报错的情况\n\t\treturn NULL;\n\t}\n\t //只要是连续分配的内存空间都可以用下标来访问\n\tfor (int i = 0; i < 5; ++i) {//++i效率高\n\t\tp[i] = 100 + i;\n\t}\n\treturn p;\n}\n\nvoid test03() {\n\tchar* p = NULL;\n\tallocateSpace(p); //执行完毕后，p仍然是NULL\n\tprintf(\"p= %s\", p);//打印结果为NULL，造成了内存泄露！！！\n}\n~~~\n\n~~~\nvoid allocateSpace(char* p) {\n\tp = malloc(100);//开辟了堆空间，p指向的堆空间存放了HelloWorld\n\tmemset(p, 0, 100);\n\tstrcpy(p, \"Hello World\");//p存放与栈上，结束后销毁，堆空间的地址从此 未知!\n}\n\nvoid test04() {\n\tchar* p = NULL;\n\tallocateSpace(p); //执行完毕后，p仍然是NULL\n\tprintf(\"p= %s\", p);//打印结果为NULL，造成了内存泄露！！！\n}\n~~~\n\n要想正确使用堆区，关键在于找到分配的堆空间的地址，一定不能丢掉开辟堆空间的地址，以下示例使用了二级指针进行操作\n\n~~~\nvoid allocateSpace02(char** p) {\n\tchar* temp = malloc(100);\n\tmemset(temp, 0, 100);\n\tstrcpy(temp, \"Hello World\");\n\t//关键步骤！\n    *p = temp;\n    //让传递过来的p指针指向开辟堆空间的地址，因此结束释放了形参char**p和临时变量char*temp也就无所谓了\n}\n\nvoid test05() {\n\tchar* p = NULL;\n\tallocateSpace02(&p);\n\tprintf(\"p= %s\\n\", p);\n    \n\tfree(p);\n\tp = NULL;//free(p) 仅仅只是将该堆空间释放，p若不置为空则成为野指针\n}\n~~~\n以下为allocateSpace02函数内存分配示意图为辅助理解\n![heap21e261.png](https://miao.su/images/2019/07/13/heap21e261.png)\n\n---\n\n## 函数调用模型\n函数调用流程示意图如下所示 (十分重要，写代码时对于每一条语句的执行心中都要有此模型)：\n\n[![001dbea1.md.jpg](https://miao.su/images/2019/07/13/001dbea1.md.jpg)](https://miao.su/image/TNrPP)\n[![002b3804.md.jpg](https://miao.su/images/2019/07/13/002b3804.md.jpg)](https://miao.su/image/TNEdB)\n[![00364141.md.jpg](https://miao.su/images/2019/07/13/00364141.md.jpg)](https://miao.su/image/TNJ5J)\n[![004f551d.md.jpg](https://miao.su/images/2019/07/13/004f551d.md.jpg)](https://miao.su/image/TNdUm)\n[![00575dc4.md.jpg](https://miao.su/images/2019/07/13/00575dc4.md.jpg)](https://miao.su/image/TNxKs)\n\n### 函数调用流程\n栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面：\n- 函数的返回地址；\n- 函数的参数；\n- 临时变量；\n- 保存的上下文：包括在函数调用前后需要保持不变的寄存器\n\n### 调用惯例\n~~~\n/*  \n\t根据下面的代码衍生出两个问题：\n\t1、参数进行压栈时，对于参数的选择是从左到右还是从右到左 \n\t2、函数参数的出栈是在func内进行还是在main中进行\n*/\n\n/*\n\t因此需要一个惯例来进行规定以下几个内容，C语言默认为_cdecl调用惯例   \n\t1、出栈方: 为调用函数方，即若main函数调用func函数则由main函数将参数进行出栈操作\n\t2、参数传值次序: 由右到左压栈\n\t3、名字修饰方式: 下划线加函数名\n*/\n\n// _cdecl默认不用加\nint _cdecl func(int a, int b) {\n\tint t_a = a;\n\tint t_b = b;\n\treturn t_a + t_b;\n}\n\nint main() {\n\tint ret = 0;\n\tret = func(10, 20);\n\tint  a = 0;\n\treturn 0;\n}\n~~~\n\n---\n\n## 指针的步长（通过实际代码进行理解）\n以下通过两个示例从易到难演示指针的步长。\n~~~\n/*\n\t 重难点！！！\n\t 指针的步长：指针变量+1，要向后跳多少个字节\n*/\n\nvoid test06() {\n\tchar buf[1024];\n\tint a = 100;\n\tmemset(buf, 0, 1024);\n\tmemcpy(buf + 1, &a, sizeof(int));\n\n    //以下为重难点！ \n    //buf为char类型，p+1跳1字节，通过强转使得p可以只跳1字节从而取到存放a的首地址后\n\tchar* p = buf;\t\n\t//由于a是int类型，需要转换int*取出存放a的4个字节，再用*取出这四个字节为a的值\n\tprintf(\"a= %d\\n\", *(int*)(p + 1));\n}\n~~~\n\n~~~\n#include<stddef.h>\n\nstruct Person {\n\tint a;\n\tchar b;\n\tchar buf[64];\n\tint d;\n};\n\nvoid test07() {\n\tstruct Person p = { 10,'b',\"Hello World\",100 };\n\t//offsetof()是宏函数，包含再stddef.h头文件中，计算结构体中变量偏移位置\n\t//printf(\"b off:%d\\n\", offsetof(struct Person, b));\n\n\t//使用Person类型指针取出d的值,重难点！！！！！！\n\tprintf(\"d= %d\\n\", *(int*)((char*)(&p) + offsetof(struct Person, d)));\n\t\n    /*  解析如下：\n\t\t1、&p 步长为Person的字节数\n\t\t2、(char*)(&p) 步长转换为1\n\t\t3、((char*)(&p) + offsetof(struct Person, d))  通过offsetof()求出d的偏移量并指向d的首地址\n\t\t4、(int*)((char*)(&p) + offsetof(struct Person, d))   d为int类型，使用int*获取d的四个字节地址\n\t\t5、*取出内存存放的d的值\n\t*/\n\n}\n~~~\n\n---\n\n##  宏函数\n宏函数不是一个真正的函数，只是预处理时做简单的文本替换\n~~~\n#define MYADD(x,y) ((x)+(y))\n\n//宏函数在一定的场景下比普通函数的运行效率要高\n//以空间换取时间\n//对于频繁调用的简单函数，可以使用宏函数代替，因为宏函数没有普通函数调用的开销（函数压栈，跳转，返回等）\n\nint main() {\n\tint a = 10, b = 20;\n\t//MYADD(a,b)实际只是被替换成了（（a）+（b））\n\tprintf(\"a + b = %d\\n\", MYADD(a, b));\n}\n~~~\n\nPS:太久没捣腾hexo了，命令都忘干净了，来来回回切换看效果花了好久，开头写的每晚花一点时间，今晚就整了快三个小时我也是醉了。。。Markdown语法也是只记得些简单的，写完一看网页效果看起来很不咋样，还写得啰嗦的要死，BUT，先这样吧，至少开了个头。","source":"_posts/2019-Holiday-Note-01.md","raw":"---\ntitle: Holiday Note_01\ndate: 2019-07-13 17:54:39\ncategories: C\ntags: [Note,C]\n---\n\n# Holiday Note_01\n\n今天是学校放假的第一天，趁着这个暑假，把丢了一个学期的博客捡起来。每晚花点时间总结下白天学到的知识点，这样不至于出现学一天忘两天的尴尬情况，也方便以后复习，目前计划是一天一篇📒📘📗📕📔📙，以上。\n\n<!-- more -->\n\n先做个总结，今天学的不算是新知识了，大都是对以前学过知识的拓展补充因此学习起来难度并不是很大，比如数据类型的一些新使用场景和方式，自增语句以及判断语句 (++i，if(NULL == p)) 的优化写法，内存四区模型的拓展，栈区和堆区使用的注意要点（堆区的使用还是挺有讲究的这是一个重难点尤其是二级指针作为参数去操作时，使用不当，不仅内存泄露，还会出现野指针），其中关于栈和函数调用流程特别重要，写程序一定要清楚的知道自己写的哪些数据分别在哪个区内，什么时候会被回收，否则可能带来非常多的bug，最后就是指针的步长（这一块比较难以理解，而且是重点，理解后就可以写出各种花里胡哨的指针表示了哈哈），新学到的不过就是宏函数和调用惯例难度不大也不是重点了。\n\n---\n\n## 数据类型\n### typedef的新用法\n~~~\n    char *p1,p2;\n    //此写法将只有p1为指针类型，p2仍为char类型\n    \n    //解决方法如下\n    typedef char * pchar;\n    pchar p3,p4,p5;\n\n    //且使用typedef有利于程序的移植性\n~~~\n\n### void *\n~~~\n    /*\n        1、是所有类型指针的祖宗，又称万能指针\n        2、任何类型的指针都不需要经过强制转换为void*\n        3、主要用于数据结构的封装,基本上封装的函数参数均为void*\n    */\n~~~\n\n### unsigned int\n~~~\n    /*\n        1、sizeof()返回的值是unsigned int\n        2、一般情况，unsigned int与int进行运算得到的是前者,如 int i=10,j=20; i-j结果为10\n        3、切记数组在作为函数参数时会退化为指向数组首元素的指针，当使用sizeof() 求大小时，求得的值实际为指针占用大小\n    */\n~~~\n\n### 内存分区的的一些补充\n- 数据区包括：堆，栈，全局/静态存储区。\n- 全局/静态存储区包括：常量区，全局区、静态区。\n- 常量区包括：字符串常量区、常变量区。\n- 代码区：存放程序编译后的二进制代码，不可寻址区。\n\n可以说，C/C++内存分区其实只有两个，即代码区和数据区。且全局const变量，字符串常量于常量区，无法通过直接或间接修改，局部const位于栈区，可以通过间接修改\n\n---\n\n## 内存分区知识点\n\n### 程序运行前\n首先需要了解，C程序在运行之前，要经过如下所示四个步骤:\n\n|步骤|内容|\n|:-:|:-:|\n|预处理|宏定义展开、头文件展开、条件编译，这里并不会检查语法|\n|编译|检查语法，将预处理后文件编译生成汇编文件|\n|汇编|将汇编文件生成目标文件(二进制文件)|\n|链接|将目标文件链接为可执行程序|\n\n生成可执行性文件后在Linux下可以通过size命令查看可执行性程序的基本情况\n\n即在程序为被加载到内存中前，程序内部已经分好了三段区域\n- 代码区（text）注意代码区通常是只读的，共享的。其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。\n- 数据区（data）该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。\n- 未初始化数据区（bss）存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。\n\n### 程序运行后\n程序运行之后，代码区，数据区以及未初始化数据区的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。\n\n#### 栈区（stack）\n栈区使用不当可能会造成程序运行结果出错，以下为两个错误示例，需要十分注意，\n~~~\n//栈区内存自动释放，不需要程序手动管理，\n\nint * myFunc() {\n\tint a = 10;//临时变量a存于栈上\n\treturn &a;\n}\n\n\n//不要返回局部变量的地址\nvoid test01() {\n\tint* p = myFunc();\n\tprintf(\"%d\\n\", *p);\n}\n\nchar *getString() {\n\tchar str[] = \"Hello World!\";//str在getString()结束后被销毁\n\treturn str;\n}\n\nvoid test02() {\n\tchar* s = NULL;\n\ts = getString();\n\tprintf(\"s=%s\", s);\n}\n\nint main() {\n\t//此使已经不关心值是多少，因为局部变量a的内存空间已经被回收\n\ttest01();\n\n\t//Hello World!被存入常量区，但是str存在与栈区，getString（）结束后被回收，str地址存放值不再是HelloWorld\n\ttest02();\n}\n~~~\n以下为栈的生长方向示意图，向低地址生长，压栈（push）使得栈顶元素的地址变小，出栈（pop）使得栈顶元素的地址变大。\n![8edce2a9aae27a724903e.jpg](https://miao.su/images/2019/07/13/8edce2a9aae27a724903e.jpg)\n\n~~~\n//栈和内存生长方式的理解代码\n//1. 栈的生长方向\nvoid test01(){\n\n\tint a = 10;\n\tint b = 20;\n\tint c = 30;\n\tint d = 40;\n\n\tprintf(\"a = %d\\n\", &a);\n\tprintf(\"b = %d\\n\", &b);\n\tprintf(\"c = %d\\n\", &c);\n\tprintf(\"d = %d\\n\", &d);\n\n\t//a的地址大于b的地址，故而生长方向向下\n}\n\n//2. 内存生长方向(小端模式)\nvoid test02(){\n\t\n\t//高位字节 -> 地位字节\n\tint num = 0xaabbccdd;\n\tunsigned char* p = &num;\n\n\t//从首地址开始的第一个字节\n\tprintf(\"%x\\n\",*p);\n\tprintf(\"%x\\n\", *(p + 1));\n\tprintf(\"%x\\n\", *(p + 2));\n\n~~~\n\n### 堆区（heap）\n以下为堆区使用的两个错误例子，导致了内存泄露，且堆释放不当还可能造成野指针，因此需要十分注意！\n~~~\nint* getSpace() {\n\tint* p = malloc(sizeof(int) * 5);//p是在栈上，但是malloc分配的20个字节在堆上\n\n\tif (NULL == p) {//该写法NULL放前边防止出现写成p=NULL且不报错的情况\n\t\treturn NULL;\n\t}\n\t //只要是连续分配的内存空间都可以用下标来访问\n\tfor (int i = 0; i < 5; ++i) {//++i效率高\n\t\tp[i] = 100 + i;\n\t}\n\treturn p;\n}\n\nvoid test03() {\n\tchar* p = NULL;\n\tallocateSpace(p); //执行完毕后，p仍然是NULL\n\tprintf(\"p= %s\", p);//打印结果为NULL，造成了内存泄露！！！\n}\n~~~\n\n~~~\nvoid allocateSpace(char* p) {\n\tp = malloc(100);//开辟了堆空间，p指向的堆空间存放了HelloWorld\n\tmemset(p, 0, 100);\n\tstrcpy(p, \"Hello World\");//p存放与栈上，结束后销毁，堆空间的地址从此 未知!\n}\n\nvoid test04() {\n\tchar* p = NULL;\n\tallocateSpace(p); //执行完毕后，p仍然是NULL\n\tprintf(\"p= %s\", p);//打印结果为NULL，造成了内存泄露！！！\n}\n~~~\n\n要想正确使用堆区，关键在于找到分配的堆空间的地址，一定不能丢掉开辟堆空间的地址，以下示例使用了二级指针进行操作\n\n~~~\nvoid allocateSpace02(char** p) {\n\tchar* temp = malloc(100);\n\tmemset(temp, 0, 100);\n\tstrcpy(temp, \"Hello World\");\n\t//关键步骤！\n    *p = temp;\n    //让传递过来的p指针指向开辟堆空间的地址，因此结束释放了形参char**p和临时变量char*temp也就无所谓了\n}\n\nvoid test05() {\n\tchar* p = NULL;\n\tallocateSpace02(&p);\n\tprintf(\"p= %s\\n\", p);\n    \n\tfree(p);\n\tp = NULL;//free(p) 仅仅只是将该堆空间释放，p若不置为空则成为野指针\n}\n~~~\n以下为allocateSpace02函数内存分配示意图为辅助理解\n![heap21e261.png](https://miao.su/images/2019/07/13/heap21e261.png)\n\n---\n\n## 函数调用模型\n函数调用流程示意图如下所示 (十分重要，写代码时对于每一条语句的执行心中都要有此模型)：\n\n[![001dbea1.md.jpg](https://miao.su/images/2019/07/13/001dbea1.md.jpg)](https://miao.su/image/TNrPP)\n[![002b3804.md.jpg](https://miao.su/images/2019/07/13/002b3804.md.jpg)](https://miao.su/image/TNEdB)\n[![00364141.md.jpg](https://miao.su/images/2019/07/13/00364141.md.jpg)](https://miao.su/image/TNJ5J)\n[![004f551d.md.jpg](https://miao.su/images/2019/07/13/004f551d.md.jpg)](https://miao.su/image/TNdUm)\n[![00575dc4.md.jpg](https://miao.su/images/2019/07/13/00575dc4.md.jpg)](https://miao.su/image/TNxKs)\n\n### 函数调用流程\n栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面：\n- 函数的返回地址；\n- 函数的参数；\n- 临时变量；\n- 保存的上下文：包括在函数调用前后需要保持不变的寄存器\n\n### 调用惯例\n~~~\n/*  \n\t根据下面的代码衍生出两个问题：\n\t1、参数进行压栈时，对于参数的选择是从左到右还是从右到左 \n\t2、函数参数的出栈是在func内进行还是在main中进行\n*/\n\n/*\n\t因此需要一个惯例来进行规定以下几个内容，C语言默认为_cdecl调用惯例   \n\t1、出栈方: 为调用函数方，即若main函数调用func函数则由main函数将参数进行出栈操作\n\t2、参数传值次序: 由右到左压栈\n\t3、名字修饰方式: 下划线加函数名\n*/\n\n// _cdecl默认不用加\nint _cdecl func(int a, int b) {\n\tint t_a = a;\n\tint t_b = b;\n\treturn t_a + t_b;\n}\n\nint main() {\n\tint ret = 0;\n\tret = func(10, 20);\n\tint  a = 0;\n\treturn 0;\n}\n~~~\n\n---\n\n## 指针的步长（通过实际代码进行理解）\n以下通过两个示例从易到难演示指针的步长。\n~~~\n/*\n\t 重难点！！！\n\t 指针的步长：指针变量+1，要向后跳多少个字节\n*/\n\nvoid test06() {\n\tchar buf[1024];\n\tint a = 100;\n\tmemset(buf, 0, 1024);\n\tmemcpy(buf + 1, &a, sizeof(int));\n\n    //以下为重难点！ \n    //buf为char类型，p+1跳1字节，通过强转使得p可以只跳1字节从而取到存放a的首地址后\n\tchar* p = buf;\t\n\t//由于a是int类型，需要转换int*取出存放a的4个字节，再用*取出这四个字节为a的值\n\tprintf(\"a= %d\\n\", *(int*)(p + 1));\n}\n~~~\n\n~~~\n#include<stddef.h>\n\nstruct Person {\n\tint a;\n\tchar b;\n\tchar buf[64];\n\tint d;\n};\n\nvoid test07() {\n\tstruct Person p = { 10,'b',\"Hello World\",100 };\n\t//offsetof()是宏函数，包含再stddef.h头文件中，计算结构体中变量偏移位置\n\t//printf(\"b off:%d\\n\", offsetof(struct Person, b));\n\n\t//使用Person类型指针取出d的值,重难点！！！！！！\n\tprintf(\"d= %d\\n\", *(int*)((char*)(&p) + offsetof(struct Person, d)));\n\t\n    /*  解析如下：\n\t\t1、&p 步长为Person的字节数\n\t\t2、(char*)(&p) 步长转换为1\n\t\t3、((char*)(&p) + offsetof(struct Person, d))  通过offsetof()求出d的偏移量并指向d的首地址\n\t\t4、(int*)((char*)(&p) + offsetof(struct Person, d))   d为int类型，使用int*获取d的四个字节地址\n\t\t5、*取出内存存放的d的值\n\t*/\n\n}\n~~~\n\n---\n\n##  宏函数\n宏函数不是一个真正的函数，只是预处理时做简单的文本替换\n~~~\n#define MYADD(x,y) ((x)+(y))\n\n//宏函数在一定的场景下比普通函数的运行效率要高\n//以空间换取时间\n//对于频繁调用的简单函数，可以使用宏函数代替，因为宏函数没有普通函数调用的开销（函数压栈，跳转，返回等）\n\nint main() {\n\tint a = 10, b = 20;\n\t//MYADD(a,b)实际只是被替换成了（（a）+（b））\n\tprintf(\"a + b = %d\\n\", MYADD(a, b));\n}\n~~~\n\nPS:太久没捣腾hexo了，命令都忘干净了，来来回回切换看效果花了好久，开头写的每晚花一点时间，今晚就整了快三个小时我也是醉了。。。Markdown语法也是只记得些简单的，写完一看网页效果看起来很不咋样，还写得啰嗦的要死，BUT，先这样吧，至少开了个头。","slug":"2019-Holiday-Note-01","published":1,"updated":"2019-07-15T14:29:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbih40002smjb1ucyiiq4","content":"<h1 id=\"Holiday-Note-01\"><a href=\"#Holiday-Note-01\" class=\"headerlink\" title=\"Holiday Note_01\"></a>Holiday Note_01</h1><p>今天是学校放假的第一天，趁着这个暑假，把丢了一个学期的博客捡起来。每晚花点时间总结下白天学到的知识点，这样不至于出现学一天忘两天的尴尬情况，也方便以后复习，目前计划是一天一篇📒📘📗📕📔📙，以上。</p>\n<a id=\"more\"></a>\n\n<p>先做个总结，今天学的不算是新知识了，大都是对以前学过知识的拓展补充因此学习起来难度并不是很大，比如数据类型的一些新使用场景和方式，自增语句以及判断语句 (++i，if(NULL == p)) 的优化写法，内存四区模型的拓展，栈区和堆区使用的注意要点（堆区的使用还是挺有讲究的这是一个重难点尤其是二级指针作为参数去操作时，使用不当，不仅内存泄露，还会出现野指针），其中关于栈和函数调用流程特别重要，写程序一定要清楚的知道自己写的哪些数据分别在哪个区内，什么时候会被回收，否则可能带来非常多的bug，最后就是指针的步长（这一块比较难以理解，而且是重点，理解后就可以写出各种花里胡哨的指针表示了哈哈），新学到的不过就是宏函数和调用惯例难度不大也不是重点了。</p>\n<hr>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"typedef的新用法\"><a href=\"#typedef的新用法\" class=\"headerlink\" title=\"typedef的新用法\"></a>typedef的新用法</h3><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">char</span> *<span class=\"built_in\">p1</span>,<span class=\"built_in\">p2</span><span class=\"comment\">;</span></span><br><span class=\"line\">//此写法将只有<span class=\"built_in\">p1</span>为指针类型，<span class=\"built_in\">p2</span>仍为char类型</span><br><span class=\"line\"></span><br><span class=\"line\">//解决方法如下</span><br><span class=\"line\"><span class=\"symbol\">typedef</span> char * pchar<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"symbol\">pchar</span> <span class=\"built_in\">p3</span>,<span class=\"built_in\">p4</span>,<span class=\"built_in\">p5</span><span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//且使用typedef有利于程序的移植性</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"void\"><a href=\"#void\" class=\"headerlink\" title=\"void *\"></a>void *</h3><figure class=\"highlight nimrod\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">    <span class=\"number\">1</span>、是所有类型指针的祖宗，又称万能指针</span><br><span class=\"line\">    <span class=\"number\">2</span>、任何类型的指针都不需要经过强制转换为<span class=\"built_in\">void</span>*</span><br><span class=\"line\">    <span class=\"number\">3</span>、主要用于数据结构的封装,基本上封装的函数参数均为<span class=\"built_in\">void</span>*</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"unsigned-int\"><a href=\"#unsigned-int\" class=\"headerlink\" title=\"unsigned int\"></a>unsigned int</h3><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">    <span class=\"number\">1</span>、sizeof()返回的值是unsigned <span class=\"built_in\">int</span></span><br><span class=\"line\">    <span class=\"number\">2</span>、一般情况，unsigned <span class=\"built_in\">int</span>与<span class=\"built_in\">int</span>进行运算得到的是前者,如 <span class=\"built_in\">int</span> i=<span class=\"number\">10</span>,j=<span class=\"number\">20</span>; i-j结果为<span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"number\">3</span>、切记数组在作为函数参数时会退化为指向数组首元素的指针，当使用sizeof() 求大小时，求得的值实际为指针占用大小</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内存分区的的一些补充\"><a href=\"#内存分区的的一些补充\" class=\"headerlink\" title=\"内存分区的的一些补充\"></a>内存分区的的一些补充</h3><ul>\n<li>数据区包括：堆，栈，全局/静态存储区。</li>\n<li>全局/静态存储区包括：常量区，全局区、静态区。</li>\n<li>常量区包括：字符串常量区、常变量区。</li>\n<li>代码区：存放程序编译后的二进制代码，不可寻址区。</li>\n</ul>\n<p>可以说，C/C++内存分区其实只有两个，即代码区和数据区。且全局const变量，字符串常量于常量区，无法通过直接或间接修改，局部const位于栈区，可以通过间接修改</p>\n<hr>\n<h2 id=\"内存分区知识点\"><a href=\"#内存分区知识点\" class=\"headerlink\" title=\"内存分区知识点\"></a>内存分区知识点</h2><h3 id=\"程序运行前\"><a href=\"#程序运行前\" class=\"headerlink\" title=\"程序运行前\"></a>程序运行前</h3><p>首先需要了解，C程序在运行之前，要经过如下所示四个步骤:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">步骤</th>\n<th align=\"center\">内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">预处理</td>\n<td align=\"center\">宏定义展开、头文件展开、条件编译，这里并不会检查语法</td>\n</tr>\n<tr>\n<td align=\"center\">编译</td>\n<td align=\"center\">检查语法，将预处理后文件编译生成汇编文件</td>\n</tr>\n<tr>\n<td align=\"center\">汇编</td>\n<td align=\"center\">将汇编文件生成目标文件(二进制文件)</td>\n</tr>\n<tr>\n<td align=\"center\">链接</td>\n<td align=\"center\">将目标文件链接为可执行程序</td>\n</tr>\n</tbody></table>\n<p>生成可执行性文件后在Linux下可以通过size命令查看可执行性程序的基本情况</p>\n<p>即在程序为被加载到内存中前，程序内部已经分好了三段区域</p>\n<ul>\n<li>代码区（text）注意代码区通常是只读的，共享的。其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。</li>\n<li>数据区（data）该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。</li>\n<li>未初始化数据区（bss）存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。</li>\n</ul>\n<h3 id=\"程序运行后\"><a href=\"#程序运行后\" class=\"headerlink\" title=\"程序运行后\"></a>程序运行后</h3><p>程序运行之后，代码区，数据区以及未初始化数据区的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。</p>\n<h4 id=\"栈区（stack）\"><a href=\"#栈区（stack）\" class=\"headerlink\" title=\"栈区（stack）\"></a>栈区（stack）</h4><p>栈区使用不当可能会造成程序运行结果出错，以下为两个错误示例，需要十分注意，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//栈区内存自动释放，不需要程序手动管理，</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> * <span class=\"title\">myFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;<span class=\"comment\">//临时变量a存于栈上</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不要返回局部变量的地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* p = myFunc();</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, *p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">getString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> str[] = <span class=\"string\">\"Hello World!\"</span>;<span class=\"comment\">//str在getString()结束后被销毁</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* s = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\ts = getString();</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"s=%s\"</span>, s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//此使已经不关心值是多少，因为局部变量a的内存空间已经被回收</span></span><br><span class=\"line\">\ttest01();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Hello World!被存入常量区，但是str存在与栈区，getString（）结束后被回收，str地址存放值不再是HelloWorld</span></span><br><span class=\"line\">\ttest02();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下为栈的生长方向示意图，向低地址生长，压栈（push）使得栈顶元素的地址变小，出栈（pop）使得栈顶元素的地址变大。<br><img src=\"https://miao.su/images/2019/07/13/8edce2a9aae27a724903e.jpg\" alt=\"8edce2a9aae27a724903e.jpg\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//栈和内存生长方式的理解代码</span></span><br><span class=\"line\"><span class=\"comment\">//1. 栈的生长方向</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c = <span class=\"number\">30</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> d = <span class=\"number\">40</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a = %d\\n\"</span>, &amp;a);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"b = %d\\n\"</span>, &amp;b);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"c = %d\\n\"</span>, &amp;c);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"d = %d\\n\"</span>, &amp;d);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//a的地址大于b的地址，故而生长方向向下</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. 内存生长方向(小端模式)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//高位字节 -&gt; 地位字节</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num = <span class=\"number\">0xaabbccdd</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>* p = &amp;num;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//从首地址开始的第一个字节</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>,*p);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>, *(p + <span class=\"number\">1</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>, *(p + <span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"堆区（heap）\"><a href=\"#堆区（heap）\" class=\"headerlink\" title=\"堆区（heap）\"></a>堆区（heap）</h3><p>以下为堆区使用的两个错误例子，导致了内存泄露，且堆释放不当还可能造成野指针，因此需要十分注意！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">getSpace</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* p = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * <span class=\"number\">5</span>);<span class=\"comment\">//p是在栈上，但是malloc分配的20个字节在堆上</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == p) &#123;<span class=\"comment\">//该写法NULL放前边防止出现写成p=NULL且不报错的情况</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t <span class=\"comment\">//只要是连续分配的内存空间都可以用下标来访问</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i) &#123;<span class=\"comment\">//++i效率高</span></span><br><span class=\"line\">\t\tp[i] = <span class=\"number\">100</span> + i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test03</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tallocateSpace(p); <span class=\"comment\">//执行完毕后，p仍然是NULL</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"p= %s\"</span>, p);<span class=\"comment\">//打印结果为NULL，造成了内存泄露！！！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">allocateSpace</span><span class=\"params\">(<span class=\"keyword\">char</span>* p)</span> </span>&#123;</span><br><span class=\"line\">\tp = <span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);<span class=\"comment\">//开辟了堆空间，p指向的堆空间存放了HelloWorld</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(p, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(p, <span class=\"string\">\"Hello World\"</span>);<span class=\"comment\">//p存放与栈上，结束后销毁，堆空间的地址从此 未知!</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test04</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tallocateSpace(p); <span class=\"comment\">//执行完毕后，p仍然是NULL</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"p= %s\"</span>, p);<span class=\"comment\">//打印结果为NULL，造成了内存泄露！！！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要想正确使用堆区，关键在于找到分配的堆空间的地址，一定不能丢掉开辟堆空间的地址，以下示例使用了二级指针进行操作</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">allocateSpace02</span><span class=\"params\">(<span class=\"keyword\">char</span>** p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* temp = <span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(temp, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(temp, <span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//关键步骤！</span></span><br><span class=\"line\">    *p = temp;</span><br><span class=\"line\">    <span class=\"comment\">//让传递过来的p指针指向开辟堆空间的地址，因此结束释放了形参char**p和临时变量char*temp也就无所谓了</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test05</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tallocateSpace02(&amp;p);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"p= %s\\n\"</span>, p);</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">\tp = <span class=\"literal\">NULL</span>;<span class=\"comment\">//free(p) 仅仅只是将该堆空间释放，p若不置为空则成为野指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下为allocateSpace02函数内存分配示意图为辅助理解<br><img src=\"https://miao.su/images/2019/07/13/heap21e261.png\" alt=\"heap21e261.png\"></p>\n<hr>\n<h2 id=\"函数调用模型\"><a href=\"#函数调用模型\" class=\"headerlink\" title=\"函数调用模型\"></a>函数调用模型</h2><p>函数调用流程示意图如下所示 (十分重要，写代码时对于每一条语句的执行心中都要有此模型)：</p>\n<p><a href=\"https://miao.su/image/TNrPP\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/13/001dbea1.md.jpg\" alt=\"001dbea1.md.jpg\"></a><br><a href=\"https://miao.su/image/TNEdB\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/13/002b3804.md.jpg\" alt=\"002b3804.md.jpg\"></a><br><a href=\"https://miao.su/image/TNJ5J\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/13/00364141.md.jpg\" alt=\"00364141.md.jpg\"></a><br><a href=\"https://miao.su/image/TNdUm\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/13/004f551d.md.jpg\" alt=\"004f551d.md.jpg\"></a><br><a href=\"https://miao.su/image/TNxKs\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/13/00575dc4.md.jpg\" alt=\"00575dc4.md.jpg\"></a></p>\n<h3 id=\"函数调用流程\"><a href=\"#函数调用流程\" class=\"headerlink\" title=\"函数调用流程\"></a>函数调用流程</h3><p>栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面：</p>\n<ul>\n<li>函数的返回地址；</li>\n<li>函数的参数；</li>\n<li>临时变量；</li>\n<li>保存的上下文：包括在函数调用前后需要保持不变的寄存器</li>\n</ul>\n<h3 id=\"调用惯例\"><a href=\"#调用惯例\" class=\"headerlink\" title=\"调用惯例\"></a>调用惯例</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">\t根据下面的代码衍生出两个问题：</span></span><br><span class=\"line\"><span class=\"comment\">\t1、参数进行压栈时，对于参数的选择是从左到右还是从右到左 </span></span><br><span class=\"line\"><span class=\"comment\">\t2、函数参数的出栈是在func内进行还是在main中进行</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t因此需要一个惯例来进行规定以下几个内容，C语言默认为_cdecl调用惯例   </span></span><br><span class=\"line\"><span class=\"comment\">\t1、出栈方: 为调用函数方，即若main函数调用func函数则由main函数将参数进行出栈操作</span></span><br><span class=\"line\"><span class=\"comment\">\t2、参数传值次序: 由右到左压栈</span></span><br><span class=\"line\"><span class=\"comment\">\t3、名字修饰方式: 下划线加函数名</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// _cdecl默认不用加</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> _cdecl <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t_a = a;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t_b = b;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t_a + t_b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tret = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(10, 20)</span>;</span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"title\">int</span>  <span class=\"title\">a</span> = 0;</span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"title\">return</span> 0;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"指针的步长（通过实际代码进行理解）\"><a href=\"#指针的步长（通过实际代码进行理解）\" class=\"headerlink\" title=\"指针的步长（通过实际代码进行理解）\"></a>指针的步长（通过实际代码进行理解）</h2><p>以下通过两个示例从易到难演示指针的步长。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t 重难点！！！</span></span><br><span class=\"line\"><span class=\"comment\">\t 指针的步长：指针变量+1，要向后跳多少个字节</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test06</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(buf, <span class=\"number\">0</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(buf + <span class=\"number\">1</span>, &amp;a, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//以下为重难点！ </span></span><br><span class=\"line\">    <span class=\"comment\">//buf为char类型，p+1跳1字节，通过强转使得p可以只跳1字节从而取到存放a的首地址后</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* p = buf;\t</span><br><span class=\"line\">\t<span class=\"comment\">//由于a是int类型，需要转换int*取出存放a的4个字节，再用*取出这四个字节为a的值</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a= %d\\n\"</span>, *(<span class=\"keyword\">int</span>*)(p + <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stddef.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> b;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">64</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test07</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p</span> = &#123;</span> <span class=\"number\">10</span>,<span class=\"string\">'b'</span>,<span class=\"string\">\"Hello World\"</span>,<span class=\"number\">100</span> &#125;;</span><br><span class=\"line\">\t<span class=\"comment\">//offsetof()是宏函数，包含再stddef.h头文件中，计算结构体中变量偏移位置</span></span><br><span class=\"line\">\t<span class=\"comment\">//printf(\"b off:%d\\n\", offsetof(struct Person, b));</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//使用Person类型指针取出d的值,重难点！！！！！！</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"d= %d\\n\"</span>, *(<span class=\"keyword\">int</span>*)((<span class=\"keyword\">char</span>*)(&amp;p) + offsetof(struct Person, d)));</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/*  解析如下：</span></span><br><span class=\"line\"><span class=\"comment\">\t\t1、&amp;p 步长为Person的字节数</span></span><br><span class=\"line\"><span class=\"comment\">\t\t2、(char*)(&amp;p) 步长转换为1</span></span><br><span class=\"line\"><span class=\"comment\">\t\t3、((char*)(&amp;p) + offsetof(struct Person, d))  通过offsetof()求出d的偏移量并指向d的首地址</span></span><br><span class=\"line\"><span class=\"comment\">\t\t4、(int*)((char*)(&amp;p) + offsetof(struct Person, d))   d为int类型，使用int*获取d的四个字节地址</span></span><br><span class=\"line\"><span class=\"comment\">\t\t5、*取出内存存放的d的值</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"宏函数\"><a href=\"#宏函数\" class=\"headerlink\" title=\"宏函数\"></a>宏函数</h2><p>宏函数不是一个真正的函数，只是预处理时做简单的文本替换</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYADD(x,y) ((x)+(y))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//宏函数在一定的场景下比普通函数的运行效率要高</span></span><br><span class=\"line\"><span class=\"comment\">//以空间换取时间</span></span><br><span class=\"line\"><span class=\"comment\">//对于频繁调用的简单函数，可以使用宏函数代替，因为宏函数没有普通函数调用的开销（函数压栈，跳转，返回等）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>, b = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//MYADD(a,b)实际只是被替换成了（（a）+（b））</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a + b = %d\\n\"</span>, MYADD(a, b));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS:太久没捣腾hexo了，命令都忘干净了，来来回回切换看效果花了好久，开头写的每晚花一点时间，今晚就整了快三个小时我也是醉了。。。Markdown语法也是只记得些简单的，写完一看网页效果看起来很不咋样，还写得啰嗦的要死，BUT，先这样吧，至少开了个头。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-01\"><a href=\"#Holiday-Note-01\" class=\"headerlink\" title=\"Holiday Note_01\"></a>Holiday Note_01</h1><p>今天是学校放假的第一天，趁着这个暑假，把丢了一个学期的博客捡起来。每晚花点时间总结下白天学到的知识点，这样不至于出现学一天忘两天的尴尬情况，也方便以后复习，目前计划是一天一篇📒📘📗📕📔📙，以上。</p>","more":"<p>先做个总结，今天学的不算是新知识了，大都是对以前学过知识的拓展补充因此学习起来难度并不是很大，比如数据类型的一些新使用场景和方式，自增语句以及判断语句 (++i，if(NULL == p)) 的优化写法，内存四区模型的拓展，栈区和堆区使用的注意要点（堆区的使用还是挺有讲究的这是一个重难点尤其是二级指针作为参数去操作时，使用不当，不仅内存泄露，还会出现野指针），其中关于栈和函数调用流程特别重要，写程序一定要清楚的知道自己写的哪些数据分别在哪个区内，什么时候会被回收，否则可能带来非常多的bug，最后就是指针的步长（这一块比较难以理解，而且是重点，理解后就可以写出各种花里胡哨的指针表示了哈哈），新学到的不过就是宏函数和调用惯例难度不大也不是重点了。</p>\n<hr>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"typedef的新用法\"><a href=\"#typedef的新用法\" class=\"headerlink\" title=\"typedef的新用法\"></a>typedef的新用法</h3><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">char</span> *<span class=\"built_in\">p1</span>,<span class=\"built_in\">p2</span><span class=\"comment\">;</span></span><br><span class=\"line\">//此写法将只有<span class=\"built_in\">p1</span>为指针类型，<span class=\"built_in\">p2</span>仍为char类型</span><br><span class=\"line\"></span><br><span class=\"line\">//解决方法如下</span><br><span class=\"line\"><span class=\"symbol\">typedef</span> char * pchar<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"symbol\">pchar</span> <span class=\"built_in\">p3</span>,<span class=\"built_in\">p4</span>,<span class=\"built_in\">p5</span><span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//且使用typedef有利于程序的移植性</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"void\"><a href=\"#void\" class=\"headerlink\" title=\"void *\"></a>void *</h3><figure class=\"highlight nimrod\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">    <span class=\"number\">1</span>、是所有类型指针的祖宗，又称万能指针</span><br><span class=\"line\">    <span class=\"number\">2</span>、任何类型的指针都不需要经过强制转换为<span class=\"built_in\">void</span>*</span><br><span class=\"line\">    <span class=\"number\">3</span>、主要用于数据结构的封装,基本上封装的函数参数均为<span class=\"built_in\">void</span>*</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"unsigned-int\"><a href=\"#unsigned-int\" class=\"headerlink\" title=\"unsigned int\"></a>unsigned int</h3><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">    <span class=\"number\">1</span>、sizeof()返回的值是unsigned <span class=\"built_in\">int</span></span><br><span class=\"line\">    <span class=\"number\">2</span>、一般情况，unsigned <span class=\"built_in\">int</span>与<span class=\"built_in\">int</span>进行运算得到的是前者,如 <span class=\"built_in\">int</span> i=<span class=\"number\">10</span>,j=<span class=\"number\">20</span>; i-j结果为<span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"number\">3</span>、切记数组在作为函数参数时会退化为指向数组首元素的指针，当使用sizeof() 求大小时，求得的值实际为指针占用大小</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内存分区的的一些补充\"><a href=\"#内存分区的的一些补充\" class=\"headerlink\" title=\"内存分区的的一些补充\"></a>内存分区的的一些补充</h3><ul>\n<li>数据区包括：堆，栈，全局/静态存储区。</li>\n<li>全局/静态存储区包括：常量区，全局区、静态区。</li>\n<li>常量区包括：字符串常量区、常变量区。</li>\n<li>代码区：存放程序编译后的二进制代码，不可寻址区。</li>\n</ul>\n<p>可以说，C/C++内存分区其实只有两个，即代码区和数据区。且全局const变量，字符串常量于常量区，无法通过直接或间接修改，局部const位于栈区，可以通过间接修改</p>\n<hr>\n<h2 id=\"内存分区知识点\"><a href=\"#内存分区知识点\" class=\"headerlink\" title=\"内存分区知识点\"></a>内存分区知识点</h2><h3 id=\"程序运行前\"><a href=\"#程序运行前\" class=\"headerlink\" title=\"程序运行前\"></a>程序运行前</h3><p>首先需要了解，C程序在运行之前，要经过如下所示四个步骤:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">步骤</th>\n<th align=\"center\">内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">预处理</td>\n<td align=\"center\">宏定义展开、头文件展开、条件编译，这里并不会检查语法</td>\n</tr>\n<tr>\n<td align=\"center\">编译</td>\n<td align=\"center\">检查语法，将预处理后文件编译生成汇编文件</td>\n</tr>\n<tr>\n<td align=\"center\">汇编</td>\n<td align=\"center\">将汇编文件生成目标文件(二进制文件)</td>\n</tr>\n<tr>\n<td align=\"center\">链接</td>\n<td align=\"center\">将目标文件链接为可执行程序</td>\n</tr>\n</tbody></table>\n<p>生成可执行性文件后在Linux下可以通过size命令查看可执行性程序的基本情况</p>\n<p>即在程序为被加载到内存中前，程序内部已经分好了三段区域</p>\n<ul>\n<li>代码区（text）注意代码区通常是只读的，共享的。其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。</li>\n<li>数据区（data）该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。</li>\n<li>未初始化数据区（bss）存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。</li>\n</ul>\n<h3 id=\"程序运行后\"><a href=\"#程序运行后\" class=\"headerlink\" title=\"程序运行后\"></a>程序运行后</h3><p>程序运行之后，代码区，数据区以及未初始化数据区的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。</p>\n<h4 id=\"栈区（stack）\"><a href=\"#栈区（stack）\" class=\"headerlink\" title=\"栈区（stack）\"></a>栈区（stack）</h4><p>栈区使用不当可能会造成程序运行结果出错，以下为两个错误示例，需要十分注意，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//栈区内存自动释放，不需要程序手动管理，</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> * <span class=\"title\">myFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;<span class=\"comment\">//临时变量a存于栈上</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不要返回局部变量的地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* p = myFunc();</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, *p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">getString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> str[] = <span class=\"string\">\"Hello World!\"</span>;<span class=\"comment\">//str在getString()结束后被销毁</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* s = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\ts = getString();</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"s=%s\"</span>, s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//此使已经不关心值是多少，因为局部变量a的内存空间已经被回收</span></span><br><span class=\"line\">\ttest01();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Hello World!被存入常量区，但是str存在与栈区，getString（）结束后被回收，str地址存放值不再是HelloWorld</span></span><br><span class=\"line\">\ttest02();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下为栈的生长方向示意图，向低地址生长，压栈（push）使得栈顶元素的地址变小，出栈（pop）使得栈顶元素的地址变大。<br><img src=\"https://miao.su/images/2019/07/13/8edce2a9aae27a724903e.jpg\" alt=\"8edce2a9aae27a724903e.jpg\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//栈和内存生长方式的理解代码</span></span><br><span class=\"line\"><span class=\"comment\">//1. 栈的生长方向</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c = <span class=\"number\">30</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> d = <span class=\"number\">40</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a = %d\\n\"</span>, &amp;a);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"b = %d\\n\"</span>, &amp;b);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"c = %d\\n\"</span>, &amp;c);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"d = %d\\n\"</span>, &amp;d);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//a的地址大于b的地址，故而生长方向向下</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. 内存生长方向(小端模式)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//高位字节 -&gt; 地位字节</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num = <span class=\"number\">0xaabbccdd</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>* p = &amp;num;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//从首地址开始的第一个字节</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>,*p);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>, *(p + <span class=\"number\">1</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>, *(p + <span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"堆区（heap）\"><a href=\"#堆区（heap）\" class=\"headerlink\" title=\"堆区（heap）\"></a>堆区（heap）</h3><p>以下为堆区使用的两个错误例子，导致了内存泄露，且堆释放不当还可能造成野指针，因此需要十分注意！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">getSpace</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* p = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * <span class=\"number\">5</span>);<span class=\"comment\">//p是在栈上，但是malloc分配的20个字节在堆上</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == p) &#123;<span class=\"comment\">//该写法NULL放前边防止出现写成p=NULL且不报错的情况</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t <span class=\"comment\">//只要是连续分配的内存空间都可以用下标来访问</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i) &#123;<span class=\"comment\">//++i效率高</span></span><br><span class=\"line\">\t\tp[i] = <span class=\"number\">100</span> + i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test03</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tallocateSpace(p); <span class=\"comment\">//执行完毕后，p仍然是NULL</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"p= %s\"</span>, p);<span class=\"comment\">//打印结果为NULL，造成了内存泄露！！！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">allocateSpace</span><span class=\"params\">(<span class=\"keyword\">char</span>* p)</span> </span>&#123;</span><br><span class=\"line\">\tp = <span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);<span class=\"comment\">//开辟了堆空间，p指向的堆空间存放了HelloWorld</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(p, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(p, <span class=\"string\">\"Hello World\"</span>);<span class=\"comment\">//p存放与栈上，结束后销毁，堆空间的地址从此 未知!</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test04</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tallocateSpace(p); <span class=\"comment\">//执行完毕后，p仍然是NULL</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"p= %s\"</span>, p);<span class=\"comment\">//打印结果为NULL，造成了内存泄露！！！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要想正确使用堆区，关键在于找到分配的堆空间的地址，一定不能丢掉开辟堆空间的地址，以下示例使用了二级指针进行操作</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">allocateSpace02</span><span class=\"params\">(<span class=\"keyword\">char</span>** p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* temp = <span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(temp, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(temp, <span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//关键步骤！</span></span><br><span class=\"line\">    *p = temp;</span><br><span class=\"line\">    <span class=\"comment\">//让传递过来的p指针指向开辟堆空间的地址，因此结束释放了形参char**p和临时变量char*temp也就无所谓了</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test05</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tallocateSpace02(&amp;p);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"p= %s\\n\"</span>, p);</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">\tp = <span class=\"literal\">NULL</span>;<span class=\"comment\">//free(p) 仅仅只是将该堆空间释放，p若不置为空则成为野指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下为allocateSpace02函数内存分配示意图为辅助理解<br><img src=\"https://miao.su/images/2019/07/13/heap21e261.png\" alt=\"heap21e261.png\"></p>\n<hr>\n<h2 id=\"函数调用模型\"><a href=\"#函数调用模型\" class=\"headerlink\" title=\"函数调用模型\"></a>函数调用模型</h2><p>函数调用流程示意图如下所示 (十分重要，写代码时对于每一条语句的执行心中都要有此模型)：</p>\n<p><a href=\"https://miao.su/image/TNrPP\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/13/001dbea1.md.jpg\" alt=\"001dbea1.md.jpg\"></a><br><a href=\"https://miao.su/image/TNEdB\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/13/002b3804.md.jpg\" alt=\"002b3804.md.jpg\"></a><br><a href=\"https://miao.su/image/TNJ5J\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/13/00364141.md.jpg\" alt=\"00364141.md.jpg\"></a><br><a href=\"https://miao.su/image/TNdUm\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/13/004f551d.md.jpg\" alt=\"004f551d.md.jpg\"></a><br><a href=\"https://miao.su/image/TNxKs\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/13/00575dc4.md.jpg\" alt=\"00575dc4.md.jpg\"></a></p>\n<h3 id=\"函数调用流程\"><a href=\"#函数调用流程\" class=\"headerlink\" title=\"函数调用流程\"></a>函数调用流程</h3><p>栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面：</p>\n<ul>\n<li>函数的返回地址；</li>\n<li>函数的参数；</li>\n<li>临时变量；</li>\n<li>保存的上下文：包括在函数调用前后需要保持不变的寄存器</li>\n</ul>\n<h3 id=\"调用惯例\"><a href=\"#调用惯例\" class=\"headerlink\" title=\"调用惯例\"></a>调用惯例</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">\t根据下面的代码衍生出两个问题：</span></span><br><span class=\"line\"><span class=\"comment\">\t1、参数进行压栈时，对于参数的选择是从左到右还是从右到左 </span></span><br><span class=\"line\"><span class=\"comment\">\t2、函数参数的出栈是在func内进行还是在main中进行</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t因此需要一个惯例来进行规定以下几个内容，C语言默认为_cdecl调用惯例   </span></span><br><span class=\"line\"><span class=\"comment\">\t1、出栈方: 为调用函数方，即若main函数调用func函数则由main函数将参数进行出栈操作</span></span><br><span class=\"line\"><span class=\"comment\">\t2、参数传值次序: 由右到左压栈</span></span><br><span class=\"line\"><span class=\"comment\">\t3、名字修饰方式: 下划线加函数名</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// _cdecl默认不用加</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> _cdecl <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t_a = a;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> t_b = b;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t_a + t_b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tret = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(10, 20)</span>;</span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"title\">int</span>  <span class=\"title\">a</span> = 0;</span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"title\">return</span> 0;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"指针的步长（通过实际代码进行理解）\"><a href=\"#指针的步长（通过实际代码进行理解）\" class=\"headerlink\" title=\"指针的步长（通过实际代码进行理解）\"></a>指针的步长（通过实际代码进行理解）</h2><p>以下通过两个示例从易到难演示指针的步长。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t 重难点！！！</span></span><br><span class=\"line\"><span class=\"comment\">\t 指针的步长：指针变量+1，要向后跳多少个字节</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test06</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(buf, <span class=\"number\">0</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(buf + <span class=\"number\">1</span>, &amp;a, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//以下为重难点！ </span></span><br><span class=\"line\">    <span class=\"comment\">//buf为char类型，p+1跳1字节，通过强转使得p可以只跳1字节从而取到存放a的首地址后</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* p = buf;\t</span><br><span class=\"line\">\t<span class=\"comment\">//由于a是int类型，需要转换int*取出存放a的4个字节，再用*取出这四个字节为a的值</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a= %d\\n\"</span>, *(<span class=\"keyword\">int</span>*)(p + <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stddef.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> b;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">64</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test07</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p</span> = &#123;</span> <span class=\"number\">10</span>,<span class=\"string\">'b'</span>,<span class=\"string\">\"Hello World\"</span>,<span class=\"number\">100</span> &#125;;</span><br><span class=\"line\">\t<span class=\"comment\">//offsetof()是宏函数，包含再stddef.h头文件中，计算结构体中变量偏移位置</span></span><br><span class=\"line\">\t<span class=\"comment\">//printf(\"b off:%d\\n\", offsetof(struct Person, b));</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//使用Person类型指针取出d的值,重难点！！！！！！</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"d= %d\\n\"</span>, *(<span class=\"keyword\">int</span>*)((<span class=\"keyword\">char</span>*)(&amp;p) + offsetof(struct Person, d)));</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/*  解析如下：</span></span><br><span class=\"line\"><span class=\"comment\">\t\t1、&amp;p 步长为Person的字节数</span></span><br><span class=\"line\"><span class=\"comment\">\t\t2、(char*)(&amp;p) 步长转换为1</span></span><br><span class=\"line\"><span class=\"comment\">\t\t3、((char*)(&amp;p) + offsetof(struct Person, d))  通过offsetof()求出d的偏移量并指向d的首地址</span></span><br><span class=\"line\"><span class=\"comment\">\t\t4、(int*)((char*)(&amp;p) + offsetof(struct Person, d))   d为int类型，使用int*获取d的四个字节地址</span></span><br><span class=\"line\"><span class=\"comment\">\t\t5、*取出内存存放的d的值</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"宏函数\"><a href=\"#宏函数\" class=\"headerlink\" title=\"宏函数\"></a>宏函数</h2><p>宏函数不是一个真正的函数，只是预处理时做简单的文本替换</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYADD(x,y) ((x)+(y))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//宏函数在一定的场景下比普通函数的运行效率要高</span></span><br><span class=\"line\"><span class=\"comment\">//以空间换取时间</span></span><br><span class=\"line\"><span class=\"comment\">//对于频繁调用的简单函数，可以使用宏函数代替，因为宏函数没有普通函数调用的开销（函数压栈，跳转，返回等）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>, b = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//MYADD(a,b)实际只是被替换成了（（a）+（b））</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a + b = %d\\n\"</span>, MYADD(a, b));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS:太久没捣腾hexo了，命令都忘干净了，来来回回切换看效果花了好久，开头写的每晚花一点时间，今晚就整了快三个小时我也是醉了。。。Markdown语法也是只记得些简单的，写完一看网页效果看起来很不咋样，还写得啰嗦的要死，BUT，先这样吧，至少开了个头。</p>"},{"title":"Holiday Note_02","date":"2019-07-14T11:23:03.000Z","_content":"\n# Holiday Note_02\n\n放假第二天。今天学的主要只有两块内容：分别是**字符串相关**(字符串格式化函数使用，字符串的拷贝和反转实现方法，查找字串的方法)；**指针作为函数参数时具有的输入输出特性**相关(指针间接赋值，主调函数分配内存与被调函数分配的内存的使用区别，二级指针对指定文件分配，释放空间练习)。难点主要在于理解指针作为函数参数时需要使用哪种类型接收，指针的间接赋值时二级指针的使用，查找子串功能实现时各个指针实现的功能。\n\n<!-- more -->\n\n---\n\n## 字符串相关\n以下为sprintf函数以及sscanf函数在格式化字符串时的一些注意要点以及用法场景。\n### sprintf 函数\nsprintf简单来讲就是按照指定格式，将字符串进行格式化后放入char * str中，与printf相比不过是多了一个接收存放格式化后字符串的指针。具体函数参数以及返回值如下所示。\n\n~~~\nint sprintf(char* str, const char* format, ...);\n功能：\n\t根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 '\\0'为止。\n参数：\n\tstr：字符串首地址\n\tformat：字符串格式，用法和printf()一样\n返回值：\n\t成功：实际格式化的字符个数\n\t失败： - 1\n~~~\n\n这是sprintf的三种常见用法\n\n#### 格式化字符串\n~~~\nchar buf[1024] = { 0 };\nsprintf(buf, \"Hello %s!\", \"World\");\nprintf(\"%s\\n\", buf);//输出结果为：Hello World!\n~~~\n\n#### 拼接字符串\n~~~\nchar* s1 = \"Hello\";\nchar* s2 = \"World!\";\nsprintf(buf, \"%s %s\", s1, s2);\nprintf(\"%s\\n\", buf);//输出结果为：Hello World!\n~~~\n\n#### 数字转换为字符串\n~~~\nint number = 666;\nsprintf(buf, \"%d\", number);\nprintf(\"%s\\n\", buf);//输出结果为666\n~~~\n\n\n---\n\n\n### sscanf 函数\nsscanf函数的主要功能为从指定的字符串中按照给定的格式读取并转换出来。如果说sprintf是放进去，那么sscanf则为取出来，且均按照指定格式进行放入和取出。\n\n~~~\nint sscanf(const char* str, const char* format, ...);\n功能：\n\t从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。\n参数：\n\tstr：指定的字符串首地址\n\tformat：字符串格式，用法和scanf()一样\n返回值：\n\t成功：实际读取的字符个数\n\t失败： - 1\n~~~\n\n\n以下为sscanf的**六种**常见格式与作用\n\n#### 1、%*s或%*d\t\n~~~\nchar* str = \"123456abcdefg\";\nchar buf[1024] = { 0 };\nsscanf(str, \"%*d%s\", buf);\nprintf(\"buf: %s\\n\", buf);//输出结果为buf: abcdefg\n~~~\n\n**注意**忽略字符串时是忽略到空格或者'\\t'\n~~~\nchar* str1 = \"abcdef\\t123456\";\nchar buf1[1024] = { 0 };\nsscanf(str1, \"%*s%s\", buf1);//此使输出结果为buf: 123456\nprintf(\"buf1: %s\\n\", buf1);//若str1字母与数字间无空格或'\\t'，将会把str1全部忽略掉，这种情况输出将为buf1:\n~~~\n\n#### 2、%[width]s\n~~~\nchar* str = \"123456abcdefg\";\nchar buf[1024] = { 0 };\nsscanf(str, \"%7s\", buf);\nprintf(\"buf: %s\\n\", buf);//输出结果为buf: 123456a\n~~~\n\n以下四种特点均为只要与要求不符合立即不进行匹配。简单说就是，不是将整个字符串中匹配的筛选出来，而是从字符串头部开始，判断一个字符格式不符合的即退出或者至'\\0'退出\n\n#### 3、%[a-z]\n~~~\nchar* str = \"123456abcdefg\";\nchar buf[1024] = { 0 };\nsscanf(str, \"%*d%[a-c]\", buf);//若不加忽略%*d的话，由于第一个字符为'1'，将直接退出，不拷贝\nprintf(\"buf: %s\\n\", buf);//输出结果为buf: abc\n~~~\n\n#### 4、%[aBc]\n~~~\nchar* str = \"aABb\";\nchar buf[1024] = { 0 };\nsscanf(str, \"%[aAb]\", buf);//从第一个开始比对，若不同依旧是直接不拷贝\nprintf(\"buf: %s\\n\", buf);//输出结果为buf: aA\n~~~\n\n#### 5、%[^a]\n~~~\nchar* str = \"aABb\";\nchar buf[1024] = { 0 };\nsscanf(str, \"%[^B]\", buf);//从第一个开始比对，若不同依旧是直接不拷贝\nprintf(\"buf: %s\\n\", buf);//输出结果为buf:aA\n~~~\n\n#### 6、%[^a-z]\n~~~\nchar* str = \"cdaABb\";\nchar buf[1024] = { 0 };\nsscanf(str, \"%[^a-b]\", buf);//从第一个开始比对，若不同依旧是直接不拷贝\nprintf(\"buf: %s\\n\", buf);//输出结果为buf:cd\n~~~\n\n#### 综合使用演示\n~~~\n//取出12uiop\nchar* str = \"abSi#12uiop@Tsi(\";\nchar buf[1024] = {0};\n//sscanf(str, \"%*[^#]\", buf);//输出结果buf:\n//sscanf(str, \"%*[^#]%s\", buf);//输出结果buf:#12uiop@Tsi(\nsscanf(str, \"%*[^#]#%[^@]\", buf);//输出结果:buf: 12uiop\nprintf(\"buf: %s\\n\", buf);\n~~~\n\n***\n\n### 字符串与字符数组的易错点\n*最重要记住一句话：字符串是以0或者'\\0'结尾的字符数组，(数字0和字符'\\0'等价)*\n\n#### 字符数组初始化\n~~~\n//字符数组只能初始化5个字符，当输出的时候，从开始位置 直到找到0结束\nchar str1[] = { 'h','e','l','l','o',};\nprintf(\"str1 = %s\", str1);//输出结果将为 str1 = hello烫烫烫剃*堺?\n\n//如果以字符串初始化，那么编译器默认会在字符串尾部添加'\\0'\nchar str2[] = \"hello\";\n~~~\n\n\n#### sizeof与strlen差别\n~~~\n//sizeof计算数组大小，数组包含'\\0'字符\n//strlen计算字符串的长度，到'\\0'结束\nprintf(\"sizeof str:%d\\n\", sizeof(str2));//结果为6\nprintf(\"strlen str:%d\\n\", strlen(str2));//结果为5\n~~~\n\n---\n\n### 实现字符串拷贝函数的三种写法\n三种方法由易到难，由数组到指针，其实指针理解了很简单。\n\n主调用函数为\n~~~\ntest05() {\n\tchar* source = \"Hello World\";\n\tchar buf[1024];\n\tcopyString01(buf, source);\n\tcopyString02(buf, source);\n\tcopyString03(buf, source);\n\tprintf(\"%s\\n\", buf);\n}\n~~~\n\n#### 方法1\n~~~\nvoid copyString01(char*dest,const char*source) {\n\tint len = strlen(source);\n\tfor (int i = 0; i < len; ++i) {\n\t\tdest[i] = source[i];\n\t}\n\tdest[len] = '\\0';\n}\n~~~\n\n#### 方法2\n~~~\nvoid copyString02(char* dest, const char* source) {\n\twhile (*source) {\n\t\t*dest = *source;\n\t\t++dest;\n\t\t++source;\n\t}\n\t*dest = '\\0';\n}\n~~~\n\n#### 我认为最好的方法3\n此写法，简洁优雅。\n~~~\nvoid copyString03(char* dest, const char* source) {\n\twhile (*(dest++) = *(source++));\n}\n~~~\n\n***\n\n### 指针和数组方式实现字符串反转\n两种写法大同小异，思路均为两个变量，头尾互换即可，关键点在于反转后的字符串结尾进行 '\\0' 操作。\n#### 数组实现\n~~~\nvoid reverseString01(char *str) {\n\tif (NULL == str)\n\t\treturn;\n\tint len = strlen(str);\n\t//以下为数组方式实现\n\tint start = 0;\n\tint end = len - 1;\n\twhile (start < end) {\n\t\tchar temp;\n\t\ttemp = str[start];\n\t\tstr[start] = str[end];\n\t\tstr[end] = temp;\n\t\t++start;\n\t\t--end;\n\t}\n\tstr[len] = '\\0';\n}\n~~~\n\n\n#### 指针实现\n~~~\nif (NULL == str)\n\t\treturn;\n\tint len = strlen(str);\t\n\n\t//以下为指针方式实现\n\tchar* pStart = str;\n\tchar* pEnd = str + len - 1;\n\twhile (pStart < pEnd) {\n\t\tchar temp;\n\t\ttemp = *pStart;\n\t\t*pStart = *pEnd;\n\t\t*pEnd = temp;\n\n\t\t++pStart;\n\t\t--pEnd;\n\t}\n\t*(str + len) = '\\0';\n~~~\n\n***\n\n### 实现查找子串\n该功能理解稍有难度，主要是理清楚逻辑。例如字符串为\"abdecdfw\",\"df\",首先思考的是找到字符串与字串第一个字符是否吻合，且定义一个指针记录哪一个字符与字串开始吻合，当找到了吻合的字符 'd' 后，关键步骤为，定义两个指针，一个指向字符串此时的位置，一个指向子串第一个字符的位置，分别进行遍历比较，应设定有两种退出情况，一种是比较字符不相等，另一种指向字串的指针指向'\\0'返回。即退出后验证若指向字串的字符串已经指向 '\\0' 即找到真正字串，此使返回最初用于记录字符串与字串字符开始吻合时位置的指针即可。 \n\n![b89941.png](https://miao.su/images/2019/07/14/b89941.png)\n\n~~~\nconst char* myStrStr(const char* str, const char* sub) {\n\t\n\tconst char* mystr = str;\n\tconst char* mysub = sub;\n\n\twhile (*mystr != '\\0') {\n\n\t\tif (*mystr != *mysub) {\n\t\t\t++mystr;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst char* temp_str = mystr;\n\t\tconst char* temp_sub = mysub;\n\n\t\twhile (*temp_sub !='\\0') {//第一个字符相等，继续向后比对\n\t\t\tif (*temp_str != *temp_sub) {\n\t\t\t\t++mystr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++temp_str;\n\t\t\t++temp_sub;\n\t\t}\n\n\t\tif (*temp_sub == '\\0') {// 匹配成功\n\t\t\treturn mystr;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid test() {\n\tchar* str = \"abdecdfw\";\n\tchar* sub = \"df\";\n\tconst char* p = myStrStr(str, sub);\n\tprintf(\"%s\\n\", p);\n}\n\nint main() {\n\ttest();\n}\n~~~\n\n***\n\n## 指针作为函数参数时具有的输入输出特性\n\n指针的**间接赋值**需要理解的十分到位！\n### 指针间接赋值\n- 用1级指针形参，去间接修改了0级指针(实参)的值。\n- 用2级指针形参，去间接修改了1级指针(实参)的值。\n- 用3级指针形参，去间接修改了2级指针(实参)的值。\n- 用n级指针形参，去间接修改了n-1级指针(实参)的值。\n\n---\n\n### 指针作为函数参数时具有的输入特性\n内容不难，但关键在于理解函数作为参数时的内存分配使用模型。\n\n#### *输入特性*：主调函数分配内存，被调函数使用内存使用内存\n~~~\nvoid printString(const char* str) {\n\tprintf(\"s= %s\\n\", str);\n}\n\nvoid test01() {\n\t//主调函数于堆上分配内存\n\tchar* s = malloc(sizeof(char) * 100);\n\tmemset(s, 0, 100);\n\tstrcpy(s, \"Hello World\\n\");\n\tprintString(s);\n}\n~~~\n\n~~~\nvoid printStringArray(char** arr,int len) {\n    // 因arr[0]是char*, 因此需要用char**来接收\n\tfor (int i = 0; i < len; ++i) {\n\t\t//arr[i] 等价于 *(arr + i)\n\t\tprintf(\"%s\\n\", arr[i]);\n\t}\n}\n\nvoid test02() {\n\t//主调函数于栈上分配内存\n\tchar* arr[] = {\n\t\t\"aaaaa\",\n\t\t\"bbbbb\",\n\t\t\"ccccc\",\n\t\t\"ddddd\",\n\t};\n\t//数组名作为函数参数进行传递时，会退化为指向数组首元素类型的指针\n\tprintStringArray(arr, sizeof(arr) / sizeof(arr[0]));\n}\n~~~\n\n\n#### *输出特性*：被调函数分配内存，主调函数使用内存使用内存\n输出特性即被调函数开辟空间，即若主调函数想使用该空间需要使用指针的间接赋值，如不能成功将被调函数开辟的内存空间地址保存，将可能导致内存泄露，这是重难点。\n~~~\nvoid allocateSpace(char **p) {\n\t//被调函数于堆空间开辟内存\n\tchar* temp = malloc(100);\n\tmemset(temp, 0, 100);\n\n\t//指针的间接赋值\n\t*p = temp;\n}\n\ntest03() {\n\t//主调函数使用被调函数开辟的堆空间内存\n\tchar* p = NULL;\n\tallocateSpace(&p);\t\n}\n~~~\n\n***\n\n### 二级指针针对文件的开辟释放内存练习 (有一定难度的综合练习)\n该练习为：读取一个文件，根据其行数与每一行的字符数，为每一行开辟一个堆空间，且每一行的堆空间大小即为该行等到字符数，实现较为繁琐，有很多细节如指针为空需要即使进行返回，文件指针的重置操作，重置缓冲区，关闭文件，释放内存的顺序以及将指针置空等。\n\n获取文件行数模块\n~~~\n//获取文件行数\nint getFileLines(FILE* file) {\n\tif (NULL == file)\n\t\treturn -1;\n\n\tint lines = 0;\n\tchar buf[1024] = {0};\n\n\twhile (fgets(buf, 1024, file) != NULL) {\n\t\t++lines;\n\t}\n\n\t//注意：恢复文件指针指向初始位置！！！\n\tfseek(file, 0, SEEK_SET);\n\n\treturn lines;\n}\n~~~\n读取文件数据并分配空间模块(重点！)\n~~~\n//读取文件数据，为每一行分配对应大小的堆空间\nvoid readFileData(FILE* file,char** pContents,int fileLines) {\n\n\tif (NULL == file)\n\t\treturn;\n\n\tif (NULL == pContents)\n\t\treturn;\n\n\tif (fileLines <= 0) \n\t\treturn;\n\t\n\n\tchar buf[1024] = { 0 };\n\tint index = 0;\n\n\twhile (fgets(buf, 1024, file) != NULL) {\n\n\t\t//计算当前行的字符数\n\t\tint curLineLen = strlen(buf) + 1;\n\n\t\t//给当前行开辟对应大小的堆空间\n\t\tchar* lineContent = malloc(sizeof(char) * curLineLen);\n\n\t\t//将该行数据拷贝进堆空间中\n\t\tstrcpy(lineContent, buf);\n\n\t\t//重置buf数据\n\t\tmemset(buf, 0, 1024);\n\n\t\t//指向开辟的空间\n\t\tpContents[index++] = lineContent;\n\t}\n\n\t//关闭文件\n\tfclose(file);\n\tfile = NULL;\n}\n~~~\n打印文件内容模块\n~~~\nvoid printData(char** pContents, int fileLines) {\n\tif (NULL == pContents)\n\t\treturn;\n\n\tif (fileLines <= 0)\n\t\treturn;\n\n\tfor (int i = 0; i < fileLines; ++i) {\n\t\tprintf(\"第 %d 行：%s\", i + 1, pContents[i]);\n\t}\n\n}\n~~~\n释放内存空间模块\n~~~\nvoid freeSpace(char** pContents, int fileLines) {\n\t//从里到外释放，与开辟空间顺序相反\n\tfor (int i = 0; i < fileLines; ++i) {\n\t\tif (pContents[i] != NULL) {\n\t\t\tfree(pContents[i]);\n\t\t\tpContents[i] = NULL;\n\t\t}\t\n\t}\n\n\tif (pContents != NULL) {\n\t\tfree(pContents);\n\t\tpContents = NULL;\n\t}\n\t\n}\n~~~\n以下为函数主体逻辑函数和主函数\n~~~\nvoid test() {\n\tFILE* file = fopen(\"./test.txt\", \"r\");\n\tif (!file)//文件打开失败另一种写法\n\t\treturn;\n\n\tint fileLines = getFileLines(file);\t\n\t//printf(\"行数为：%d\\n\", fileLines);\n\n\tchar** pContents = malloc(sizeof(char*) * fileLines);\n\n\t//读取文件并对应每行开辟堆空间\n\treadFileData(file, pContents, fileLines);\n\n\t//打印文件内容\n\tprintData(pContents, fileLines);\n\n\t//释放堆空间\n\tfreeSpace(pContents, fileLines);\n}\n\nint main() {\n\n\ttest();\n\n}\n~~~\n\n***\n\nPS：今天只花了俩小时就总结完了，总体来说这样复习的效果还是不错的，而且越来越熟练，白天码代码时就有意识的写注释进行整理了。但是排版还是个问题，一直觉得排版巨丑，不知道什么时候能好好学学解决下。","source":"_posts/2019-Holiday-Note-02.md","raw":"---\ntitle: Holiday Note_02\ndate: 2019-07-14 19:23:03\ncategories: C\ntags: [Note,C]\n---\n\n# Holiday Note_02\n\n放假第二天。今天学的主要只有两块内容：分别是**字符串相关**(字符串格式化函数使用，字符串的拷贝和反转实现方法，查找字串的方法)；**指针作为函数参数时具有的输入输出特性**相关(指针间接赋值，主调函数分配内存与被调函数分配的内存的使用区别，二级指针对指定文件分配，释放空间练习)。难点主要在于理解指针作为函数参数时需要使用哪种类型接收，指针的间接赋值时二级指针的使用，查找子串功能实现时各个指针实现的功能。\n\n<!-- more -->\n\n---\n\n## 字符串相关\n以下为sprintf函数以及sscanf函数在格式化字符串时的一些注意要点以及用法场景。\n### sprintf 函数\nsprintf简单来讲就是按照指定格式，将字符串进行格式化后放入char * str中，与printf相比不过是多了一个接收存放格式化后字符串的指针。具体函数参数以及返回值如下所示。\n\n~~~\nint sprintf(char* str, const char* format, ...);\n功能：\n\t根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 '\\0'为止。\n参数：\n\tstr：字符串首地址\n\tformat：字符串格式，用法和printf()一样\n返回值：\n\t成功：实际格式化的字符个数\n\t失败： - 1\n~~~\n\n这是sprintf的三种常见用法\n\n#### 格式化字符串\n~~~\nchar buf[1024] = { 0 };\nsprintf(buf, \"Hello %s!\", \"World\");\nprintf(\"%s\\n\", buf);//输出结果为：Hello World!\n~~~\n\n#### 拼接字符串\n~~~\nchar* s1 = \"Hello\";\nchar* s2 = \"World!\";\nsprintf(buf, \"%s %s\", s1, s2);\nprintf(\"%s\\n\", buf);//输出结果为：Hello World!\n~~~\n\n#### 数字转换为字符串\n~~~\nint number = 666;\nsprintf(buf, \"%d\", number);\nprintf(\"%s\\n\", buf);//输出结果为666\n~~~\n\n\n---\n\n\n### sscanf 函数\nsscanf函数的主要功能为从指定的字符串中按照给定的格式读取并转换出来。如果说sprintf是放进去，那么sscanf则为取出来，且均按照指定格式进行放入和取出。\n\n~~~\nint sscanf(const char* str, const char* format, ...);\n功能：\n\t从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。\n参数：\n\tstr：指定的字符串首地址\n\tformat：字符串格式，用法和scanf()一样\n返回值：\n\t成功：实际读取的字符个数\n\t失败： - 1\n~~~\n\n\n以下为sscanf的**六种**常见格式与作用\n\n#### 1、%*s或%*d\t\n~~~\nchar* str = \"123456abcdefg\";\nchar buf[1024] = { 0 };\nsscanf(str, \"%*d%s\", buf);\nprintf(\"buf: %s\\n\", buf);//输出结果为buf: abcdefg\n~~~\n\n**注意**忽略字符串时是忽略到空格或者'\\t'\n~~~\nchar* str1 = \"abcdef\\t123456\";\nchar buf1[1024] = { 0 };\nsscanf(str1, \"%*s%s\", buf1);//此使输出结果为buf: 123456\nprintf(\"buf1: %s\\n\", buf1);//若str1字母与数字间无空格或'\\t'，将会把str1全部忽略掉，这种情况输出将为buf1:\n~~~\n\n#### 2、%[width]s\n~~~\nchar* str = \"123456abcdefg\";\nchar buf[1024] = { 0 };\nsscanf(str, \"%7s\", buf);\nprintf(\"buf: %s\\n\", buf);//输出结果为buf: 123456a\n~~~\n\n以下四种特点均为只要与要求不符合立即不进行匹配。简单说就是，不是将整个字符串中匹配的筛选出来，而是从字符串头部开始，判断一个字符格式不符合的即退出或者至'\\0'退出\n\n#### 3、%[a-z]\n~~~\nchar* str = \"123456abcdefg\";\nchar buf[1024] = { 0 };\nsscanf(str, \"%*d%[a-c]\", buf);//若不加忽略%*d的话，由于第一个字符为'1'，将直接退出，不拷贝\nprintf(\"buf: %s\\n\", buf);//输出结果为buf: abc\n~~~\n\n#### 4、%[aBc]\n~~~\nchar* str = \"aABb\";\nchar buf[1024] = { 0 };\nsscanf(str, \"%[aAb]\", buf);//从第一个开始比对，若不同依旧是直接不拷贝\nprintf(\"buf: %s\\n\", buf);//输出结果为buf: aA\n~~~\n\n#### 5、%[^a]\n~~~\nchar* str = \"aABb\";\nchar buf[1024] = { 0 };\nsscanf(str, \"%[^B]\", buf);//从第一个开始比对，若不同依旧是直接不拷贝\nprintf(\"buf: %s\\n\", buf);//输出结果为buf:aA\n~~~\n\n#### 6、%[^a-z]\n~~~\nchar* str = \"cdaABb\";\nchar buf[1024] = { 0 };\nsscanf(str, \"%[^a-b]\", buf);//从第一个开始比对，若不同依旧是直接不拷贝\nprintf(\"buf: %s\\n\", buf);//输出结果为buf:cd\n~~~\n\n#### 综合使用演示\n~~~\n//取出12uiop\nchar* str = \"abSi#12uiop@Tsi(\";\nchar buf[1024] = {0};\n//sscanf(str, \"%*[^#]\", buf);//输出结果buf:\n//sscanf(str, \"%*[^#]%s\", buf);//输出结果buf:#12uiop@Tsi(\nsscanf(str, \"%*[^#]#%[^@]\", buf);//输出结果:buf: 12uiop\nprintf(\"buf: %s\\n\", buf);\n~~~\n\n***\n\n### 字符串与字符数组的易错点\n*最重要记住一句话：字符串是以0或者'\\0'结尾的字符数组，(数字0和字符'\\0'等价)*\n\n#### 字符数组初始化\n~~~\n//字符数组只能初始化5个字符，当输出的时候，从开始位置 直到找到0结束\nchar str1[] = { 'h','e','l','l','o',};\nprintf(\"str1 = %s\", str1);//输出结果将为 str1 = hello烫烫烫剃*堺?\n\n//如果以字符串初始化，那么编译器默认会在字符串尾部添加'\\0'\nchar str2[] = \"hello\";\n~~~\n\n\n#### sizeof与strlen差别\n~~~\n//sizeof计算数组大小，数组包含'\\0'字符\n//strlen计算字符串的长度，到'\\0'结束\nprintf(\"sizeof str:%d\\n\", sizeof(str2));//结果为6\nprintf(\"strlen str:%d\\n\", strlen(str2));//结果为5\n~~~\n\n---\n\n### 实现字符串拷贝函数的三种写法\n三种方法由易到难，由数组到指针，其实指针理解了很简单。\n\n主调用函数为\n~~~\ntest05() {\n\tchar* source = \"Hello World\";\n\tchar buf[1024];\n\tcopyString01(buf, source);\n\tcopyString02(buf, source);\n\tcopyString03(buf, source);\n\tprintf(\"%s\\n\", buf);\n}\n~~~\n\n#### 方法1\n~~~\nvoid copyString01(char*dest,const char*source) {\n\tint len = strlen(source);\n\tfor (int i = 0; i < len; ++i) {\n\t\tdest[i] = source[i];\n\t}\n\tdest[len] = '\\0';\n}\n~~~\n\n#### 方法2\n~~~\nvoid copyString02(char* dest, const char* source) {\n\twhile (*source) {\n\t\t*dest = *source;\n\t\t++dest;\n\t\t++source;\n\t}\n\t*dest = '\\0';\n}\n~~~\n\n#### 我认为最好的方法3\n此写法，简洁优雅。\n~~~\nvoid copyString03(char* dest, const char* source) {\n\twhile (*(dest++) = *(source++));\n}\n~~~\n\n***\n\n### 指针和数组方式实现字符串反转\n两种写法大同小异，思路均为两个变量，头尾互换即可，关键点在于反转后的字符串结尾进行 '\\0' 操作。\n#### 数组实现\n~~~\nvoid reverseString01(char *str) {\n\tif (NULL == str)\n\t\treturn;\n\tint len = strlen(str);\n\t//以下为数组方式实现\n\tint start = 0;\n\tint end = len - 1;\n\twhile (start < end) {\n\t\tchar temp;\n\t\ttemp = str[start];\n\t\tstr[start] = str[end];\n\t\tstr[end] = temp;\n\t\t++start;\n\t\t--end;\n\t}\n\tstr[len] = '\\0';\n}\n~~~\n\n\n#### 指针实现\n~~~\nif (NULL == str)\n\t\treturn;\n\tint len = strlen(str);\t\n\n\t//以下为指针方式实现\n\tchar* pStart = str;\n\tchar* pEnd = str + len - 1;\n\twhile (pStart < pEnd) {\n\t\tchar temp;\n\t\ttemp = *pStart;\n\t\t*pStart = *pEnd;\n\t\t*pEnd = temp;\n\n\t\t++pStart;\n\t\t--pEnd;\n\t}\n\t*(str + len) = '\\0';\n~~~\n\n***\n\n### 实现查找子串\n该功能理解稍有难度，主要是理清楚逻辑。例如字符串为\"abdecdfw\",\"df\",首先思考的是找到字符串与字串第一个字符是否吻合，且定义一个指针记录哪一个字符与字串开始吻合，当找到了吻合的字符 'd' 后，关键步骤为，定义两个指针，一个指向字符串此时的位置，一个指向子串第一个字符的位置，分别进行遍历比较，应设定有两种退出情况，一种是比较字符不相等，另一种指向字串的指针指向'\\0'返回。即退出后验证若指向字串的字符串已经指向 '\\0' 即找到真正字串，此使返回最初用于记录字符串与字串字符开始吻合时位置的指针即可。 \n\n![b89941.png](https://miao.su/images/2019/07/14/b89941.png)\n\n~~~\nconst char* myStrStr(const char* str, const char* sub) {\n\t\n\tconst char* mystr = str;\n\tconst char* mysub = sub;\n\n\twhile (*mystr != '\\0') {\n\n\t\tif (*mystr != *mysub) {\n\t\t\t++mystr;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst char* temp_str = mystr;\n\t\tconst char* temp_sub = mysub;\n\n\t\twhile (*temp_sub !='\\0') {//第一个字符相等，继续向后比对\n\t\t\tif (*temp_str != *temp_sub) {\n\t\t\t\t++mystr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++temp_str;\n\t\t\t++temp_sub;\n\t\t}\n\n\t\tif (*temp_sub == '\\0') {// 匹配成功\n\t\t\treturn mystr;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid test() {\n\tchar* str = \"abdecdfw\";\n\tchar* sub = \"df\";\n\tconst char* p = myStrStr(str, sub);\n\tprintf(\"%s\\n\", p);\n}\n\nint main() {\n\ttest();\n}\n~~~\n\n***\n\n## 指针作为函数参数时具有的输入输出特性\n\n指针的**间接赋值**需要理解的十分到位！\n### 指针间接赋值\n- 用1级指针形参，去间接修改了0级指针(实参)的值。\n- 用2级指针形参，去间接修改了1级指针(实参)的值。\n- 用3级指针形参，去间接修改了2级指针(实参)的值。\n- 用n级指针形参，去间接修改了n-1级指针(实参)的值。\n\n---\n\n### 指针作为函数参数时具有的输入特性\n内容不难，但关键在于理解函数作为参数时的内存分配使用模型。\n\n#### *输入特性*：主调函数分配内存，被调函数使用内存使用内存\n~~~\nvoid printString(const char* str) {\n\tprintf(\"s= %s\\n\", str);\n}\n\nvoid test01() {\n\t//主调函数于堆上分配内存\n\tchar* s = malloc(sizeof(char) * 100);\n\tmemset(s, 0, 100);\n\tstrcpy(s, \"Hello World\\n\");\n\tprintString(s);\n}\n~~~\n\n~~~\nvoid printStringArray(char** arr,int len) {\n    // 因arr[0]是char*, 因此需要用char**来接收\n\tfor (int i = 0; i < len; ++i) {\n\t\t//arr[i] 等价于 *(arr + i)\n\t\tprintf(\"%s\\n\", arr[i]);\n\t}\n}\n\nvoid test02() {\n\t//主调函数于栈上分配内存\n\tchar* arr[] = {\n\t\t\"aaaaa\",\n\t\t\"bbbbb\",\n\t\t\"ccccc\",\n\t\t\"ddddd\",\n\t};\n\t//数组名作为函数参数进行传递时，会退化为指向数组首元素类型的指针\n\tprintStringArray(arr, sizeof(arr) / sizeof(arr[0]));\n}\n~~~\n\n\n#### *输出特性*：被调函数分配内存，主调函数使用内存使用内存\n输出特性即被调函数开辟空间，即若主调函数想使用该空间需要使用指针的间接赋值，如不能成功将被调函数开辟的内存空间地址保存，将可能导致内存泄露，这是重难点。\n~~~\nvoid allocateSpace(char **p) {\n\t//被调函数于堆空间开辟内存\n\tchar* temp = malloc(100);\n\tmemset(temp, 0, 100);\n\n\t//指针的间接赋值\n\t*p = temp;\n}\n\ntest03() {\n\t//主调函数使用被调函数开辟的堆空间内存\n\tchar* p = NULL;\n\tallocateSpace(&p);\t\n}\n~~~\n\n***\n\n### 二级指针针对文件的开辟释放内存练习 (有一定难度的综合练习)\n该练习为：读取一个文件，根据其行数与每一行的字符数，为每一行开辟一个堆空间，且每一行的堆空间大小即为该行等到字符数，实现较为繁琐，有很多细节如指针为空需要即使进行返回，文件指针的重置操作，重置缓冲区，关闭文件，释放内存的顺序以及将指针置空等。\n\n获取文件行数模块\n~~~\n//获取文件行数\nint getFileLines(FILE* file) {\n\tif (NULL == file)\n\t\treturn -1;\n\n\tint lines = 0;\n\tchar buf[1024] = {0};\n\n\twhile (fgets(buf, 1024, file) != NULL) {\n\t\t++lines;\n\t}\n\n\t//注意：恢复文件指针指向初始位置！！！\n\tfseek(file, 0, SEEK_SET);\n\n\treturn lines;\n}\n~~~\n读取文件数据并分配空间模块(重点！)\n~~~\n//读取文件数据，为每一行分配对应大小的堆空间\nvoid readFileData(FILE* file,char** pContents,int fileLines) {\n\n\tif (NULL == file)\n\t\treturn;\n\n\tif (NULL == pContents)\n\t\treturn;\n\n\tif (fileLines <= 0) \n\t\treturn;\n\t\n\n\tchar buf[1024] = { 0 };\n\tint index = 0;\n\n\twhile (fgets(buf, 1024, file) != NULL) {\n\n\t\t//计算当前行的字符数\n\t\tint curLineLen = strlen(buf) + 1;\n\n\t\t//给当前行开辟对应大小的堆空间\n\t\tchar* lineContent = malloc(sizeof(char) * curLineLen);\n\n\t\t//将该行数据拷贝进堆空间中\n\t\tstrcpy(lineContent, buf);\n\n\t\t//重置buf数据\n\t\tmemset(buf, 0, 1024);\n\n\t\t//指向开辟的空间\n\t\tpContents[index++] = lineContent;\n\t}\n\n\t//关闭文件\n\tfclose(file);\n\tfile = NULL;\n}\n~~~\n打印文件内容模块\n~~~\nvoid printData(char** pContents, int fileLines) {\n\tif (NULL == pContents)\n\t\treturn;\n\n\tif (fileLines <= 0)\n\t\treturn;\n\n\tfor (int i = 0; i < fileLines; ++i) {\n\t\tprintf(\"第 %d 行：%s\", i + 1, pContents[i]);\n\t}\n\n}\n~~~\n释放内存空间模块\n~~~\nvoid freeSpace(char** pContents, int fileLines) {\n\t//从里到外释放，与开辟空间顺序相反\n\tfor (int i = 0; i < fileLines; ++i) {\n\t\tif (pContents[i] != NULL) {\n\t\t\tfree(pContents[i]);\n\t\t\tpContents[i] = NULL;\n\t\t}\t\n\t}\n\n\tif (pContents != NULL) {\n\t\tfree(pContents);\n\t\tpContents = NULL;\n\t}\n\t\n}\n~~~\n以下为函数主体逻辑函数和主函数\n~~~\nvoid test() {\n\tFILE* file = fopen(\"./test.txt\", \"r\");\n\tif (!file)//文件打开失败另一种写法\n\t\treturn;\n\n\tint fileLines = getFileLines(file);\t\n\t//printf(\"行数为：%d\\n\", fileLines);\n\n\tchar** pContents = malloc(sizeof(char*) * fileLines);\n\n\t//读取文件并对应每行开辟堆空间\n\treadFileData(file, pContents, fileLines);\n\n\t//打印文件内容\n\tprintData(pContents, fileLines);\n\n\t//释放堆空间\n\tfreeSpace(pContents, fileLines);\n}\n\nint main() {\n\n\ttest();\n\n}\n~~~\n\n***\n\nPS：今天只花了俩小时就总结完了，总体来说这样复习的效果还是不错的，而且越来越熟练，白天码代码时就有意识的写注释进行整理了。但是排版还是个问题，一直觉得排版巨丑，不知道什么时候能好好学学解决下。","slug":"2019-Holiday-Note-02","published":1,"updated":"2019-07-15T14:29:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbih70004smjbo7o7hjmm","content":"<h1 id=\"Holiday-Note-02\"><a href=\"#Holiday-Note-02\" class=\"headerlink\" title=\"Holiday Note_02\"></a>Holiday Note_02</h1><p>放假第二天。今天学的主要只有两块内容：分别是<strong>字符串相关</strong>(字符串格式化函数使用，字符串的拷贝和反转实现方法，查找字串的方法)；<strong>指针作为函数参数时具有的输入输出特性</strong>相关(指针间接赋值，主调函数分配内存与被调函数分配的内存的使用区别，二级指针对指定文件分配，释放空间练习)。难点主要在于理解指针作为函数参数时需要使用哪种类型接收，指针的间接赋值时二级指针的使用，查找子串功能实现时各个指针实现的功能。</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"字符串相关\"><a href=\"#字符串相关\" class=\"headerlink\" title=\"字符串相关\"></a>字符串相关</h2><p>以下为sprintf函数以及sscanf函数在格式化字符串时的一些注意要点以及用法场景。</p>\n<h3 id=\"sprintf-函数\"><a href=\"#sprintf-函数\" class=\"headerlink\" title=\"sprintf 函数\"></a>sprintf 函数</h3><p>sprintf简单来讲就是按照指定格式，将字符串进行格式化后放入char * str中，与printf相比不过是多了一个接收存放格式化后字符串的指针。具体函数参数以及返回值如下所示。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> sprintf(<span class=\"built_in\">char</span>* <span class=\"built_in\">str</span>, <span class=\"keyword\">const</span> <span class=\"built_in\">char</span>* format, ...);</span><br><span class=\"line\">功能：</span><br><span class=\"line\">\t根据参数format字符串来转换并格式化数据，然后将结果输出到<span class=\"built_in\">str</span>指定的空间中，直到出现字符串结束符 <span class=\"string\">'\\0'</span>为止。</span><br><span class=\"line\">参数：</span><br><span class=\"line\">\t<span class=\"built_in\">str</span>：字符串首地址</span><br><span class=\"line\">\tformat：字符串格式，用法和printf()一样</span><br><span class=\"line\">返回值：</span><br><span class=\"line\">\t成功：实际格式化的字符个数</span><br><span class=\"line\">\t失败： - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>这是sprintf的三种常见用法</p>\n<h4 id=\"格式化字符串\"><a href=\"#格式化字符串\" class=\"headerlink\" title=\"格式化字符串\"></a>格式化字符串</h4><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char <span class=\"keyword\">buf[1024] </span>= &#123; <span class=\"number\">0</span> &#125;<span class=\"comment\">;</span></span><br><span class=\"line\">sprintf(<span class=\"keyword\">buf, </span><span class=\"string\">\"Hello %s!\"</span>, <span class=\"string\">\"World\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">printf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">buf);//输出结果为：Hello </span>World!</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"拼接字符串\"><a href=\"#拼接字符串\" class=\"headerlink\" title=\"拼接字符串\"></a>拼接字符串</h4><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char* <span class=\"built_in\">s1</span> = <span class=\"string\">\"Hello\"</span><span class=\"comment\">;</span></span><br><span class=\"line\">char* <span class=\"built_in\">s2</span> = <span class=\"string\">\"World!\"</span><span class=\"comment\">;</span></span><br><span class=\"line\">sprintf(<span class=\"keyword\">buf, </span><span class=\"string\">\"%s %s\"</span>, <span class=\"built_in\">s1</span>, <span class=\"built_in\">s2</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">printf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">buf);//输出结果为：Hello </span>World!</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数字转换为字符串\"><a href=\"#数字转换为字符串\" class=\"headerlink\" title=\"数字转换为字符串\"></a>数字转换为字符串</h4><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> number = <span class=\"number\">666</span>;</span><br><span class=\"line\"><span class=\"keyword\">sprintf</span>(buf, <span class=\"string\">\"%d\"</span>, number);</span><br><span class=\"line\"><span class=\"keyword\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, buf);<span class=\"regexp\">//</span>输出结果为<span class=\"number\">666</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"sscanf-函数\"><a href=\"#sscanf-函数\" class=\"headerlink\" title=\"sscanf 函数\"></a>sscanf 函数</h3><p>sscanf函数的主要功能为从指定的字符串中按照给定的格式读取并转换出来。如果说sprintf是放进去，那么sscanf则为取出来，且均按照指定格式进行放入和取出。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> sscanf(<span class=\"keyword\">const</span> <span class=\"built_in\">char</span>* <span class=\"built_in\">str</span>, <span class=\"keyword\">const</span> <span class=\"built_in\">char</span>* format, ...);</span><br><span class=\"line\">功能：</span><br><span class=\"line\">\t从<span class=\"built_in\">str</span>指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。</span><br><span class=\"line\">参数：</span><br><span class=\"line\">\t<span class=\"built_in\">str</span>：指定的字符串首地址</span><br><span class=\"line\">\tformat：字符串格式，用法和scanf()一样</span><br><span class=\"line\">返回值：</span><br><span class=\"line\">\t成功：实际读取的字符个数</span><br><span class=\"line\">\t失败： - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>以下为sscanf的<strong>六种</strong>常见格式与作用</p>\n<h4 id=\"1、-s或-d\"><a href=\"#1、-s或-d\" class=\"headerlink\" title=\"1、%s或%d\"></a>1、%<em>s或%</em>d</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str = <span class=\"string\">\"123456abcdefg\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str, <span class=\"string\">\"%*d%s\"</span>, buf);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, buf);<span class=\"comment\">//输出结果为buf: abcdefg</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>忽略字符串时是忽略到空格或者’\\t’</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str1 = <span class=\"string\">\"abcdef\\t123456\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf1[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str1, <span class=\"string\">\"%*s%s\"</span>, buf1);<span class=\"comment\">//此使输出结果为buf: 123456</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf1: %s\\n\"</span>, buf1);<span class=\"comment\">//若str1字母与数字间无空格或'\\t'，将会把str1全部忽略掉，这种情况输出将为buf1:</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、-width-s\"><a href=\"#2、-width-s\" class=\"headerlink\" title=\"2、%[width]s\"></a>2、%[width]s</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str = <span class=\"string\">\"123456abcdefg\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str, <span class=\"string\">\"%7s\"</span>, buf);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, buf);<span class=\"comment\">//输出结果为buf: 123456a</span></span><br></pre></td></tr></table></figure>\n\n<p>以下四种特点均为只要与要求不符合立即不进行匹配。简单说就是，不是将整个字符串中匹配的筛选出来，而是从字符串头部开始，判断一个字符格式不符合的即退出或者至’\\0’退出</p>\n<h4 id=\"3、-a-z\"><a href=\"#3、-a-z\" class=\"headerlink\" title=\"3、%[a-z]\"></a>3、%[a-z]</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str = <span class=\"string\">\"123456abcdefg\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str, <span class=\"string\">\"%*d%[a-c]\"</span>, buf);<span class=\"comment\">//若不加忽略%*d的话，由于第一个字符为'1'，将直接退出，不拷贝</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, buf);<span class=\"comment\">//输出结果为buf: abc</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、-aBc\"><a href=\"#4、-aBc\" class=\"headerlink\" title=\"4、%[aBc]\"></a>4、%[aBc]</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str = <span class=\"string\">\"aABb\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str, <span class=\"string\">\"%[aAb]\"</span>, buf);<span class=\"comment\">//从第一个开始比对，若不同依旧是直接不拷贝</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, buf);<span class=\"comment\">//输出结果为buf: aA</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5、-a\"><a href=\"#5、-a\" class=\"headerlink\" title=\"5、%[^a]\"></a>5、%[^a]</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str = <span class=\"string\">\"aABb\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str, <span class=\"string\">\"%[^B]\"</span>, buf);<span class=\"comment\">//从第一个开始比对，若不同依旧是直接不拷贝</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, buf);<span class=\"comment\">//输出结果为buf:aA</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6、-a-z\"><a href=\"#6、-a-z\" class=\"headerlink\" title=\"6、%[^a-z]\"></a>6、%[^a-z]</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str = <span class=\"string\">\"cdaABb\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str, <span class=\"string\">\"%[^a-b]\"</span>, buf);<span class=\"comment\">//从第一个开始比对，若不同依旧是直接不拷贝</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, buf);<span class=\"comment\">//输出结果为buf:cd</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"综合使用演示\"><a href=\"#综合使用演示\" class=\"headerlink\" title=\"综合使用演示\"></a>综合使用演示</h4><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//取出<span class=\"number\">12</span>uiop</span><br><span class=\"line\"><span class=\"symbol\">char</span>* <span class=\"keyword\">str </span>= <span class=\"string\">\"abSi#12uiop@Tsi(\"</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"symbol\">char</span> <span class=\"keyword\">buf[1024] </span>= &#123;<span class=\"number\">0</span>&#125;<span class=\"comment\">;</span></span><br><span class=\"line\">//sscanf(<span class=\"keyword\">str, </span><span class=\"string\">\"%*[^#]\"</span>, <span class=\"keyword\">buf);//输出结果buf:</span></span><br><span class=\"line\"><span class=\"keyword\">//sscanf(str, </span><span class=\"string\">\"%*[^#]%s\"</span>, <span class=\"keyword\">buf);//输出结果buf:#12uiop@Tsi(</span></span><br><span class=\"line\"><span class=\"keyword\">sscanf(str, </span><span class=\"string\">\"%*[^#]#%[^@]\"</span>, <span class=\"keyword\">buf);//输出结果:buf: </span><span class=\"number\">12</span>uiop</span><br><span class=\"line\"><span class=\"symbol\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, <span class=\"keyword\">buf);</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"字符串与字符数组的易错点\"><a href=\"#字符串与字符数组的易错点\" class=\"headerlink\" title=\"字符串与字符数组的易错点\"></a>字符串与字符数组的易错点</h3><p><em>最重要记住一句话：字符串是以0或者’\\0’结尾的字符数组，(数字0和字符’\\0’等价)</em></p>\n<h4 id=\"字符数组初始化\"><a href=\"#字符数组初始化\" class=\"headerlink\" title=\"字符数组初始化\"></a>字符数组初始化</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//字符数组只能初始化5个字符，当输出的时候，从开始位置 直到找到0结束</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> str1[] = &#123; <span class=\"string\">'h'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'l'</span>,<span class=\"string\">'l'</span>,<span class=\"string\">'o'</span>,&#125;;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"str1 = %s\"</span>, str1);<span class=\"comment\">//输出结果将为 str1 = hello烫烫烫剃*堺?</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果以字符串初始化，那么编译器默认会在字符串尾部添加'\\0'</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> str2[] = <span class=\"string\">\"hello\"</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sizeof与strlen差别\"><a href=\"#sizeof与strlen差别\" class=\"headerlink\" title=\"sizeof与strlen差别\"></a>sizeof与strlen差别</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sizeof计算数组大小，数组包含'\\0'字符</span></span><br><span class=\"line\"><span class=\"comment\">//strlen计算字符串的长度，到'\\0'结束</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof str:%d\\n\"</span>, <span class=\"keyword\">sizeof</span>(str2));<span class=\"comment\">//结果为6</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"strlen str:%d\\n\"</span>, <span class=\"built_in\">strlen</span>(str2));<span class=\"comment\">//结果为5</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"实现字符串拷贝函数的三种写法\"><a href=\"#实现字符串拷贝函数的三种写法\" class=\"headerlink\" title=\"实现字符串拷贝函数的三种写法\"></a>实现字符串拷贝函数的三种写法</h3><p>三种方法由易到难，由数组到指针，其实指针理解了很简单。</p>\n<p>主调用函数为</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test05() &#123;</span><br><span class=\"line\">\tchar* source = <span class=\"string\">\"Hello World\"</span><span class=\"comment\">;</span></span><br><span class=\"line\">\tchar <span class=\"keyword\">buf[1024];</span></span><br><span class=\"line\"><span class=\"keyword\">\t</span>copyString01(<span class=\"keyword\">buf, </span>source)<span class=\"comment\">;</span></span><br><span class=\"line\">\tcopyString02(<span class=\"keyword\">buf, </span>source)<span class=\"comment\">;</span></span><br><span class=\"line\">\tcopyString03(<span class=\"keyword\">buf, </span>source)<span class=\"comment\">;</span></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">buf);</span></span><br><span class=\"line\"><span class=\"keyword\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyString01</span><span class=\"params\">(<span class=\"keyword\">char</span>*dest,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*source)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(source);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">\t\tdest[i] = source[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdest[len] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h4><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> copyString02(<span class=\"keyword\">char</span>* dest, const <span class=\"keyword\">char</span>* <span class=\"keyword\">source</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (*<span class=\"keyword\">source</span>) &#123;</span><br><span class=\"line\">\t\t*dest = *<span class=\"keyword\">source</span>;</span><br><span class=\"line\">\t\t++dest;</span><br><span class=\"line\">\t\t++<span class=\"keyword\">source</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t*dest = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"我认为最好的方法3\"><a href=\"#我认为最好的方法3\" class=\"headerlink\" title=\"我认为最好的方法3\"></a>我认为最好的方法3</h4><p>此写法，简洁优雅。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyString03</span><span class=\"params\">(<span class=\"keyword\">char</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* source)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (*(dest++) = *(source++));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"指针和数组方式实现字符串反转\"><a href=\"#指针和数组方式实现字符串反转\" class=\"headerlink\" title=\"指针和数组方式实现字符串反转\"></a>指针和数组方式实现字符串反转</h3><p>两种写法大同小异，思路均为两个变量，头尾互换即可，关键点在于反转后的字符串结尾进行 ‘\\0’ 操作。</p>\n<h4 id=\"数组实现\"><a href=\"#数组实现\" class=\"headerlink\" title=\"数组实现\"></a>数组实现</h4><figure class=\"highlight hsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void reverseString01(char *<span class=\"keyword\">str</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == <span class=\"keyword\">str</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span><span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = <span class=\"keyword\">strlen</span>(<span class=\"keyword\">str</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"comment\">//以下为数组方式实现</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start = <span class=\"number\">0</span><span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> <span class=\"keyword\">end</span> = len - <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (start &lt; <span class=\"keyword\">end</span>) &#123;</span><br><span class=\"line\">\t\tchar temp<span class=\"comment\">;</span></span><br><span class=\"line\">\t\ttemp = <span class=\"keyword\">str</span>[start]<span class=\"comment\">;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">str</span>[start] = <span class=\"keyword\">str</span>[<span class=\"keyword\">end</span>]<span class=\"comment\">;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">str</span>[<span class=\"keyword\">end</span>] = temp<span class=\"comment\">;</span></span><br><span class=\"line\">\t\t++start<span class=\"comment\">;</span></span><br><span class=\"line\">\t\t--<span class=\"keyword\">end</span><span class=\"comment\">;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">str</span>[len] = <span class=\"string\">'\\0'</span><span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"指针实现\"><a href=\"#指针实现\" class=\"headerlink\" title=\"指针实现\"></a>指针实现</h4><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (NULL == <span class=\"keyword\">str</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = strlen(<span class=\"keyword\">str</span>);\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//以下为指针方式实现</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* pStart = <span class=\"keyword\">str</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* pEnd = <span class=\"keyword\">str</span> + len - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pStart &lt; pEnd) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> temp;</span><br><span class=\"line\">\t\ttemp = *pStart;</span><br><span class=\"line\">\t\t*pStart = *pEnd;</span><br><span class=\"line\">\t\t*pEnd = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t++pStart;</span><br><span class=\"line\">\t\t--pEnd;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t*(<span class=\"keyword\">str</span> + len) = <span class=\"string\">'\\0'</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"实现查找子串\"><a href=\"#实现查找子串\" class=\"headerlink\" title=\"实现查找子串\"></a>实现查找子串</h3><p>该功能理解稍有难度，主要是理清楚逻辑。例如字符串为”abdecdfw”,”df”,首先思考的是找到字符串与字串第一个字符是否吻合，且定义一个指针记录哪一个字符与字串开始吻合，当找到了吻合的字符 ‘d’ 后，关键步骤为，定义两个指针，一个指向字符串此时的位置，一个指向子串第一个字符的位置，分别进行遍历比较，应设定有两种退出情况，一种是比较字符不相等，另一种指向字串的指针指向’\\0’返回。即退出后验证若指向字串的字符串已经指向 ‘\\0’ 即找到真正字串，此使返回最初用于记录字符串与字串字符开始吻合时位置的指针即可。 </p>\n<p><img src=\"https://miao.su/images/2019/07/14/b89941.png\" alt=\"b89941.png\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">myStrStr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sub)</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* mystr = str;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* mysub = sub;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (*mystr != <span class=\"string\">'\\0'</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (*mystr != *mysub) &#123;</span><br><span class=\"line\">\t\t\t++mystr;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* temp_str = mystr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* temp_sub = mysub;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (*temp_sub !=<span class=\"string\">'\\0'</span>) &#123;<span class=\"comment\">//第一个字符相等，继续向后比对</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (*temp_str != *temp_sub) &#123;</span><br><span class=\"line\">\t\t\t\t++mystr;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t++temp_str;</span><br><span class=\"line\">\t\t\t++temp_sub;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (*temp_sub == <span class=\"string\">'\\0'</span>) &#123;<span class=\"comment\">// 匹配成功</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> mystr;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* str = <span class=\"string\">\"abdecdfw\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* sub = <span class=\"string\">\"df\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* p = myStrStr(str, sub);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\ttest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"指针作为函数参数时具有的输入输出特性\"><a href=\"#指针作为函数参数时具有的输入输出特性\" class=\"headerlink\" title=\"指针作为函数参数时具有的输入输出特性\"></a>指针作为函数参数时具有的输入输出特性</h2><p>指针的<strong>间接赋值</strong>需要理解的十分到位！</p>\n<h3 id=\"指针间接赋值\"><a href=\"#指针间接赋值\" class=\"headerlink\" title=\"指针间接赋值\"></a>指针间接赋值</h3><ul>\n<li>用1级指针形参，去间接修改了0级指针(实参)的值。</li>\n<li>用2级指针形参，去间接修改了1级指针(实参)的值。</li>\n<li>用3级指针形参，去间接修改了2级指针(实参)的值。</li>\n<li>用n级指针形参，去间接修改了n-1级指针(实参)的值。</li>\n</ul>\n<hr>\n<h3 id=\"指针作为函数参数时具有的输入特性\"><a href=\"#指针作为函数参数时具有的输入特性\" class=\"headerlink\" title=\"指针作为函数参数时具有的输入特性\"></a>指针作为函数参数时具有的输入特性</h3><p>内容不难，但关键在于理解函数作为参数时的内存分配使用模型。</p>\n<h4 id=\"输入特性：主调函数分配内存，被调函数使用内存使用内存\"><a href=\"#输入特性：主调函数分配内存，被调函数使用内存使用内存\" class=\"headerlink\" title=\"输入特性：主调函数分配内存，被调函数使用内存使用内存\"></a><em>输入特性</em>：主调函数分配内存，被调函数使用内存使用内存</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printString</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"s= %s\\n\"</span>, str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//主调函数于堆上分配内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* s = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) * <span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(s, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(s, <span class=\"string\">\"Hello World\\n\"</span>);</span><br><span class=\"line\">\tprintString(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printStringArray</span><span class=\"params\">(<span class=\"keyword\">char</span>** arr,<span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 因arr[0]是char*, 因此需要用char**来接收</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//arr[i] 等价于 *(arr + i)</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, arr[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//主调函数于栈上分配内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* arr[] = &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"aaaaa\"</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">\"bbbbb\"</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">\"ccccc\"</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">\"ddddd\"</span>,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">//数组名作为函数参数进行传递时，会退化为指向数组首元素类型的指针</span></span><br><span class=\"line\">\tprintStringArray(arr, <span class=\"keyword\">sizeof</span>(arr) / <span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"输出特性：被调函数分配内存，主调函数使用内存使用内存\"><a href=\"#输出特性：被调函数分配内存，主调函数使用内存使用内存\" class=\"headerlink\" title=\"输出特性：被调函数分配内存，主调函数使用内存使用内存\"></a><em>输出特性</em>：被调函数分配内存，主调函数使用内存使用内存</h4><p>输出特性即被调函数开辟空间，即若主调函数想使用该空间需要使用指针的间接赋值，如不能成功将被调函数开辟的内存空间地址保存，将可能导致内存泄露，这是重难点。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">allocateSpace</span><span class=\"params\">(<span class=\"keyword\">char</span> **p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//被调函数于堆空间开辟内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* temp = <span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(temp, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//指针的间接赋值</span></span><br><span class=\"line\">\t*p = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test03() &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//主调函数使用被调函数开辟的堆空间内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tallocateSpace(&amp;p);\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"二级指针针对文件的开辟释放内存练习-有一定难度的综合练习\"><a href=\"#二级指针针对文件的开辟释放内存练习-有一定难度的综合练习\" class=\"headerlink\" title=\"二级指针针对文件的开辟释放内存练习 (有一定难度的综合练习)\"></a>二级指针针对文件的开辟释放内存练习 (有一定难度的综合练习)</h3><p>该练习为：读取一个文件，根据其行数与每一行的字符数，为每一行开辟一个堆空间，且每一行的堆空间大小即为该行等到字符数，实现较为繁琐，有很多细节如指针为空需要即使进行返回，文件指针的重置操作，重置缓冲区，关闭文件，释放内存的顺序以及将指针置空等。</p>\n<p>获取文件行数模块</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取文件行数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> getFileLines(<span class=\"keyword\">FILE</span>* <span class=\"keyword\">file</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">NULL</span> == <span class=\"keyword\">file</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lines = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (fgets(buf, <span class=\"number\">1024</span>, <span class=\"keyword\">file</span>) != <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t++lines;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//注意：恢复文件指针指向初始位置！！！</span></span><br><span class=\"line\">\tfseek(<span class=\"keyword\">file</span>, <span class=\"number\">0</span>, SEEK_SET);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lines;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>读取文件数据并分配空间模块(重点！)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//读取文件数据，为每一行分配对应大小的堆空间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFileData</span><span class=\"params\">(FILE* file,<span class=\"keyword\">char</span>** pContents,<span class=\"keyword\">int</span> fileLines)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == file)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == pContents)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fileLines &lt;= <span class=\"number\">0</span>) </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (fgets(buf, <span class=\"number\">1024</span>, file) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//计算当前行的字符数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> curLineLen = <span class=\"built_in\">strlen</span>(buf) + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//给当前行开辟对应大小的堆空间</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>* lineContent = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) * curLineLen);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将该行数据拷贝进堆空间中</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(lineContent, buf);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//重置buf数据</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(buf, <span class=\"number\">0</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//指向开辟的空间</span></span><br><span class=\"line\">\t\tpContents[index++] = lineContent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">\tfclose(file);</span><br><span class=\"line\">\tfile = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印文件内容模块</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printData</span><span class=\"params\">(<span class=\"keyword\">char</span>** pContents, <span class=\"keyword\">int</span> fileLines)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == pContents)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fileLines &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; fileLines; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"第 %d 行：%s\"</span>, i + <span class=\"number\">1</span>, pContents[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>释放内存空间模块</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">freeSpace</span><span class=\"params\">(<span class=\"keyword\">char</span>** pContents, <span class=\"keyword\">int</span> fileLines)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从里到外释放，与开辟空间顺序相反</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; fileLines; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pContents[i] != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(pContents[i]);</span><br><span class=\"line\">\t\t\tpContents[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pContents != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(pContents);</span><br><span class=\"line\">\t\tpContents = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下为函数主体逻辑函数和主函数</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> test() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">FILE</span>* <span class=\"keyword\">file</span> = fopen(<span class=\"string\">\"./test.txt\"</span>, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!<span class=\"keyword\">file</span>)<span class=\"comment\">//文件打开失败另一种写法</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fileLines = getFileLines(<span class=\"keyword\">file</span>);\t</span><br><span class=\"line\">\t<span class=\"comment\">//printf(\"行数为：%d\\n\", fileLines);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>** pContents = malloc(sizeof(<span class=\"keyword\">char</span>*) * fileLines);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//读取文件并对应每行开辟堆空间</span></span><br><span class=\"line\">\treadFileData(<span class=\"keyword\">file</span>, pContents, fileLines);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//打印文件内容</span></span><br><span class=\"line\">\tprintData(pContents, fileLines);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//释放堆空间</span></span><br><span class=\"line\">\tfreeSpace(pContents, fileLines);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttest();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>PS：今天只花了俩小时就总结完了，总体来说这样复习的效果还是不错的，而且越来越熟练，白天码代码时就有意识的写注释进行整理了。但是排版还是个问题，一直觉得排版巨丑，不知道什么时候能好好学学解决下。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-02\"><a href=\"#Holiday-Note-02\" class=\"headerlink\" title=\"Holiday Note_02\"></a>Holiday Note_02</h1><p>放假第二天。今天学的主要只有两块内容：分别是<strong>字符串相关</strong>(字符串格式化函数使用，字符串的拷贝和反转实现方法，查找字串的方法)；<strong>指针作为函数参数时具有的输入输出特性</strong>相关(指针间接赋值，主调函数分配内存与被调函数分配的内存的使用区别，二级指针对指定文件分配，释放空间练习)。难点主要在于理解指针作为函数参数时需要使用哪种类型接收，指针的间接赋值时二级指针的使用，查找子串功能实现时各个指针实现的功能。</p>","more":"<hr>\n<h2 id=\"字符串相关\"><a href=\"#字符串相关\" class=\"headerlink\" title=\"字符串相关\"></a>字符串相关</h2><p>以下为sprintf函数以及sscanf函数在格式化字符串时的一些注意要点以及用法场景。</p>\n<h3 id=\"sprintf-函数\"><a href=\"#sprintf-函数\" class=\"headerlink\" title=\"sprintf 函数\"></a>sprintf 函数</h3><p>sprintf简单来讲就是按照指定格式，将字符串进行格式化后放入char * str中，与printf相比不过是多了一个接收存放格式化后字符串的指针。具体函数参数以及返回值如下所示。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> sprintf(<span class=\"built_in\">char</span>* <span class=\"built_in\">str</span>, <span class=\"keyword\">const</span> <span class=\"built_in\">char</span>* format, ...);</span><br><span class=\"line\">功能：</span><br><span class=\"line\">\t根据参数format字符串来转换并格式化数据，然后将结果输出到<span class=\"built_in\">str</span>指定的空间中，直到出现字符串结束符 <span class=\"string\">'\\0'</span>为止。</span><br><span class=\"line\">参数：</span><br><span class=\"line\">\t<span class=\"built_in\">str</span>：字符串首地址</span><br><span class=\"line\">\tformat：字符串格式，用法和printf()一样</span><br><span class=\"line\">返回值：</span><br><span class=\"line\">\t成功：实际格式化的字符个数</span><br><span class=\"line\">\t失败： - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>这是sprintf的三种常见用法</p>\n<h4 id=\"格式化字符串\"><a href=\"#格式化字符串\" class=\"headerlink\" title=\"格式化字符串\"></a>格式化字符串</h4><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char <span class=\"keyword\">buf[1024] </span>= &#123; <span class=\"number\">0</span> &#125;<span class=\"comment\">;</span></span><br><span class=\"line\">sprintf(<span class=\"keyword\">buf, </span><span class=\"string\">\"Hello %s!\"</span>, <span class=\"string\">\"World\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">printf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">buf);//输出结果为：Hello </span>World!</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"拼接字符串\"><a href=\"#拼接字符串\" class=\"headerlink\" title=\"拼接字符串\"></a>拼接字符串</h4><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char* <span class=\"built_in\">s1</span> = <span class=\"string\">\"Hello\"</span><span class=\"comment\">;</span></span><br><span class=\"line\">char* <span class=\"built_in\">s2</span> = <span class=\"string\">\"World!\"</span><span class=\"comment\">;</span></span><br><span class=\"line\">sprintf(<span class=\"keyword\">buf, </span><span class=\"string\">\"%s %s\"</span>, <span class=\"built_in\">s1</span>, <span class=\"built_in\">s2</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">printf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">buf);//输出结果为：Hello </span>World!</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数字转换为字符串\"><a href=\"#数字转换为字符串\" class=\"headerlink\" title=\"数字转换为字符串\"></a>数字转换为字符串</h4><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> number = <span class=\"number\">666</span>;</span><br><span class=\"line\"><span class=\"keyword\">sprintf</span>(buf, <span class=\"string\">\"%d\"</span>, number);</span><br><span class=\"line\"><span class=\"keyword\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, buf);<span class=\"regexp\">//</span>输出结果为<span class=\"number\">666</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"sscanf-函数\"><a href=\"#sscanf-函数\" class=\"headerlink\" title=\"sscanf 函数\"></a>sscanf 函数</h3><p>sscanf函数的主要功能为从指定的字符串中按照给定的格式读取并转换出来。如果说sprintf是放进去，那么sscanf则为取出来，且均按照指定格式进行放入和取出。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> sscanf(<span class=\"keyword\">const</span> <span class=\"built_in\">char</span>* <span class=\"built_in\">str</span>, <span class=\"keyword\">const</span> <span class=\"built_in\">char</span>* format, ...);</span><br><span class=\"line\">功能：</span><br><span class=\"line\">\t从<span class=\"built_in\">str</span>指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。</span><br><span class=\"line\">参数：</span><br><span class=\"line\">\t<span class=\"built_in\">str</span>：指定的字符串首地址</span><br><span class=\"line\">\tformat：字符串格式，用法和scanf()一样</span><br><span class=\"line\">返回值：</span><br><span class=\"line\">\t成功：实际读取的字符个数</span><br><span class=\"line\">\t失败： - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>以下为sscanf的<strong>六种</strong>常见格式与作用</p>\n<h4 id=\"1、-s或-d\"><a href=\"#1、-s或-d\" class=\"headerlink\" title=\"1、%s或%d\"></a>1、%<em>s或%</em>d</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str = <span class=\"string\">\"123456abcdefg\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str, <span class=\"string\">\"%*d%s\"</span>, buf);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, buf);<span class=\"comment\">//输出结果为buf: abcdefg</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>忽略字符串时是忽略到空格或者’\\t’</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str1 = <span class=\"string\">\"abcdef\\t123456\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf1[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str1, <span class=\"string\">\"%*s%s\"</span>, buf1);<span class=\"comment\">//此使输出结果为buf: 123456</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf1: %s\\n\"</span>, buf1);<span class=\"comment\">//若str1字母与数字间无空格或'\\t'，将会把str1全部忽略掉，这种情况输出将为buf1:</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、-width-s\"><a href=\"#2、-width-s\" class=\"headerlink\" title=\"2、%[width]s\"></a>2、%[width]s</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str = <span class=\"string\">\"123456abcdefg\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str, <span class=\"string\">\"%7s\"</span>, buf);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, buf);<span class=\"comment\">//输出结果为buf: 123456a</span></span><br></pre></td></tr></table></figure>\n\n<p>以下四种特点均为只要与要求不符合立即不进行匹配。简单说就是，不是将整个字符串中匹配的筛选出来，而是从字符串头部开始，判断一个字符格式不符合的即退出或者至’\\0’退出</p>\n<h4 id=\"3、-a-z\"><a href=\"#3、-a-z\" class=\"headerlink\" title=\"3、%[a-z]\"></a>3、%[a-z]</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str = <span class=\"string\">\"123456abcdefg\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str, <span class=\"string\">\"%*d%[a-c]\"</span>, buf);<span class=\"comment\">//若不加忽略%*d的话，由于第一个字符为'1'，将直接退出，不拷贝</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, buf);<span class=\"comment\">//输出结果为buf: abc</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、-aBc\"><a href=\"#4、-aBc\" class=\"headerlink\" title=\"4、%[aBc]\"></a>4、%[aBc]</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str = <span class=\"string\">\"aABb\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str, <span class=\"string\">\"%[aAb]\"</span>, buf);<span class=\"comment\">//从第一个开始比对，若不同依旧是直接不拷贝</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, buf);<span class=\"comment\">//输出结果为buf: aA</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5、-a\"><a href=\"#5、-a\" class=\"headerlink\" title=\"5、%[^a]\"></a>5、%[^a]</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str = <span class=\"string\">\"aABb\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str, <span class=\"string\">\"%[^B]\"</span>, buf);<span class=\"comment\">//从第一个开始比对，若不同依旧是直接不拷贝</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, buf);<span class=\"comment\">//输出结果为buf:aA</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6、-a-z\"><a href=\"#6、-a-z\" class=\"headerlink\" title=\"6、%[^a-z]\"></a>6、%[^a-z]</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str = <span class=\"string\">\"cdaABb\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">sscanf</span>(str, <span class=\"string\">\"%[^a-b]\"</span>, buf);<span class=\"comment\">//从第一个开始比对，若不同依旧是直接不拷贝</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, buf);<span class=\"comment\">//输出结果为buf:cd</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"综合使用演示\"><a href=\"#综合使用演示\" class=\"headerlink\" title=\"综合使用演示\"></a>综合使用演示</h4><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//取出<span class=\"number\">12</span>uiop</span><br><span class=\"line\"><span class=\"symbol\">char</span>* <span class=\"keyword\">str </span>= <span class=\"string\">\"abSi#12uiop@Tsi(\"</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"symbol\">char</span> <span class=\"keyword\">buf[1024] </span>= &#123;<span class=\"number\">0</span>&#125;<span class=\"comment\">;</span></span><br><span class=\"line\">//sscanf(<span class=\"keyword\">str, </span><span class=\"string\">\"%*[^#]\"</span>, <span class=\"keyword\">buf);//输出结果buf:</span></span><br><span class=\"line\"><span class=\"keyword\">//sscanf(str, </span><span class=\"string\">\"%*[^#]%s\"</span>, <span class=\"keyword\">buf);//输出结果buf:#12uiop@Tsi(</span></span><br><span class=\"line\"><span class=\"keyword\">sscanf(str, </span><span class=\"string\">\"%*[^#]#%[^@]\"</span>, <span class=\"keyword\">buf);//输出结果:buf: </span><span class=\"number\">12</span>uiop</span><br><span class=\"line\"><span class=\"symbol\">printf</span>(<span class=\"string\">\"buf: %s\\n\"</span>, <span class=\"keyword\">buf);</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"字符串与字符数组的易错点\"><a href=\"#字符串与字符数组的易错点\" class=\"headerlink\" title=\"字符串与字符数组的易错点\"></a>字符串与字符数组的易错点</h3><p><em>最重要记住一句话：字符串是以0或者’\\0’结尾的字符数组，(数字0和字符’\\0’等价)</em></p>\n<h4 id=\"字符数组初始化\"><a href=\"#字符数组初始化\" class=\"headerlink\" title=\"字符数组初始化\"></a>字符数组初始化</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//字符数组只能初始化5个字符，当输出的时候，从开始位置 直到找到0结束</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> str1[] = &#123; <span class=\"string\">'h'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'l'</span>,<span class=\"string\">'l'</span>,<span class=\"string\">'o'</span>,&#125;;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"str1 = %s\"</span>, str1);<span class=\"comment\">//输出结果将为 str1 = hello烫烫烫剃*堺?</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果以字符串初始化，那么编译器默认会在字符串尾部添加'\\0'</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> str2[] = <span class=\"string\">\"hello\"</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sizeof与strlen差别\"><a href=\"#sizeof与strlen差别\" class=\"headerlink\" title=\"sizeof与strlen差别\"></a>sizeof与strlen差别</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sizeof计算数组大小，数组包含'\\0'字符</span></span><br><span class=\"line\"><span class=\"comment\">//strlen计算字符串的长度，到'\\0'结束</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof str:%d\\n\"</span>, <span class=\"keyword\">sizeof</span>(str2));<span class=\"comment\">//结果为6</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"strlen str:%d\\n\"</span>, <span class=\"built_in\">strlen</span>(str2));<span class=\"comment\">//结果为5</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"实现字符串拷贝函数的三种写法\"><a href=\"#实现字符串拷贝函数的三种写法\" class=\"headerlink\" title=\"实现字符串拷贝函数的三种写法\"></a>实现字符串拷贝函数的三种写法</h3><p>三种方法由易到难，由数组到指针，其实指针理解了很简单。</p>\n<p>主调用函数为</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test05() &#123;</span><br><span class=\"line\">\tchar* source = <span class=\"string\">\"Hello World\"</span><span class=\"comment\">;</span></span><br><span class=\"line\">\tchar <span class=\"keyword\">buf[1024];</span></span><br><span class=\"line\"><span class=\"keyword\">\t</span>copyString01(<span class=\"keyword\">buf, </span>source)<span class=\"comment\">;</span></span><br><span class=\"line\">\tcopyString02(<span class=\"keyword\">buf, </span>source)<span class=\"comment\">;</span></span><br><span class=\"line\">\tcopyString03(<span class=\"keyword\">buf, </span>source)<span class=\"comment\">;</span></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">buf);</span></span><br><span class=\"line\"><span class=\"keyword\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyString01</span><span class=\"params\">(<span class=\"keyword\">char</span>*dest,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*source)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(source);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">\t\tdest[i] = source[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdest[len] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h4><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> copyString02(<span class=\"keyword\">char</span>* dest, const <span class=\"keyword\">char</span>* <span class=\"keyword\">source</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (*<span class=\"keyword\">source</span>) &#123;</span><br><span class=\"line\">\t\t*dest = *<span class=\"keyword\">source</span>;</span><br><span class=\"line\">\t\t++dest;</span><br><span class=\"line\">\t\t++<span class=\"keyword\">source</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t*dest = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"我认为最好的方法3\"><a href=\"#我认为最好的方法3\" class=\"headerlink\" title=\"我认为最好的方法3\"></a>我认为最好的方法3</h4><p>此写法，简洁优雅。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyString03</span><span class=\"params\">(<span class=\"keyword\">char</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* source)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (*(dest++) = *(source++));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"指针和数组方式实现字符串反转\"><a href=\"#指针和数组方式实现字符串反转\" class=\"headerlink\" title=\"指针和数组方式实现字符串反转\"></a>指针和数组方式实现字符串反转</h3><p>两种写法大同小异，思路均为两个变量，头尾互换即可，关键点在于反转后的字符串结尾进行 ‘\\0’ 操作。</p>\n<h4 id=\"数组实现\"><a href=\"#数组实现\" class=\"headerlink\" title=\"数组实现\"></a>数组实现</h4><figure class=\"highlight hsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void reverseString01(char *<span class=\"keyword\">str</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == <span class=\"keyword\">str</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span><span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = <span class=\"keyword\">strlen</span>(<span class=\"keyword\">str</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"comment\">//以下为数组方式实现</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start = <span class=\"number\">0</span><span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> <span class=\"keyword\">end</span> = len - <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (start &lt; <span class=\"keyword\">end</span>) &#123;</span><br><span class=\"line\">\t\tchar temp<span class=\"comment\">;</span></span><br><span class=\"line\">\t\ttemp = <span class=\"keyword\">str</span>[start]<span class=\"comment\">;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">str</span>[start] = <span class=\"keyword\">str</span>[<span class=\"keyword\">end</span>]<span class=\"comment\">;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">str</span>[<span class=\"keyword\">end</span>] = temp<span class=\"comment\">;</span></span><br><span class=\"line\">\t\t++start<span class=\"comment\">;</span></span><br><span class=\"line\">\t\t--<span class=\"keyword\">end</span><span class=\"comment\">;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">str</span>[len] = <span class=\"string\">'\\0'</span><span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"指针实现\"><a href=\"#指针实现\" class=\"headerlink\" title=\"指针实现\"></a>指针实现</h4><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (NULL == <span class=\"keyword\">str</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = strlen(<span class=\"keyword\">str</span>);\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//以下为指针方式实现</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* pStart = <span class=\"keyword\">str</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* pEnd = <span class=\"keyword\">str</span> + len - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pStart &lt; pEnd) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> temp;</span><br><span class=\"line\">\t\ttemp = *pStart;</span><br><span class=\"line\">\t\t*pStart = *pEnd;</span><br><span class=\"line\">\t\t*pEnd = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t++pStart;</span><br><span class=\"line\">\t\t--pEnd;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t*(<span class=\"keyword\">str</span> + len) = <span class=\"string\">'\\0'</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"实现查找子串\"><a href=\"#实现查找子串\" class=\"headerlink\" title=\"实现查找子串\"></a>实现查找子串</h3><p>该功能理解稍有难度，主要是理清楚逻辑。例如字符串为”abdecdfw”,”df”,首先思考的是找到字符串与字串第一个字符是否吻合，且定义一个指针记录哪一个字符与字串开始吻合，当找到了吻合的字符 ‘d’ 后，关键步骤为，定义两个指针，一个指向字符串此时的位置，一个指向子串第一个字符的位置，分别进行遍历比较，应设定有两种退出情况，一种是比较字符不相等，另一种指向字串的指针指向’\\0’返回。即退出后验证若指向字串的字符串已经指向 ‘\\0’ 即找到真正字串，此使返回最初用于记录字符串与字串字符开始吻合时位置的指针即可。 </p>\n<p><img src=\"https://miao.su/images/2019/07/14/b89941.png\" alt=\"b89941.png\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">myStrStr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sub)</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* mystr = str;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* mysub = sub;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (*mystr != <span class=\"string\">'\\0'</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (*mystr != *mysub) &#123;</span><br><span class=\"line\">\t\t\t++mystr;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* temp_str = mystr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* temp_sub = mysub;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (*temp_sub !=<span class=\"string\">'\\0'</span>) &#123;<span class=\"comment\">//第一个字符相等，继续向后比对</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (*temp_str != *temp_sub) &#123;</span><br><span class=\"line\">\t\t\t\t++mystr;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t++temp_str;</span><br><span class=\"line\">\t\t\t++temp_sub;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (*temp_sub == <span class=\"string\">'\\0'</span>) &#123;<span class=\"comment\">// 匹配成功</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> mystr;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* str = <span class=\"string\">\"abdecdfw\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* sub = <span class=\"string\">\"df\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* p = myStrStr(str, sub);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\ttest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"指针作为函数参数时具有的输入输出特性\"><a href=\"#指针作为函数参数时具有的输入输出特性\" class=\"headerlink\" title=\"指针作为函数参数时具有的输入输出特性\"></a>指针作为函数参数时具有的输入输出特性</h2><p>指针的<strong>间接赋值</strong>需要理解的十分到位！</p>\n<h3 id=\"指针间接赋值\"><a href=\"#指针间接赋值\" class=\"headerlink\" title=\"指针间接赋值\"></a>指针间接赋值</h3><ul>\n<li>用1级指针形参，去间接修改了0级指针(实参)的值。</li>\n<li>用2级指针形参，去间接修改了1级指针(实参)的值。</li>\n<li>用3级指针形参，去间接修改了2级指针(实参)的值。</li>\n<li>用n级指针形参，去间接修改了n-1级指针(实参)的值。</li>\n</ul>\n<hr>\n<h3 id=\"指针作为函数参数时具有的输入特性\"><a href=\"#指针作为函数参数时具有的输入特性\" class=\"headerlink\" title=\"指针作为函数参数时具有的输入特性\"></a>指针作为函数参数时具有的输入特性</h3><p>内容不难，但关键在于理解函数作为参数时的内存分配使用模型。</p>\n<h4 id=\"输入特性：主调函数分配内存，被调函数使用内存使用内存\"><a href=\"#输入特性：主调函数分配内存，被调函数使用内存使用内存\" class=\"headerlink\" title=\"输入特性：主调函数分配内存，被调函数使用内存使用内存\"></a><em>输入特性</em>：主调函数分配内存，被调函数使用内存使用内存</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printString</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"s= %s\\n\"</span>, str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//主调函数于堆上分配内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* s = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) * <span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(s, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(s, <span class=\"string\">\"Hello World\\n\"</span>);</span><br><span class=\"line\">\tprintString(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printStringArray</span><span class=\"params\">(<span class=\"keyword\">char</span>** arr,<span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 因arr[0]是char*, 因此需要用char**来接收</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//arr[i] 等价于 *(arr + i)</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, arr[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//主调函数于栈上分配内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* arr[] = &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"aaaaa\"</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">\"bbbbb\"</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">\"ccccc\"</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">\"ddddd\"</span>,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">//数组名作为函数参数进行传递时，会退化为指向数组首元素类型的指针</span></span><br><span class=\"line\">\tprintStringArray(arr, <span class=\"keyword\">sizeof</span>(arr) / <span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"输出特性：被调函数分配内存，主调函数使用内存使用内存\"><a href=\"#输出特性：被调函数分配内存，主调函数使用内存使用内存\" class=\"headerlink\" title=\"输出特性：被调函数分配内存，主调函数使用内存使用内存\"></a><em>输出特性</em>：被调函数分配内存，主调函数使用内存使用内存</h4><p>输出特性即被调函数开辟空间，即若主调函数想使用该空间需要使用指针的间接赋值，如不能成功将被调函数开辟的内存空间地址保存，将可能导致内存泄露，这是重难点。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">allocateSpace</span><span class=\"params\">(<span class=\"keyword\">char</span> **p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//被调函数于堆空间开辟内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* temp = <span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(temp, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//指针的间接赋值</span></span><br><span class=\"line\">\t*p = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test03() &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//主调函数使用被调函数开辟的堆空间内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tallocateSpace(&amp;p);\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"二级指针针对文件的开辟释放内存练习-有一定难度的综合练习\"><a href=\"#二级指针针对文件的开辟释放内存练习-有一定难度的综合练习\" class=\"headerlink\" title=\"二级指针针对文件的开辟释放内存练习 (有一定难度的综合练习)\"></a>二级指针针对文件的开辟释放内存练习 (有一定难度的综合练习)</h3><p>该练习为：读取一个文件，根据其行数与每一行的字符数，为每一行开辟一个堆空间，且每一行的堆空间大小即为该行等到字符数，实现较为繁琐，有很多细节如指针为空需要即使进行返回，文件指针的重置操作，重置缓冲区，关闭文件，释放内存的顺序以及将指针置空等。</p>\n<p>获取文件行数模块</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取文件行数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> getFileLines(<span class=\"keyword\">FILE</span>* <span class=\"keyword\">file</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">NULL</span> == <span class=\"keyword\">file</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lines = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (fgets(buf, <span class=\"number\">1024</span>, <span class=\"keyword\">file</span>) != <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t++lines;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//注意：恢复文件指针指向初始位置！！！</span></span><br><span class=\"line\">\tfseek(<span class=\"keyword\">file</span>, <span class=\"number\">0</span>, SEEK_SET);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lines;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>读取文件数据并分配空间模块(重点！)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//读取文件数据，为每一行分配对应大小的堆空间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readFileData</span><span class=\"params\">(FILE* file,<span class=\"keyword\">char</span>** pContents,<span class=\"keyword\">int</span> fileLines)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == file)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == pContents)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fileLines &lt;= <span class=\"number\">0</span>) </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (fgets(buf, <span class=\"number\">1024</span>, file) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//计算当前行的字符数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> curLineLen = <span class=\"built_in\">strlen</span>(buf) + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//给当前行开辟对应大小的堆空间</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>* lineContent = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) * curLineLen);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将该行数据拷贝进堆空间中</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(lineContent, buf);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//重置buf数据</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(buf, <span class=\"number\">0</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//指向开辟的空间</span></span><br><span class=\"line\">\t\tpContents[index++] = lineContent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">\tfclose(file);</span><br><span class=\"line\">\tfile = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印文件内容模块</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printData</span><span class=\"params\">(<span class=\"keyword\">char</span>** pContents, <span class=\"keyword\">int</span> fileLines)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == pContents)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fileLines &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; fileLines; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"第 %d 行：%s\"</span>, i + <span class=\"number\">1</span>, pContents[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>释放内存空间模块</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">freeSpace</span><span class=\"params\">(<span class=\"keyword\">char</span>** pContents, <span class=\"keyword\">int</span> fileLines)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从里到外释放，与开辟空间顺序相反</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; fileLines; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pContents[i] != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(pContents[i]);</span><br><span class=\"line\">\t\t\tpContents[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pContents != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(pContents);</span><br><span class=\"line\">\t\tpContents = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下为函数主体逻辑函数和主函数</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> test() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">FILE</span>* <span class=\"keyword\">file</span> = fopen(<span class=\"string\">\"./test.txt\"</span>, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!<span class=\"keyword\">file</span>)<span class=\"comment\">//文件打开失败另一种写法</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fileLines = getFileLines(<span class=\"keyword\">file</span>);\t</span><br><span class=\"line\">\t<span class=\"comment\">//printf(\"行数为：%d\\n\", fileLines);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>** pContents = malloc(sizeof(<span class=\"keyword\">char</span>*) * fileLines);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//读取文件并对应每行开辟堆空间</span></span><br><span class=\"line\">\treadFileData(<span class=\"keyword\">file</span>, pContents, fileLines);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//打印文件内容</span></span><br><span class=\"line\">\tprintData(pContents, fileLines);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//释放堆空间</span></span><br><span class=\"line\">\tfreeSpace(pContents, fileLines);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttest();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>PS：今天只花了俩小时就总结完了，总体来说这样复习的效果还是不错的，而且越来越熟练，白天码代码时就有意识的写注释进行整理了。但是排版还是个问题，一直觉得排版巨丑，不知道什么时候能好好学学解决下。</p>"},{"title":"Holiday Note_04","date":"2019-07-16T13:14:31.000Z","_content":"\n# Holiday Note_04\n\n放假第四天。今天学了**内存对齐**的原理与一系列原则(感觉还是挺简单的，主要突出了时间换空间的思想)，还有**文件打开，关闭以及缓冲区的一些补充知识**。另外写了两个练习，一个是**结构体嵌套二维指针**(依旧是练习分配释放内存，只不过这个练习以Teacher-Student模型分配了4层内存，内存的分配和释放操作还是挺细节的)。另一个练习是 **配置文件读写**案例，巨恶心，写头文件，然后将功能一一封装实现，最后调用测试功能，从下午写到晚上，晕头转向的，全是二级指针三级指针以及结构体指针，刚刚又好好想了一遍，为什么debug了这么久，总结了下是自己没理清楚参数传递的思路和调用过程就写，这样下来效率自然就低了，下次写这种复杂的案例时还是应该先画好图理清楚了再开始。\n\n\n<!-- more -->\n\n---\n\n## 内存对齐\n\n\n### 什么是内存对齐\n\n在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，\n这里涉及到内存字节对齐的问题。\n\n~~从理论上讲，对于任何变量的访问都可以从任何地址开始访问~~\n\n但是事实上不是如此，**实际上访问特定类型的变量只能在特定的地址访问**，\n这就需要各个变量在空间上按一定的规则排列， 而不是简单地顺序排列，这就是内存对齐。\n\n我们知道内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取\n\n但是实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等，\n\n***\n\n### 内存对齐的优缺点\n\n> 空间换时间\n\n内存对齐是操作系统为了**提高访问内存的策略**。**操作系统在访问内存的时候，每次读取一定长度(这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍)**。如果没有对齐，为了访问一个变量可能产生*二次访问*。而且要注意的是某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统。\n\n---\n\n### 内存对齐的三大原则\n\n- 对于*标准数据类型*，它的地址只要是它的**长度的整数倍**。\n\n\n- 对于非标准数据类型，比如结构体，要遵循以下对齐原则：\n\n1. 数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在**offset为min（当前成员的大小，#pargama pack(n)）整数倍**的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。\n\n2. **结构体总的大小**，也就是sizeof的结果，必须是min（结构体内部最大成员，#pargama pack(n)）的整数倍，**不足要补齐**。\n\n3. 结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是**结构体A的起点为A内部最大成员的整数倍的地方**。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。\n\n\n辅助理解代码如下：\n\n下面这条代码是显示当前packing alignment的字节数，以warning message的形式被显示。我在VS上显示的结果是8.\n~~~\n#pragma pack(show)\n~~~\n[![463d913c5f9d055218431668f3e527249333.md.png](https://miao.su/images/2019/07/16/463d913c5f9d055218431668f3e527249333.md.png)](https://miao.su/image/TaHgL)\n\n~~~\ntypedef struct _STUDENT1 {\n\tint a;//0-3\n\tchar b;//4\n\tdouble c;//8-15  每个成员必须放在min（当前成员的大小，#pargama pack(n)）整数倍的地方开始\n\tfloat d;//16-19   结构体总的大小必须为min（结构体内部最大成员，#pargama pack(n)）为8的整数倍，因此0-23  大小一共为24\n}Student1;\n\n\ntypedef struct _STUDENT2 {\n\tchar a;//0\n\tStudent1 b;//8-31 结构体A的起点为A内部最大成员的整数倍的地方\n\tdouble c;//32-39   0-39  40字节\n}Student2;\n~~~\n\n~~~\nvoid test() {\n\n\tprintf(\"%d\\n\", sizeof(Student1));//输出结果为24\n\tprintf(\"%d\\n\", sizeof(Student2));//输出结果为40\n\n}\n~~~\n\n---\n\n## 结构体嵌套二维指针练习\n\n![1205c38d33e627257b4b4.png](https://miao.su/images/2019/07/16/1205c38d33e627257b4b4.png)\n\n结构体如下所示，模型为一个Teacher类型的二级指针，为它分配存放三个Teacher类型的一个指针类型用于存放数据，这三个Teacher类型的一级指针再为name和students分配空间，其中students为二级指针即表示有多个学生，因此使用以及分配的二维指针students继续分配4个一维指针存放学生姓名。该案例关键在于**训练分配内存和释放内存的次序以及判定条件的书写**。\n~~~\nstruct Teacher {\n\tchar* name;\n\tchar** students;\n};\n~~~\n\n~~~\nvoid printTeacher(struct Teacher** ts) {\n\tfor (int i = 0; i < 3; ++i) {\n\n\t\tprintf(\"%s\\n\", ts[i]->name);\n\n\t\tfor (int j = 0; j < 5; ++j) {\n\n\t\t\tprintf(\"%s\\n\", ts[i]->students[j]);\n\n\t\t}\n\t}\n}\n~~~\n\n分配内存\n~~~\nint allocateSpace(struct Teacher*** ts) {\n\t\n\tif (NULL == ts)\n\t\treturn -1;\n\t\n\tstruct Teacher** temp = malloc(sizeof(struct Teacher*) * 3);\n\n\tfor (int i = 0; i < 3; ++i) {\n\n\t\ttemp[i] = malloc(sizeof(struct Teacher));\n\n\t\ttemp[i]->name = malloc(sizeof(char) * 64);\n\n\t\tsprintf(temp[i]->name, \"Teacher_%d\", i + 1);\n\n\t\ttemp[i]->students = malloc(sizeof(char*) * 5);\n\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\ttemp[i]->students[j] = malloc(sizeof(char) * 64);\n\t\t\tsprintf(temp[i]->students[j], \"\\tStudent_%d\", j + 1);\n\t\t}\n\n\t}\n\n\t//指针的间接赋值\n\t*ts = temp;\n\n\treturn 0;\n}\n~~~\n**释放内存(关键)**\n~~~\nvoid freeSpace(struct Teacher** ts) {\n\n\tif (NULL == ts)\n\t\treturn;\n\n\tfor (int i = 0; i < 3; ++i) {\n\n\t\tif (NULL == ts[i])\n\t\t\tcontinue;\n\n\t\tif (ts[i]->name != NULL) {\n\t\t\tfree(ts[i]->name);\n\t\t\tts[i]->name = NULL;\n\t\t}\n\n\t\tif (ts[i]->students != NULL) {\n\n\t\t\tfor (int j = 0; j < 5; ++j) {\n\n\t\t\t\tif (NULL == ts[i]->students[j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfree(ts[i]->students[j]);\n\t\t\t\tts[i]->students[j] = NULL;\n\n\t\t\t}\n\n\t\t\tfree(ts[i]->students);\n\t\t\tts[i]->students = NULL;\n\n\t\t}\n\n\t\tfree(ts[i]);\n\t\tts[i] = NULL;\n\n\t}\n\n\tfree(ts);\n\tts = NULL;\n\n}\n~~~\n调用函数\n~~~\nvoid test() {\n\n\tstruct Teacher** teacher;\n\n\tteacher = NULL;\n\n\t//定义allocateSpace函数返回值类型为int的目的为接收不同情况的错误码\n\tprintf(\"%d\\n\", allocateSpace(&teacher));\n\n\tprintTeacher(teacher);\n\n\tfreeSpace(teacher);\n\n}\n\n\nint main() {\n\ttest();\n}\n~~~\n\n---\n\n## 文件相关\n\n### 文件缓冲区\n\n如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以**减少磁盘的读写次数**，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大**提高计算机的运行速度**。\n\n![566664cfae.png](https://miao.su/images/2019/07/16/566664cfae.png)\n\n\n---\n\n### 理解fopen与fclose与文件缓冲区的关系\n文件的打开操作表示将给用户指定的文件在内存**分配一个FILE结构区**，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。\n\n*只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去*，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。**文件的关闭也意味着释放了该文件的缓冲区**。\n\n---\n\n### 有关文件指针和EOF的注意事项\n关键在于文件指针何时指向EOF：只有当进行fgetc操作后文件指针后才会指向EOF，此使feof的返回值才为真，没进行fgetc操作前，文件指针仍未指向EOF。若不注意可能在读取时将EOF读取。\n~~~\nvoid test01() {\n\n\tFILE* fp = fopen(\"./test.txt\", \"r\");\n\n\tchar ch;\n\twhile (!feof(fp)) {//注意：该写法将会读取出EOF，因为只有当进行了fgetc操作，文件指针才指向EOF，FILE 中的flag值才会改变，此刻的feof(fp)返回值才为真。\n\n\t\tch = fgetc(fp);\n\n\t\t//加入判断可避免读取出EOF，进行完fgetc操作后文件指针已经指向了EOF\n\t\tif (feof(fp))\n\t\t\tbreak;\n\n\t\tprintf(\"%c\", ch);\n\n\t}\n\n\tfclose(fp);\n\tfp = NULL;\n\n}\n~~~\n下面的写法可以直接规避打印EOF的情况\n~~~\nvoid test02() {\n\n\tFILE* fp = fopen(\"./test.txt\", \"r\");\n\n\tchar ch;\n\twhile ((ch = fgetc(fp)) != EOF) {\n\t\tprintf(\"%c\", ch);\n\t}\n\n\tfclose(fp);\n\tfp = NULL;\n}\n~~~\n\n---\n\n\n### 配置文件读写代码\n\n思路如下: 有如下的配置文件，现需要按找指定格式读取其中有用的key值和value值，如ip:192.168.137.134，ip地址对应key值，192.168.137.134对应value值。将文件中所有有效的key，value值读取后为其分配对应的内存空间，并存放与结构体中，且之后可以通过给定一个key值返回对应的value值。\n\n![359febb5d031e91e0bb5f0abb4c31abca5ff.png](https://miao.su/images/2019/07/16/359febb5d031e91e0bb5f0abb4c31abca5ff.png)\n\n以下是头文件，定义好函数原型以及存储key，value的结构体，实现过程有点复杂，但是更重要的是**理解各个函数调用的过程以及参数的传递作用**！！！\n~~~\n//防止头文件重复包含\n#pragma once\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n//为了C++能够调用C写的函数\n#ifdef __cplusplus\n\textern \"C\" {\n#endif\n\n\tstruct ConfigInfo {\n\t\tchar key[64];\n\t\tchar value[128];\n\t};\n\n\t//获取文件有效行\n\tint getLines_ConfigFile(FILE* file);\n\n\t//加载配置文件\n\tvoid loadFile_ConfigFile(const char* filePath, char*** fileData, int* line);\n\n\t//解析配置文件\n\tvoid parseFile_ConfigFile(const char** fileData, int line, struct ConfigInfo** info);\n\n\t//获得指定配置信息\n\tvoid getInfo_ConfigFile(const char* key, struct ConfigInfo* info, int line);\n\n\t//释放配置文件信息\n\tvoid destroyFile_ConfigFile(struct ConfigInfo* info);\n\n\t//判断当前行是否有效\n\tint isValid_ConfigFile(const char* buf);\n\n\n#ifdef __cplusplus\n\t}\n#endif \n~~~\n\n以下为功能实现文件\n\n获取文件有效行\n~~~\n#include \"ConfigFile.h\"\n\nint getLines_ConfigFile(FILE* file) {\n\n\tchar buf[1024] = { 0 };\n\tint lines = 0;\n\t\n\twhile (fgets(buf, 1024, file) != NULL) {\n\t\t\n\t\tif (!isValid_ConfigFile(buf)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tmemset(buf, 0, 1024);\n\n\t\t++lines;\n\t}\n\n\tfseek(file, 0, SEEK_SET);\n\n\treturn lines;\n\n}\n~~~\n加载配置文件\n~~~\nvoid loadFile_ConfigFile(const char* filePath, char*** fileData, int* line) {\n\n\tFILE* file = fopen(filePath, \"r\");\n\n\tif (NULL == file)\n\t\treturn;\n\n\tint lines = getLines_ConfigFile(file);\n\tchar** temp = malloc(sizeof(char*) * lines);\n\n\tchar buf[1024] = { 0 };\n\tint index = 0;\n\n\twhile (fgets(buf, 1024, file) != NULL) {\n\n\t\tif (!isValid_ConfigFile(buf))//返回false时，则该行无效，读取下一行\n\t\t\tcontinue;\n\n\t\ttemp[index] = malloc(sizeof(char) * strlen(buf) + 1);\n\n\t\tstrcpy(temp[index], buf);\n\n\t\t++index;\n\n\t\tmemset(buf, 0, 1024);\n\t}\n\n\t*fileData = temp;\n\t*line = lines;\n\n\tfclose(file);\n\n}\n~~~\n解析配置文件\n~~~\nvoid parseFile_ConfigFile(const char** fileData, int line, struct ConfigInfo** info) {\n\n\tstruct ConfigInfo* myInfo = malloc(sizeof(struct ConfigInfo) * line);\n\tmemset(myInfo, 0, sizeof(struct ConfigInfo) * line);\n\n\tfor (int i = 0; i < line; ++i) {\n\n\t\tchar* pos = strchr(fileData[i], ':');\n\n\t\tstrncpy(myInfo[i].key, fileData[i], pos - fileData[i]);\n\n\t\tint flag = 0;\n\t\tif (fileData[i][strlen(fileData[i]) - 1] == '\\n') {//等价于*(fileData[i] + strlen(fileData[i]) - 1);\n\t\t\t//此使代表该行结尾为换行\n\t\t\tflag = 1;\n\t\t\tprintf(\"该行有换行\\n\");\n\t\t}\n\n\t\tstrncpy(myInfo[i].value, pos + 1, strlen(pos + 1) - flag);//将有换行的'\\n'不进行拷贝\n\n\t\tprintf(\"key = %s  value = %s\\n\", myInfo[i].key, myInfo[i].value);\n\n\t}\n\n//释放文件信息\n\tfor (int i = 0; i < line; ++i) {\n\t\tif (fileData[i] != NULL) {\n\t\t\t\n\t\t\tfree(fileData[i]);\n\t\t\tfileData[i] = NULL;\n\t\t\n\t\t}\n\t}\n\n\t*info = myInfo;\n\n}\n~~~\n获得指定配置信息\n~~~\nvoid getInfo_ConfigFile(const char* key, struct ConfigInfo* info, int line) {\n\n\tfor (int i = 0; i < line; ++i)\n\t{\n\t\tif (strcmp(key, info[i].key) == 0)\n\t\t{\n\t\t\treturn info[i].value;\n\t\t}\n\t}\n~~~\n释放配置文件信息\n~~~\nvoid destroyFile_ConfigFile(struct ConfigInfo* info) {\n\n\tif(NULL == info)\n\t{\n\t\treturn;\n\t}\n\n\tfree(info);\n\tinfo = NULL;\n\n}\n~~~\n判断当前行是否有效\n~~~\nint isValid_ConfigFile(const char* buf) {\n\n\tif (buf[0] == '#' || buf[0] == '\\n' || (strchr(buf, ':') == NULL))\n\t\treturn 0;\n\n\treturn 1;\n\n}\n~~~\n以下为测试功能函数以及主函数文件\n~~~\nvoid test() {\n\t\n\tchar** fileData = NULL;\n\tint lines = 0;\n\tstruct ConfigInfo* myInfo = NULL;\n\n\tloadFile_ConfigFile(\"./config.ini\", &fileData, &lines);\n\n\tprintf(\"%d\\n\", lines);\n\n\tparseFile_ConfigFile(fileData, lines, &myInfo);\n\n\tdestroyFile_ConfigFile(myInfo);\n\n}\n\nint main() {\n\ttest();\n}\n~~~\n\nPS：多次想放弃，磕磕绊绊看着源码一行一行改错。。。对这种逻辑复杂的配置文件读写案例，code之前切记画图，切记画图，切记画图。不画图，debug时泪流满面。","source":"_posts/2019-Holiday-Note-04.md","raw":"---\ntitle: Holiday Note_04\ndate: 2019-07-16 21:14:31\ncategories: C\ntags: [Note,C]\n---\n\n# Holiday Note_04\n\n放假第四天。今天学了**内存对齐**的原理与一系列原则(感觉还是挺简单的，主要突出了时间换空间的思想)，还有**文件打开，关闭以及缓冲区的一些补充知识**。另外写了两个练习，一个是**结构体嵌套二维指针**(依旧是练习分配释放内存，只不过这个练习以Teacher-Student模型分配了4层内存，内存的分配和释放操作还是挺细节的)。另一个练习是 **配置文件读写**案例，巨恶心，写头文件，然后将功能一一封装实现，最后调用测试功能，从下午写到晚上，晕头转向的，全是二级指针三级指针以及结构体指针，刚刚又好好想了一遍，为什么debug了这么久，总结了下是自己没理清楚参数传递的思路和调用过程就写，这样下来效率自然就低了，下次写这种复杂的案例时还是应该先画好图理清楚了再开始。\n\n\n<!-- more -->\n\n---\n\n## 内存对齐\n\n\n### 什么是内存对齐\n\n在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，\n这里涉及到内存字节对齐的问题。\n\n~~从理论上讲，对于任何变量的访问都可以从任何地址开始访问~~\n\n但是事实上不是如此，**实际上访问特定类型的变量只能在特定的地址访问**，\n这就需要各个变量在空间上按一定的规则排列， 而不是简单地顺序排列，这就是内存对齐。\n\n我们知道内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取\n\n但是实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等，\n\n***\n\n### 内存对齐的优缺点\n\n> 空间换时间\n\n内存对齐是操作系统为了**提高访问内存的策略**。**操作系统在访问内存的时候，每次读取一定长度(这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍)**。如果没有对齐，为了访问一个变量可能产生*二次访问*。而且要注意的是某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统。\n\n---\n\n### 内存对齐的三大原则\n\n- 对于*标准数据类型*，它的地址只要是它的**长度的整数倍**。\n\n\n- 对于非标准数据类型，比如结构体，要遵循以下对齐原则：\n\n1. 数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在**offset为min（当前成员的大小，#pargama pack(n)）整数倍**的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。\n\n2. **结构体总的大小**，也就是sizeof的结果，必须是min（结构体内部最大成员，#pargama pack(n)）的整数倍，**不足要补齐**。\n\n3. 结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是**结构体A的起点为A内部最大成员的整数倍的地方**。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。\n\n\n辅助理解代码如下：\n\n下面这条代码是显示当前packing alignment的字节数，以warning message的形式被显示。我在VS上显示的结果是8.\n~~~\n#pragma pack(show)\n~~~\n[![463d913c5f9d055218431668f3e527249333.md.png](https://miao.su/images/2019/07/16/463d913c5f9d055218431668f3e527249333.md.png)](https://miao.su/image/TaHgL)\n\n~~~\ntypedef struct _STUDENT1 {\n\tint a;//0-3\n\tchar b;//4\n\tdouble c;//8-15  每个成员必须放在min（当前成员的大小，#pargama pack(n)）整数倍的地方开始\n\tfloat d;//16-19   结构体总的大小必须为min（结构体内部最大成员，#pargama pack(n)）为8的整数倍，因此0-23  大小一共为24\n}Student1;\n\n\ntypedef struct _STUDENT2 {\n\tchar a;//0\n\tStudent1 b;//8-31 结构体A的起点为A内部最大成员的整数倍的地方\n\tdouble c;//32-39   0-39  40字节\n}Student2;\n~~~\n\n~~~\nvoid test() {\n\n\tprintf(\"%d\\n\", sizeof(Student1));//输出结果为24\n\tprintf(\"%d\\n\", sizeof(Student2));//输出结果为40\n\n}\n~~~\n\n---\n\n## 结构体嵌套二维指针练习\n\n![1205c38d33e627257b4b4.png](https://miao.su/images/2019/07/16/1205c38d33e627257b4b4.png)\n\n结构体如下所示，模型为一个Teacher类型的二级指针，为它分配存放三个Teacher类型的一个指针类型用于存放数据，这三个Teacher类型的一级指针再为name和students分配空间，其中students为二级指针即表示有多个学生，因此使用以及分配的二维指针students继续分配4个一维指针存放学生姓名。该案例关键在于**训练分配内存和释放内存的次序以及判定条件的书写**。\n~~~\nstruct Teacher {\n\tchar* name;\n\tchar** students;\n};\n~~~\n\n~~~\nvoid printTeacher(struct Teacher** ts) {\n\tfor (int i = 0; i < 3; ++i) {\n\n\t\tprintf(\"%s\\n\", ts[i]->name);\n\n\t\tfor (int j = 0; j < 5; ++j) {\n\n\t\t\tprintf(\"%s\\n\", ts[i]->students[j]);\n\n\t\t}\n\t}\n}\n~~~\n\n分配内存\n~~~\nint allocateSpace(struct Teacher*** ts) {\n\t\n\tif (NULL == ts)\n\t\treturn -1;\n\t\n\tstruct Teacher** temp = malloc(sizeof(struct Teacher*) * 3);\n\n\tfor (int i = 0; i < 3; ++i) {\n\n\t\ttemp[i] = malloc(sizeof(struct Teacher));\n\n\t\ttemp[i]->name = malloc(sizeof(char) * 64);\n\n\t\tsprintf(temp[i]->name, \"Teacher_%d\", i + 1);\n\n\t\ttemp[i]->students = malloc(sizeof(char*) * 5);\n\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\ttemp[i]->students[j] = malloc(sizeof(char) * 64);\n\t\t\tsprintf(temp[i]->students[j], \"\\tStudent_%d\", j + 1);\n\t\t}\n\n\t}\n\n\t//指针的间接赋值\n\t*ts = temp;\n\n\treturn 0;\n}\n~~~\n**释放内存(关键)**\n~~~\nvoid freeSpace(struct Teacher** ts) {\n\n\tif (NULL == ts)\n\t\treturn;\n\n\tfor (int i = 0; i < 3; ++i) {\n\n\t\tif (NULL == ts[i])\n\t\t\tcontinue;\n\n\t\tif (ts[i]->name != NULL) {\n\t\t\tfree(ts[i]->name);\n\t\t\tts[i]->name = NULL;\n\t\t}\n\n\t\tif (ts[i]->students != NULL) {\n\n\t\t\tfor (int j = 0; j < 5; ++j) {\n\n\t\t\t\tif (NULL == ts[i]->students[j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfree(ts[i]->students[j]);\n\t\t\t\tts[i]->students[j] = NULL;\n\n\t\t\t}\n\n\t\t\tfree(ts[i]->students);\n\t\t\tts[i]->students = NULL;\n\n\t\t}\n\n\t\tfree(ts[i]);\n\t\tts[i] = NULL;\n\n\t}\n\n\tfree(ts);\n\tts = NULL;\n\n}\n~~~\n调用函数\n~~~\nvoid test() {\n\n\tstruct Teacher** teacher;\n\n\tteacher = NULL;\n\n\t//定义allocateSpace函数返回值类型为int的目的为接收不同情况的错误码\n\tprintf(\"%d\\n\", allocateSpace(&teacher));\n\n\tprintTeacher(teacher);\n\n\tfreeSpace(teacher);\n\n}\n\n\nint main() {\n\ttest();\n}\n~~~\n\n---\n\n## 文件相关\n\n### 文件缓冲区\n\n如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以**减少磁盘的读写次数**，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大**提高计算机的运行速度**。\n\n![566664cfae.png](https://miao.su/images/2019/07/16/566664cfae.png)\n\n\n---\n\n### 理解fopen与fclose与文件缓冲区的关系\n文件的打开操作表示将给用户指定的文件在内存**分配一个FILE结构区**，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。\n\n*只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去*，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。**文件的关闭也意味着释放了该文件的缓冲区**。\n\n---\n\n### 有关文件指针和EOF的注意事项\n关键在于文件指针何时指向EOF：只有当进行fgetc操作后文件指针后才会指向EOF，此使feof的返回值才为真，没进行fgetc操作前，文件指针仍未指向EOF。若不注意可能在读取时将EOF读取。\n~~~\nvoid test01() {\n\n\tFILE* fp = fopen(\"./test.txt\", \"r\");\n\n\tchar ch;\n\twhile (!feof(fp)) {//注意：该写法将会读取出EOF，因为只有当进行了fgetc操作，文件指针才指向EOF，FILE 中的flag值才会改变，此刻的feof(fp)返回值才为真。\n\n\t\tch = fgetc(fp);\n\n\t\t//加入判断可避免读取出EOF，进行完fgetc操作后文件指针已经指向了EOF\n\t\tif (feof(fp))\n\t\t\tbreak;\n\n\t\tprintf(\"%c\", ch);\n\n\t}\n\n\tfclose(fp);\n\tfp = NULL;\n\n}\n~~~\n下面的写法可以直接规避打印EOF的情况\n~~~\nvoid test02() {\n\n\tFILE* fp = fopen(\"./test.txt\", \"r\");\n\n\tchar ch;\n\twhile ((ch = fgetc(fp)) != EOF) {\n\t\tprintf(\"%c\", ch);\n\t}\n\n\tfclose(fp);\n\tfp = NULL;\n}\n~~~\n\n---\n\n\n### 配置文件读写代码\n\n思路如下: 有如下的配置文件，现需要按找指定格式读取其中有用的key值和value值，如ip:192.168.137.134，ip地址对应key值，192.168.137.134对应value值。将文件中所有有效的key，value值读取后为其分配对应的内存空间，并存放与结构体中，且之后可以通过给定一个key值返回对应的value值。\n\n![359febb5d031e91e0bb5f0abb4c31abca5ff.png](https://miao.su/images/2019/07/16/359febb5d031e91e0bb5f0abb4c31abca5ff.png)\n\n以下是头文件，定义好函数原型以及存储key，value的结构体，实现过程有点复杂，但是更重要的是**理解各个函数调用的过程以及参数的传递作用**！！！\n~~~\n//防止头文件重复包含\n#pragma once\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n//为了C++能够调用C写的函数\n#ifdef __cplusplus\n\textern \"C\" {\n#endif\n\n\tstruct ConfigInfo {\n\t\tchar key[64];\n\t\tchar value[128];\n\t};\n\n\t//获取文件有效行\n\tint getLines_ConfigFile(FILE* file);\n\n\t//加载配置文件\n\tvoid loadFile_ConfigFile(const char* filePath, char*** fileData, int* line);\n\n\t//解析配置文件\n\tvoid parseFile_ConfigFile(const char** fileData, int line, struct ConfigInfo** info);\n\n\t//获得指定配置信息\n\tvoid getInfo_ConfigFile(const char* key, struct ConfigInfo* info, int line);\n\n\t//释放配置文件信息\n\tvoid destroyFile_ConfigFile(struct ConfigInfo* info);\n\n\t//判断当前行是否有效\n\tint isValid_ConfigFile(const char* buf);\n\n\n#ifdef __cplusplus\n\t}\n#endif \n~~~\n\n以下为功能实现文件\n\n获取文件有效行\n~~~\n#include \"ConfigFile.h\"\n\nint getLines_ConfigFile(FILE* file) {\n\n\tchar buf[1024] = { 0 };\n\tint lines = 0;\n\t\n\twhile (fgets(buf, 1024, file) != NULL) {\n\t\t\n\t\tif (!isValid_ConfigFile(buf)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tmemset(buf, 0, 1024);\n\n\t\t++lines;\n\t}\n\n\tfseek(file, 0, SEEK_SET);\n\n\treturn lines;\n\n}\n~~~\n加载配置文件\n~~~\nvoid loadFile_ConfigFile(const char* filePath, char*** fileData, int* line) {\n\n\tFILE* file = fopen(filePath, \"r\");\n\n\tif (NULL == file)\n\t\treturn;\n\n\tint lines = getLines_ConfigFile(file);\n\tchar** temp = malloc(sizeof(char*) * lines);\n\n\tchar buf[1024] = { 0 };\n\tint index = 0;\n\n\twhile (fgets(buf, 1024, file) != NULL) {\n\n\t\tif (!isValid_ConfigFile(buf))//返回false时，则该行无效，读取下一行\n\t\t\tcontinue;\n\n\t\ttemp[index] = malloc(sizeof(char) * strlen(buf) + 1);\n\n\t\tstrcpy(temp[index], buf);\n\n\t\t++index;\n\n\t\tmemset(buf, 0, 1024);\n\t}\n\n\t*fileData = temp;\n\t*line = lines;\n\n\tfclose(file);\n\n}\n~~~\n解析配置文件\n~~~\nvoid parseFile_ConfigFile(const char** fileData, int line, struct ConfigInfo** info) {\n\n\tstruct ConfigInfo* myInfo = malloc(sizeof(struct ConfigInfo) * line);\n\tmemset(myInfo, 0, sizeof(struct ConfigInfo) * line);\n\n\tfor (int i = 0; i < line; ++i) {\n\n\t\tchar* pos = strchr(fileData[i], ':');\n\n\t\tstrncpy(myInfo[i].key, fileData[i], pos - fileData[i]);\n\n\t\tint flag = 0;\n\t\tif (fileData[i][strlen(fileData[i]) - 1] == '\\n') {//等价于*(fileData[i] + strlen(fileData[i]) - 1);\n\t\t\t//此使代表该行结尾为换行\n\t\t\tflag = 1;\n\t\t\tprintf(\"该行有换行\\n\");\n\t\t}\n\n\t\tstrncpy(myInfo[i].value, pos + 1, strlen(pos + 1) - flag);//将有换行的'\\n'不进行拷贝\n\n\t\tprintf(\"key = %s  value = %s\\n\", myInfo[i].key, myInfo[i].value);\n\n\t}\n\n//释放文件信息\n\tfor (int i = 0; i < line; ++i) {\n\t\tif (fileData[i] != NULL) {\n\t\t\t\n\t\t\tfree(fileData[i]);\n\t\t\tfileData[i] = NULL;\n\t\t\n\t\t}\n\t}\n\n\t*info = myInfo;\n\n}\n~~~\n获得指定配置信息\n~~~\nvoid getInfo_ConfigFile(const char* key, struct ConfigInfo* info, int line) {\n\n\tfor (int i = 0; i < line; ++i)\n\t{\n\t\tif (strcmp(key, info[i].key) == 0)\n\t\t{\n\t\t\treturn info[i].value;\n\t\t}\n\t}\n~~~\n释放配置文件信息\n~~~\nvoid destroyFile_ConfigFile(struct ConfigInfo* info) {\n\n\tif(NULL == info)\n\t{\n\t\treturn;\n\t}\n\n\tfree(info);\n\tinfo = NULL;\n\n}\n~~~\n判断当前行是否有效\n~~~\nint isValid_ConfigFile(const char* buf) {\n\n\tif (buf[0] == '#' || buf[0] == '\\n' || (strchr(buf, ':') == NULL))\n\t\treturn 0;\n\n\treturn 1;\n\n}\n~~~\n以下为测试功能函数以及主函数文件\n~~~\nvoid test() {\n\t\n\tchar** fileData = NULL;\n\tint lines = 0;\n\tstruct ConfigInfo* myInfo = NULL;\n\n\tloadFile_ConfigFile(\"./config.ini\", &fileData, &lines);\n\n\tprintf(\"%d\\n\", lines);\n\n\tparseFile_ConfigFile(fileData, lines, &myInfo);\n\n\tdestroyFile_ConfigFile(myInfo);\n\n}\n\nint main() {\n\ttest();\n}\n~~~\n\nPS：多次想放弃，磕磕绊绊看着源码一行一行改错。。。对这种逻辑复杂的配置文件读写案例，code之前切记画图，切记画图，切记画图。不画图，debug时泪流满面。","slug":"2019-Holiday-Note-04","published":1,"updated":"2019-07-16T14:40:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihb0008smjbhi1uuce4","content":"<h1 id=\"Holiday-Note-04\"><a href=\"#Holiday-Note-04\" class=\"headerlink\" title=\"Holiday Note_04\"></a>Holiday Note_04</h1><p>放假第四天。今天学了<strong>内存对齐</strong>的原理与一系列原则(感觉还是挺简单的，主要突出了时间换空间的思想)，还有<strong>文件打开，关闭以及缓冲区的一些补充知识</strong>。另外写了两个练习，一个是<strong>结构体嵌套二维指针</strong>(依旧是练习分配释放内存，只不过这个练习以Teacher-Student模型分配了4层内存，内存的分配和释放操作还是挺细节的)。另一个练习是 <strong>配置文件读写</strong>案例，巨恶心，写头文件，然后将功能一一封装实现，最后调用测试功能，从下午写到晚上，晕头转向的，全是二级指针三级指针以及结构体指针，刚刚又好好想了一遍，为什么debug了这么久，总结了下是自己没理清楚参数传递的思路和调用过程就写，这样下来效率自然就低了，下次写这种复杂的案例时还是应该先画好图理清楚了再开始。</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"内存对齐\"><a href=\"#内存对齐\" class=\"headerlink\" title=\"内存对齐\"></a>内存对齐</h2><h3 id=\"什么是内存对齐\"><a href=\"#什么是内存对齐\" class=\"headerlink\" title=\"什么是内存对齐\"></a>什么是内存对齐</h3><p>在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，<br>这里涉及到内存字节对齐的问题。</p>\n<p><del>从理论上讲，对于任何变量的访问都可以从任何地址开始访问</del></p>\n<p>但是事实上不是如此，<strong>实际上访问特定类型的变量只能在特定的地址访问</strong>，<br>这就需要各个变量在空间上按一定的规则排列， 而不是简单地顺序排列，这就是内存对齐。</p>\n<p>我们知道内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取</p>\n<p>但是实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等，</p>\n<hr>\n<h3 id=\"内存对齐的优缺点\"><a href=\"#内存对齐的优缺点\" class=\"headerlink\" title=\"内存对齐的优缺点\"></a>内存对齐的优缺点</h3><blockquote>\n<p>空间换时间</p>\n</blockquote>\n<p>内存对齐是操作系统为了<strong>提高访问内存的策略</strong>。<strong>操作系统在访问内存的时候，每次读取一定长度(这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍)</strong>。如果没有对齐，为了访问一个变量可能产生<em>二次访问</em>。而且要注意的是某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统。</p>\n<hr>\n<h3 id=\"内存对齐的三大原则\"><a href=\"#内存对齐的三大原则\" class=\"headerlink\" title=\"内存对齐的三大原则\"></a>内存对齐的三大原则</h3><ul>\n<li>对于<em>标准数据类型</em>，它的地址只要是它的<strong>长度的整数倍</strong>。</li>\n</ul>\n<ul>\n<li>对于非标准数据类型，比如结构体，要遵循以下对齐原则：</li>\n</ul>\n<ol>\n<li><p>数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在<strong>offset为min（当前成员的大小，#pargama pack(n)）整数倍</strong>的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。</p>\n</li>\n<li><p><strong>结构体总的大小</strong>，也就是sizeof的结果，必须是min（结构体内部最大成员，#pargama pack(n)）的整数倍，<strong>不足要补齐</strong>。</p>\n</li>\n<li><p>结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是<strong>结构体A的起点为A内部最大成员的整数倍的地方</strong>。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。</p>\n</li>\n</ol>\n<p>辅助理解代码如下：</p>\n<p>下面这条代码是显示当前packing alignment的字节数，以warning message的形式被显示。我在VS上显示的结果是8.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> pack(show)</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://miao.su/image/TaHgL\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/16/463d913c5f9d055218431668f3e527249333.md.png\" alt=\"463d913c5f9d055218431668f3e527249333.md.png\"></a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">STUDENT1</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a;<span class=\"comment\">//0-3</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> b;<span class=\"comment\">//4</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> c;<span class=\"comment\">//8-15  每个成员必须放在min（当前成员的大小，#pargama pack(n)）整数倍的地方开始</span></span><br><span class=\"line\">\t<span class=\"keyword\">float</span> d;<span class=\"comment\">//16-19   结构体总的大小必须为min（结构体内部最大成员，#pargama pack(n)）为8的整数倍，因此0-23  大小一共为24</span></span><br><span class=\"line\">&#125;Student1;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">STUDENT2</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> a;<span class=\"comment\">//0</span></span><br><span class=\"line\">\tStudent1 b;<span class=\"comment\">//8-31 结构体A的起点为A内部最大成员的整数倍的地方</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> c;<span class=\"comment\">//32-39   0-39  40字节</span></span><br><span class=\"line\">&#125;Student2;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, <span class=\"keyword\">sizeof</span>(Student1));<span class=\"comment\">//输出结果为24</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, <span class=\"keyword\">sizeof</span>(Student2));<span class=\"comment\">//输出结果为40</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"结构体嵌套二维指针练习\"><a href=\"#结构体嵌套二维指针练习\" class=\"headerlink\" title=\"结构体嵌套二维指针练习\"></a>结构体嵌套二维指针练习</h2><p><img src=\"https://miao.su/images/2019/07/16/1205c38d33e627257b4b4.png\" alt=\"1205c38d33e627257b4b4.png\"></p>\n<p>结构体如下所示，模型为一个Teacher类型的二级指针，为它分配存放三个Teacher类型的一个指针类型用于存放数据，这三个Teacher类型的一级指针再为name和students分配空间，其中students为二级指针即表示有多个学生，因此使用以及分配的二维指针students继续分配4个一维指针存放学生姓名。该案例关键在于<strong>训练分配内存和释放内存的次序以及判定条件的书写</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* name;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>** students;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void printTeacher(struct Teacher** ts) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int <span class=\"built_in\">i</span> = <span class=\"number\">0</span>; <span class=\"built_in\">i</span> &lt; <span class=\"number\">3</span>; ++<span class=\"built_in\">i</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprintf(<span class=\"string\">\"%s\\n\"</span>, ts[<span class=\"built_in\">i</span>]-&gt;name);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (int <span class=\"built_in\">j</span> = <span class=\"number\">0</span>; <span class=\"built_in\">j</span> &lt; <span class=\"number\">5</span>; ++<span class=\"built_in\">j</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tprintf(<span class=\"string\">\"%s\\n\"</span>, ts[<span class=\"built_in\">i</span>]-&gt;students[<span class=\"built_in\">j</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分配内存</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int allocateSpace(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span></span>*** ts) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == ts)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span></span>** temp = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span></span>*) * <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttemp[i] = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span></span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttemp[i]-&gt;name = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"built_in\">char</span>) * <span class=\"number\">64</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsprintf(temp[i]-&gt;name, <span class=\"string\">\"Teacher_%d\"</span>, i + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttemp[i]-&gt;students = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"built_in\">char</span>*) * <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (int j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; ++j) &#123;</span><br><span class=\"line\">\t\t\ttemp[i]-&gt;students[j] = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"built_in\">char</span>) * <span class=\"number\">64</span>);</span><br><span class=\"line\">\t\t\tsprintf(temp[i]-&gt;students[j], <span class=\"string\">\"\\tStudent_%d\"</span>, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//指针的间接赋值</span></span><br><span class=\"line\">\t*ts = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>释放内存(关键)</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void freeSpace(struct Teacher** ts) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == ts)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int <span class=\"built_in\">i</span> = <span class=\"number\">0</span>; <span class=\"built_in\">i</span> &lt; <span class=\"number\">3</span>; ++<span class=\"built_in\">i</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (NULL == ts[<span class=\"built_in\">i</span>])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ts[<span class=\"built_in\">i</span>]-&gt;name != NULL) &#123;</span><br><span class=\"line\">\t\t\tfree(ts[<span class=\"built_in\">i</span>]-&gt;name);</span><br><span class=\"line\">\t\t\tts[<span class=\"built_in\">i</span>]-&gt;name = NULL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ts[<span class=\"built_in\">i</span>]-&gt;students != NULL) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (int <span class=\"built_in\">j</span> = <span class=\"number\">0</span>; <span class=\"built_in\">j</span> &lt; <span class=\"number\">5</span>; ++<span class=\"built_in\">j</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (NULL == ts[<span class=\"built_in\">i</span>]-&gt;students[<span class=\"built_in\">j</span>]) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tfree(ts[<span class=\"built_in\">i</span>]-&gt;students[<span class=\"built_in\">j</span>]);</span><br><span class=\"line\">\t\t\t\tts[<span class=\"built_in\">i</span>]-&gt;students[<span class=\"built_in\">j</span>] = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfree(ts[<span class=\"built_in\">i</span>]-&gt;students);</span><br><span class=\"line\">\t\t\tts[<span class=\"built_in\">i</span>]-&gt;students = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfree(ts[<span class=\"built_in\">i</span>]);</span><br><span class=\"line\">\t\tts[<span class=\"built_in\">i</span>] = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfree(ts);</span><br><span class=\"line\">\tts = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span>** <span class=\"title\">teacher</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tteacher = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//定义allocateSpace函数返回值类型为int的目的为接收不同情况的错误码</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, allocateSpace(&amp;teacher));</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintTeacher(teacher);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfreeSpace(teacher);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\ttest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"文件相关\"><a href=\"#文件相关\" class=\"headerlink\" title=\"文件相关\"></a>文件相关</h2><h3 id=\"文件缓冲区\"><a href=\"#文件缓冲区\" class=\"headerlink\" title=\"文件缓冲区\"></a>文件缓冲区</h3><p>如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以<strong>减少磁盘的读写次数</strong>，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大<strong>提高计算机的运行速度</strong>。</p>\n<p><img src=\"https://miao.su/images/2019/07/16/566664cfae.png\" alt=\"566664cfae.png\"></p>\n<hr>\n<h3 id=\"理解fopen与fclose与文件缓冲区的关系\"><a href=\"#理解fopen与fclose与文件缓冲区的关系\" class=\"headerlink\" title=\"理解fopen与fclose与文件缓冲区的关系\"></a>理解fopen与fclose与文件缓冲区的关系</h3><p>文件的打开操作表示将给用户指定的文件在内存<strong>分配一个FILE结构区</strong>，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。</p>\n<p><em>只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去</em>，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。<strong>文件的关闭也意味着释放了该文件的缓冲区</strong>。</p>\n<hr>\n<h3 id=\"有关文件指针和EOF的注意事项\"><a href=\"#有关文件指针和EOF的注意事项\" class=\"headerlink\" title=\"有关文件指针和EOF的注意事项\"></a>有关文件指针和EOF的注意事项</h3><p>关键在于文件指针何时指向EOF：只有当进行fgetc操作后文件指针后才会指向EOF，此使feof的返回值才为真，没进行fgetc操作前，文件指针仍未指向EOF。若不注意可能在读取时将EOF读取。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFILE* fp = fopen(<span class=\"string\">\"./test.txt\"</span>, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!feof(fp)) &#123;<span class=\"comment\">//注意：该写法将会读取出EOF，因为只有当进行了fgetc操作，文件指针才指向EOF，FILE 中的flag值才会改变，此刻的feof(fp)返回值才为真。</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tch = fgetc(fp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//加入判断可避免读取出EOF，进行完fgetc操作后文件指针已经指向了EOF</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (feof(fp))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, ch);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfclose(fp);</span><br><span class=\"line\">\tfp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的写法可以直接规避打印EOF的情况</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test02() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFILE* <span class=\"built_in\">fp</span> = fopen(<span class=\"string\">\"./test.txt\"</span>, <span class=\"string\">\"r\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tchar ch<span class=\"comment\">;</span></span><br><span class=\"line\">\twhile ((ch = fgetc(<span class=\"built_in\">fp</span>)) != EOF) &#123;</span><br><span class=\"line\">\t\tprintf(<span class=\"string\">\"%c\"</span>, ch)<span class=\"comment\">;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfclose(<span class=\"built_in\">fp</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"built_in\">fp</span> = NULL<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"配置文件读写代码\"><a href=\"#配置文件读写代码\" class=\"headerlink\" title=\"配置文件读写代码\"></a>配置文件读写代码</h3><p>思路如下: 有如下的配置文件，现需要按找指定格式读取其中有用的key值和value值，如ip:192.168.137.134，ip地址对应key值，192.168.137.134对应value值。将文件中所有有效的key，value值读取后为其分配对应的内存空间，并存放与结构体中，且之后可以通过给定一个key值返回对应的value值。</p>\n<p><img src=\"https://miao.su/images/2019/07/16/359febb5d031e91e0bb5f0abb4c31abca5ff.png\" alt=\"359febb5d031e91e0bb5f0abb4c31abca5ff.png\"></p>\n<p>以下是头文件，定义好函数原型以及存储key，value的结构体，实现过程有点复杂，但是更重要的是<strong>理解各个函数调用的过程以及参数的传递作用</strong>！！！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//防止头文件重复包含</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//为了C++能够调用C写的函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">\t<span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ConfigInfo</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> key[<span class=\"number\">64</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> value[<span class=\"number\">128</span>];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//获取文件有效行</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLines_ConfigFile</span><span class=\"params\">(FILE* file)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//加载配置文件</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loadFile_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filePath, <span class=\"keyword\">char</span>*** fileData, <span class=\"keyword\">int</span>* line)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//解析配置文件</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">parseFile_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>** fileData, <span class=\"keyword\">int</span> line, struct ConfigInfo** info)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//获得指定配置信息</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getInfo_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* key, struct ConfigInfo* info, <span class=\"keyword\">int</span> line)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//释放配置文件信息</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroyFile_ConfigFile</span><span class=\"params\">(struct ConfigInfo* info)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//判断当前行是否有效</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isValid_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>以下为功能实现文件</p>\n<p>获取文件有效行</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">include</span> <span class=\"string\">\"ConfigFile.h\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> getLines_ConfigFile(<span class=\"keyword\">FILE</span>* <span class=\"keyword\">file</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lines = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (fgets(buf, <span class=\"number\">1024</span>, <span class=\"keyword\">file</span>) != <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isValid_ConfigFile(buf)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmemset(buf, <span class=\"number\">0</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t++lines;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfseek(<span class=\"keyword\">file</span>, <span class=\"number\">0</span>, SEEK_SET);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lines;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加载配置文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loadFile_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filePath, <span class=\"keyword\">char</span>*** fileData, <span class=\"keyword\">int</span>* line)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFILE* file = fopen(filePath, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == file)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lines = getLines_ConfigFile(file);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>** temp = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>*) * lines);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (fgets(buf, <span class=\"number\">1024</span>, file) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isValid_ConfigFile(buf))<span class=\"comment\">//返回false时，则该行无效，读取下一行</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttemp[index] = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) * <span class=\"built_in\">strlen</span>(buf) + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(temp[index], buf);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t++index;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(buf, <span class=\"number\">0</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*fileData = temp;</span><br><span class=\"line\">\t*line = lines;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfclose(file);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解析配置文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">parseFile_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>** fileData, <span class=\"keyword\">int</span> line, struct ConfigInfo** info)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ConfigInfo</span>* <span class=\"title\">myInfo</span> = <span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">ConfigInfo</span>) * <span class=\"title\">line</span>);</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(myInfo, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(struct ConfigInfo) * line);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; line; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>* pos = <span class=\"built_in\">strchr</span>(fileData[i], <span class=\"string\">':'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">strncpy</span>(myInfo[i].key, fileData[i], pos - fileData[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fileData[i][<span class=\"built_in\">strlen</span>(fileData[i]) - <span class=\"number\">1</span>] == <span class=\"string\">'\\n'</span>) &#123;<span class=\"comment\">//等价于*(fileData[i] + strlen(fileData[i]) - 1);</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//此使代表该行结尾为换行</span></span><br><span class=\"line\">\t\t\tflag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"该行有换行\\n\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">strncpy</span>(myInfo[i].value, pos + <span class=\"number\">1</span>, <span class=\"built_in\">strlen</span>(pos + <span class=\"number\">1</span>) - flag);<span class=\"comment\">//将有换行的'\\n'不进行拷贝</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"key = %s  value = %s\\n\"</span>, myInfo[i].key, myInfo[i].value);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//释放文件信息</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; line; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fileData[i] != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(fileData[i]);</span><br><span class=\"line\">\t\t\tfileData[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*info = myInfo;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>获得指定配置信息</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> getInfo_ConfigFile(<span class=\"keyword\">const</span> <span class=\"built_in\">char</span>* <span class=\"built_in\">key</span>, struct ConfigInfo* info, <span class=\"built_in\">int</span> <span class=\"built_in\">line</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">line</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (strcmp(<span class=\"built_in\">key</span>, info[i].<span class=\"built_in\">key</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> info[i].value;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>释放配置文件信息</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroyFile_ConfigFile</span><span class=\"params\">(struct ConfigInfo* info)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == info)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(info);</span><br><span class=\"line\">\tinfo = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判断当前行是否有效</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isValid_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* buf)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (buf[<span class=\"number\">0</span>] == <span class=\"string\">'#'</span> || buf[<span class=\"number\">0</span>] == <span class=\"string\">'\\n'</span> || (<span class=\"built_in\">strchr</span>(buf, <span class=\"string\">':'</span>) == <span class=\"literal\">NULL</span>))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下为测试功能函数以及主函数文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>** fileData = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lines = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ConfigInfo</span>* <span class=\"title\">myInfo</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tloadFile_ConfigFile(<span class=\"string\">\"./config.ini\"</span>, &amp;fileData, &amp;lines);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, lines);</span><br><span class=\"line\"></span><br><span class=\"line\">\tparseFile_ConfigFile(fileData, lines, &amp;myInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">\tdestroyFile_ConfigFile(myInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\ttest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS：多次想放弃，磕磕绊绊看着源码一行一行改错。。。对这种逻辑复杂的配置文件读写案例，code之前切记画图，切记画图，切记画图。不画图，debug时泪流满面。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-04\"><a href=\"#Holiday-Note-04\" class=\"headerlink\" title=\"Holiday Note_04\"></a>Holiday Note_04</h1><p>放假第四天。今天学了<strong>内存对齐</strong>的原理与一系列原则(感觉还是挺简单的，主要突出了时间换空间的思想)，还有<strong>文件打开，关闭以及缓冲区的一些补充知识</strong>。另外写了两个练习，一个是<strong>结构体嵌套二维指针</strong>(依旧是练习分配释放内存，只不过这个练习以Teacher-Student模型分配了4层内存，内存的分配和释放操作还是挺细节的)。另一个练习是 <strong>配置文件读写</strong>案例，巨恶心，写头文件，然后将功能一一封装实现，最后调用测试功能，从下午写到晚上，晕头转向的，全是二级指针三级指针以及结构体指针，刚刚又好好想了一遍，为什么debug了这么久，总结了下是自己没理清楚参数传递的思路和调用过程就写，这样下来效率自然就低了，下次写这种复杂的案例时还是应该先画好图理清楚了再开始。</p>","more":"<hr>\n<h2 id=\"内存对齐\"><a href=\"#内存对齐\" class=\"headerlink\" title=\"内存对齐\"></a>内存对齐</h2><h3 id=\"什么是内存对齐\"><a href=\"#什么是内存对齐\" class=\"headerlink\" title=\"什么是内存对齐\"></a>什么是内存对齐</h3><p>在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，<br>这里涉及到内存字节对齐的问题。</p>\n<p><del>从理论上讲，对于任何变量的访问都可以从任何地址开始访问</del></p>\n<p>但是事实上不是如此，<strong>实际上访问特定类型的变量只能在特定的地址访问</strong>，<br>这就需要各个变量在空间上按一定的规则排列， 而不是简单地顺序排列，这就是内存对齐。</p>\n<p>我们知道内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取</p>\n<p>但是实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等，</p>\n<hr>\n<h3 id=\"内存对齐的优缺点\"><a href=\"#内存对齐的优缺点\" class=\"headerlink\" title=\"内存对齐的优缺点\"></a>内存对齐的优缺点</h3><blockquote>\n<p>空间换时间</p>\n</blockquote>\n<p>内存对齐是操作系统为了<strong>提高访问内存的策略</strong>。<strong>操作系统在访问内存的时候，每次读取一定长度(这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍)</strong>。如果没有对齐，为了访问一个变量可能产生<em>二次访问</em>。而且要注意的是某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统。</p>\n<hr>\n<h3 id=\"内存对齐的三大原则\"><a href=\"#内存对齐的三大原则\" class=\"headerlink\" title=\"内存对齐的三大原则\"></a>内存对齐的三大原则</h3><ul>\n<li>对于<em>标准数据类型</em>，它的地址只要是它的<strong>长度的整数倍</strong>。</li>\n</ul>\n<ul>\n<li>对于非标准数据类型，比如结构体，要遵循以下对齐原则：</li>\n</ul>\n<ol>\n<li><p>数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在<strong>offset为min（当前成员的大小，#pargama pack(n)）整数倍</strong>的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。</p>\n</li>\n<li><p><strong>结构体总的大小</strong>，也就是sizeof的结果，必须是min（结构体内部最大成员，#pargama pack(n)）的整数倍，<strong>不足要补齐</strong>。</p>\n</li>\n<li><p>结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是<strong>结构体A的起点为A内部最大成员的整数倍的地方</strong>。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。</p>\n</li>\n</ol>\n<p>辅助理解代码如下：</p>\n<p>下面这条代码是显示当前packing alignment的字节数，以warning message的形式被显示。我在VS上显示的结果是8.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> pack(show)</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://miao.su/image/TaHgL\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/16/463d913c5f9d055218431668f3e527249333.md.png\" alt=\"463d913c5f9d055218431668f3e527249333.md.png\"></a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">STUDENT1</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a;<span class=\"comment\">//0-3</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> b;<span class=\"comment\">//4</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> c;<span class=\"comment\">//8-15  每个成员必须放在min（当前成员的大小，#pargama pack(n)）整数倍的地方开始</span></span><br><span class=\"line\">\t<span class=\"keyword\">float</span> d;<span class=\"comment\">//16-19   结构体总的大小必须为min（结构体内部最大成员，#pargama pack(n)）为8的整数倍，因此0-23  大小一共为24</span></span><br><span class=\"line\">&#125;Student1;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">STUDENT2</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> a;<span class=\"comment\">//0</span></span><br><span class=\"line\">\tStudent1 b;<span class=\"comment\">//8-31 结构体A的起点为A内部最大成员的整数倍的地方</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> c;<span class=\"comment\">//32-39   0-39  40字节</span></span><br><span class=\"line\">&#125;Student2;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, <span class=\"keyword\">sizeof</span>(Student1));<span class=\"comment\">//输出结果为24</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, <span class=\"keyword\">sizeof</span>(Student2));<span class=\"comment\">//输出结果为40</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"结构体嵌套二维指针练习\"><a href=\"#结构体嵌套二维指针练习\" class=\"headerlink\" title=\"结构体嵌套二维指针练习\"></a>结构体嵌套二维指针练习</h2><p><img src=\"https://miao.su/images/2019/07/16/1205c38d33e627257b4b4.png\" alt=\"1205c38d33e627257b4b4.png\"></p>\n<p>结构体如下所示，模型为一个Teacher类型的二级指针，为它分配存放三个Teacher类型的一个指针类型用于存放数据，这三个Teacher类型的一级指针再为name和students分配空间，其中students为二级指针即表示有多个学生，因此使用以及分配的二维指针students继续分配4个一维指针存放学生姓名。该案例关键在于<strong>训练分配内存和释放内存的次序以及判定条件的书写</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* name;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>** students;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void printTeacher(struct Teacher** ts) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int <span class=\"built_in\">i</span> = <span class=\"number\">0</span>; <span class=\"built_in\">i</span> &lt; <span class=\"number\">3</span>; ++<span class=\"built_in\">i</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprintf(<span class=\"string\">\"%s\\n\"</span>, ts[<span class=\"built_in\">i</span>]-&gt;name);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (int <span class=\"built_in\">j</span> = <span class=\"number\">0</span>; <span class=\"built_in\">j</span> &lt; <span class=\"number\">5</span>; ++<span class=\"built_in\">j</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tprintf(<span class=\"string\">\"%s\\n\"</span>, ts[<span class=\"built_in\">i</span>]-&gt;students[<span class=\"built_in\">j</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分配内存</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int allocateSpace(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span></span>*** ts) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == ts)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span></span>** temp = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span></span>*) * <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttemp[i] = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span></span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttemp[i]-&gt;name = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"built_in\">char</span>) * <span class=\"number\">64</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsprintf(temp[i]-&gt;name, <span class=\"string\">\"Teacher_%d\"</span>, i + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttemp[i]-&gt;students = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"built_in\">char</span>*) * <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (int j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; ++j) &#123;</span><br><span class=\"line\">\t\t\ttemp[i]-&gt;students[j] = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"built_in\">char</span>) * <span class=\"number\">64</span>);</span><br><span class=\"line\">\t\t\tsprintf(temp[i]-&gt;students[j], <span class=\"string\">\"\\tStudent_%d\"</span>, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//指针的间接赋值</span></span><br><span class=\"line\">\t*ts = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>释放内存(关键)</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void freeSpace(struct Teacher** ts) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == ts)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int <span class=\"built_in\">i</span> = <span class=\"number\">0</span>; <span class=\"built_in\">i</span> &lt; <span class=\"number\">3</span>; ++<span class=\"built_in\">i</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (NULL == ts[<span class=\"built_in\">i</span>])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ts[<span class=\"built_in\">i</span>]-&gt;name != NULL) &#123;</span><br><span class=\"line\">\t\t\tfree(ts[<span class=\"built_in\">i</span>]-&gt;name);</span><br><span class=\"line\">\t\t\tts[<span class=\"built_in\">i</span>]-&gt;name = NULL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ts[<span class=\"built_in\">i</span>]-&gt;students != NULL) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (int <span class=\"built_in\">j</span> = <span class=\"number\">0</span>; <span class=\"built_in\">j</span> &lt; <span class=\"number\">5</span>; ++<span class=\"built_in\">j</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (NULL == ts[<span class=\"built_in\">i</span>]-&gt;students[<span class=\"built_in\">j</span>]) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tfree(ts[<span class=\"built_in\">i</span>]-&gt;students[<span class=\"built_in\">j</span>]);</span><br><span class=\"line\">\t\t\t\tts[<span class=\"built_in\">i</span>]-&gt;students[<span class=\"built_in\">j</span>] = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfree(ts[<span class=\"built_in\">i</span>]-&gt;students);</span><br><span class=\"line\">\t\t\tts[<span class=\"built_in\">i</span>]-&gt;students = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfree(ts[<span class=\"built_in\">i</span>]);</span><br><span class=\"line\">\t\tts[<span class=\"built_in\">i</span>] = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfree(ts);</span><br><span class=\"line\">\tts = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span>** <span class=\"title\">teacher</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tteacher = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//定义allocateSpace函数返回值类型为int的目的为接收不同情况的错误码</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, allocateSpace(&amp;teacher));</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintTeacher(teacher);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfreeSpace(teacher);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\ttest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"文件相关\"><a href=\"#文件相关\" class=\"headerlink\" title=\"文件相关\"></a>文件相关</h2><h3 id=\"文件缓冲区\"><a href=\"#文件缓冲区\" class=\"headerlink\" title=\"文件缓冲区\"></a>文件缓冲区</h3><p>如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以<strong>减少磁盘的读写次数</strong>，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大<strong>提高计算机的运行速度</strong>。</p>\n<p><img src=\"https://miao.su/images/2019/07/16/566664cfae.png\" alt=\"566664cfae.png\"></p>\n<hr>\n<h3 id=\"理解fopen与fclose与文件缓冲区的关系\"><a href=\"#理解fopen与fclose与文件缓冲区的关系\" class=\"headerlink\" title=\"理解fopen与fclose与文件缓冲区的关系\"></a>理解fopen与fclose与文件缓冲区的关系</h3><p>文件的打开操作表示将给用户指定的文件在内存<strong>分配一个FILE结构区</strong>，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。</p>\n<p><em>只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去</em>，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。<strong>文件的关闭也意味着释放了该文件的缓冲区</strong>。</p>\n<hr>\n<h3 id=\"有关文件指针和EOF的注意事项\"><a href=\"#有关文件指针和EOF的注意事项\" class=\"headerlink\" title=\"有关文件指针和EOF的注意事项\"></a>有关文件指针和EOF的注意事项</h3><p>关键在于文件指针何时指向EOF：只有当进行fgetc操作后文件指针后才会指向EOF，此使feof的返回值才为真，没进行fgetc操作前，文件指针仍未指向EOF。若不注意可能在读取时将EOF读取。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFILE* fp = fopen(<span class=\"string\">\"./test.txt\"</span>, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!feof(fp)) &#123;<span class=\"comment\">//注意：该写法将会读取出EOF，因为只有当进行了fgetc操作，文件指针才指向EOF，FILE 中的flag值才会改变，此刻的feof(fp)返回值才为真。</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tch = fgetc(fp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//加入判断可避免读取出EOF，进行完fgetc操作后文件指针已经指向了EOF</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (feof(fp))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, ch);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfclose(fp);</span><br><span class=\"line\">\tfp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的写法可以直接规避打印EOF的情况</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test02() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFILE* <span class=\"built_in\">fp</span> = fopen(<span class=\"string\">\"./test.txt\"</span>, <span class=\"string\">\"r\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tchar ch<span class=\"comment\">;</span></span><br><span class=\"line\">\twhile ((ch = fgetc(<span class=\"built_in\">fp</span>)) != EOF) &#123;</span><br><span class=\"line\">\t\tprintf(<span class=\"string\">\"%c\"</span>, ch)<span class=\"comment\">;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfclose(<span class=\"built_in\">fp</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"built_in\">fp</span> = NULL<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"配置文件读写代码\"><a href=\"#配置文件读写代码\" class=\"headerlink\" title=\"配置文件读写代码\"></a>配置文件读写代码</h3><p>思路如下: 有如下的配置文件，现需要按找指定格式读取其中有用的key值和value值，如ip:192.168.137.134，ip地址对应key值，192.168.137.134对应value值。将文件中所有有效的key，value值读取后为其分配对应的内存空间，并存放与结构体中，且之后可以通过给定一个key值返回对应的value值。</p>\n<p><img src=\"https://miao.su/images/2019/07/16/359febb5d031e91e0bb5f0abb4c31abca5ff.png\" alt=\"359febb5d031e91e0bb5f0abb4c31abca5ff.png\"></p>\n<p>以下是头文件，定义好函数原型以及存储key，value的结构体，实现过程有点复杂，但是更重要的是<strong>理解各个函数调用的过程以及参数的传递作用</strong>！！！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//防止头文件重复包含</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//为了C++能够调用C写的函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">\t<span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ConfigInfo</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> key[<span class=\"number\">64</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> value[<span class=\"number\">128</span>];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//获取文件有效行</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLines_ConfigFile</span><span class=\"params\">(FILE* file)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//加载配置文件</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loadFile_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filePath, <span class=\"keyword\">char</span>*** fileData, <span class=\"keyword\">int</span>* line)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//解析配置文件</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">parseFile_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>** fileData, <span class=\"keyword\">int</span> line, struct ConfigInfo** info)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//获得指定配置信息</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getInfo_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* key, struct ConfigInfo* info, <span class=\"keyword\">int</span> line)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//释放配置文件信息</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroyFile_ConfigFile</span><span class=\"params\">(struct ConfigInfo* info)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//判断当前行是否有效</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isValid_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>以下为功能实现文件</p>\n<p>获取文件有效行</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">include</span> <span class=\"string\">\"ConfigFile.h\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> getLines_ConfigFile(<span class=\"keyword\">FILE</span>* <span class=\"keyword\">file</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lines = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (fgets(buf, <span class=\"number\">1024</span>, <span class=\"keyword\">file</span>) != <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isValid_ConfigFile(buf)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmemset(buf, <span class=\"number\">0</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t++lines;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfseek(<span class=\"keyword\">file</span>, <span class=\"number\">0</span>, SEEK_SET);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lines;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加载配置文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loadFile_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filePath, <span class=\"keyword\">char</span>*** fileData, <span class=\"keyword\">int</span>* line)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFILE* file = fopen(filePath, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == file)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lines = getLines_ConfigFile(file);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>** temp = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>*) * lines);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (fgets(buf, <span class=\"number\">1024</span>, file) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isValid_ConfigFile(buf))<span class=\"comment\">//返回false时，则该行无效，读取下一行</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttemp[index] = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) * <span class=\"built_in\">strlen</span>(buf) + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(temp[index], buf);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t++index;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(buf, <span class=\"number\">0</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*fileData = temp;</span><br><span class=\"line\">\t*line = lines;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfclose(file);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解析配置文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">parseFile_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>** fileData, <span class=\"keyword\">int</span> line, struct ConfigInfo** info)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ConfigInfo</span>* <span class=\"title\">myInfo</span> = <span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">ConfigInfo</span>) * <span class=\"title\">line</span>);</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(myInfo, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(struct ConfigInfo) * line);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; line; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>* pos = <span class=\"built_in\">strchr</span>(fileData[i], <span class=\"string\">':'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">strncpy</span>(myInfo[i].key, fileData[i], pos - fileData[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fileData[i][<span class=\"built_in\">strlen</span>(fileData[i]) - <span class=\"number\">1</span>] == <span class=\"string\">'\\n'</span>) &#123;<span class=\"comment\">//等价于*(fileData[i] + strlen(fileData[i]) - 1);</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//此使代表该行结尾为换行</span></span><br><span class=\"line\">\t\t\tflag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"该行有换行\\n\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">strncpy</span>(myInfo[i].value, pos + <span class=\"number\">1</span>, <span class=\"built_in\">strlen</span>(pos + <span class=\"number\">1</span>) - flag);<span class=\"comment\">//将有换行的'\\n'不进行拷贝</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"key = %s  value = %s\\n\"</span>, myInfo[i].key, myInfo[i].value);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//释放文件信息</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; line; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fileData[i] != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(fileData[i]);</span><br><span class=\"line\">\t\t\tfileData[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*info = myInfo;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>获得指定配置信息</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> getInfo_ConfigFile(<span class=\"keyword\">const</span> <span class=\"built_in\">char</span>* <span class=\"built_in\">key</span>, struct ConfigInfo* info, <span class=\"built_in\">int</span> <span class=\"built_in\">line</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">line</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (strcmp(<span class=\"built_in\">key</span>, info[i].<span class=\"built_in\">key</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> info[i].value;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>释放配置文件信息</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroyFile_ConfigFile</span><span class=\"params\">(struct ConfigInfo* info)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == info)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(info);</span><br><span class=\"line\">\tinfo = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判断当前行是否有效</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isValid_ConfigFile</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* buf)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (buf[<span class=\"number\">0</span>] == <span class=\"string\">'#'</span> || buf[<span class=\"number\">0</span>] == <span class=\"string\">'\\n'</span> || (<span class=\"built_in\">strchr</span>(buf, <span class=\"string\">':'</span>) == <span class=\"literal\">NULL</span>))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下为测试功能函数以及主函数文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>** fileData = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lines = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ConfigInfo</span>* <span class=\"title\">myInfo</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tloadFile_ConfigFile(<span class=\"string\">\"./config.ini\"</span>, &amp;fileData, &amp;lines);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, lines);</span><br><span class=\"line\"></span><br><span class=\"line\">\tparseFile_ConfigFile(fileData, lines, &amp;myInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">\tdestroyFile_ConfigFile(myInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\ttest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS：多次想放弃，磕磕绊绊看着源码一行一行改错。。。对这种逻辑复杂的配置文件读写案例，code之前切记画图，切记画图，切记画图。不画图，debug时泪流满面。</p>"},{"title":"Holiday Note_05","date":"2019-07-17T09:26:45.000Z","_content":"\n# Holiday Note_05\n\n放假第五天，接触了**函数指针**和**回调函数**的概念以及用法。不是那么好理解，但是却是一个异常重要的知识点，视频中表示无论花多少时间精力去理解都是值得的。我也是把代码从不使用回调函数到使用并且以不同方式使用后，才逐渐理解了一些，其思想有点类似与多态，有利于代码的复用以及维护。使用回调函数编写好接口后，其他用户调取时只要注意接口的函数指针类型以及返回值类型，便可以根据自己的业务需求自定义函数内部逻辑了。\n\n然后又重新复习了下**链表**，因为上个寒假我的C还只有三脚猫功夫的时候硬嗑过，再加上这个学期上一些杂课的时候好好读了《数据结构与算法——C语言实现》，这次再实现链表的各种功能时，以前积攒了一堆搞不懂的问题一瞬间迎刃而解的爽快感着实难以形容，真的是大为舒畅。\n\n还有今天早上烧水泡茶的操作把自己迷到了，记在末尾，不过相信这种蠢事一辈子可能都忘不了的了。。。😂\n\n\n<!-- more -->\n\n---\n\n## 函数指针\n\n**一个函数在编译时被分配一个入口地址，这个地址就称为函数的指针，函数名代表函数的入口地址。**\n\n要记住，函数名只不过是一个函数的**入口地址**，和数组类型指针有些类似，都有**三种方式**进行定义函数指针。\n\n\n\n- 1、先定义函数类型\n~~~\ntypedef int(FUNC_TYPE)(int, char);\nFUNC_TYPE* pFunc = func;\n\t\npFunc(10, 'a');\n~~~\n\n- 2、定义函数指针类型\n~~~\ntypedef int(*FUNCPOINT_TYPE)(int, char);\nFUNCPOINT_TYPE funcPoint = func;\n\nfuncPoint(20, 'b');\n~~~\n\n- 3、直接定义函数指针变量\n~~~\nint(*FuncPoint)(int, char) = func;\n\nfuncPoint(30, 'c');\n~~~\n\n上述函数指针指向的函数原型\n~~~\nint func(int a, char b) {\n\tprintf(\"Hello World!\\n\");\n}\n~~~\n\n---\n\n## 回调函数\n\n**务必理解该思想，此案例代码一定要读懂。**\n\n以下案例具体可描述为：用户希望将指定的数据进行打印。\n\n因此有这样一个问题：每次给定的数据类型是不固定的，因此在进行数据打印时，无法将函数功能固定死，当然也绝不能将所有类型的数据打印方法分别都实现。因此引入函数回调这样一个思想，假设用户将会**给定怎样的数据我们还不清楚**，我们做的功能仅仅是做好接口，通过用户传递的几个关键参数，我们可以确定每一个数据的地址确定并传出，如果我们提前写好打印方法，那么很明显，若换了另外一种数据，这个函数便无法使用了。因此我们不负责打印。用户根据我们的接口的规则设计相应的函数实现打印功能。接口有一个重要的参数便是函数指针了，用户需要打印何种类型的数据，便编写该类数据的打印函数并将其作为参数传递至接口。这样，在调用我们的接口时，函数指针将会指向用户编写好对应的函数进行功能实现，完成了代码的简化以及复用，大大减少了维护的成本。 \n\n\n\n这是编写的**接口函数**，函数指针类型的形参一般使用万能指针类型。\n~~~\nvoid printAllArray(void* data, int elementSize, int len, void(*print)(void *)) {\n\n    //传递过来的第一个参数是一个数据数组，第二个参数是每个数据的大小，第三个是数据的个数，第四个是函数指针\n\tchar* start = (char*)data;//将数据转换为字符指针类型来将每一个数据地址求出\n\n\tfor (int i = 0; i < len; ++i) {\n\t\tchar* eleAddr = start + i * elementSize;\n\n\t\t//下列语句不能写死，传递过来的数据类型是不确定的，为了代码的复用，应当根据用户需求，使用回调函数\n\t\t//printf(\"%d\\n\", *((int*)eleAddr));\n\n\t\t//print为函数指针变量，此写法今后不用修改，因为不管用户需要打印何种类型，print都指向了用户自定义的打印函数，printAllArray函数目的是求出需要打印的每个元素的地址\n\t\tprint(eleAddr);\n\t\t\n\t}\n\n}\n~~~\n\n用户自定函数1，用于打印int类型数据\n~~~\nvoid myPrintInt(void * eleAdd) {\n\n\t//因为这是用户自己写的函数，因此清楚需要转换成指定类型将数据打印出。\n\tint* pAddress = (int*)eleAdd;\n\tprintf(\"%d\\n\", *pAddress);\n\n}\n~~~\n\n用户自定函数2，打印struct类型数据\n~~~\nstruct Person {\n\tchar name[64];\n\tint age;\n};\n\nvoid myPrintPerson(void* dataAddress) {\n\n\tstruct Person* pAddress = (struct Person*)dataAddress;\n\tprintf(\"name = %s age = %d\\n\", pAddress->name, pAddress->age);\n\n}\n~~~\n\n可见，接口编写完后，无论打印什么类型的数据，此使打印何种类型数据仅仅是取决用户如何传递的参数信息以及用户对应不同数据针对接口编写的打印函数了\n~~~\nvoid test() {\n\t\n\tint arr[] = { 1, 2, 3, 4, 5 };\n\n\tstruct Person persons[5] = {\n\t\t{\"aaa\",10},\n\t\t{\"bbb\",20},\n\t\t{\"ccc\",30},\n\t\t{\"ddd\",40},\n\t\t{\"eee\",50},\n\t};\n\n\t//调用接口打印整型数组类型\n\tprintAllArray(arr, sizeof(arr[0]), 5, myPrintInt);\n\n\tprintf(\"--------------------\\n\");\n\n\t//调用接口打印结构体类型\n\tprintAllArray(persons, sizeof(persons[0]), 5, myPrintPerson);\n\n}\n~~~\n\n---\n\n## 链表\n\n > 在《数据结构与算法——C语言描述中》，链表，队列，栈被称为是最简单和最基本的三种数据结构。\n\n### 什么是链表：\n\n-\t链表通过指针将一些列数据结点，连接成一个数据链。相对于数组，链表具有更好的**动态性**（*非顺序存储*）。\n-\t**数据域**用来存储数据，**指针域**用于建立与下一个结点的联系。\n-\t建立链表时无需预先知道数据总量的，可以随机的分配空间，可以高效的在链表中的任意位置实时插入或删除数据。\n-\t链表的**开销**，主要是访问顺序性和组织链(指针域)的空间损失。\n\n---\n\n### 数组与链表的区别：\n\n数组：一次性分配一块连续的存储区域。\n\n优点：\n\n- 随机访问元素效率高\n\n缺点：\n- 需要分配一块连续的存储区域（很大区域，有可能分配失败）     \n- **删除和插入某个元素效率低**\n\n---\n\n链表：无需一次性分配一块连续的存储区域，只需分配n块节点存储区域，通过指针建立关系。\n\n优点：\n- 不需要一块连续的存储区域\n-  **删除和插入某个元素效率高**\n\n缺点：\n- **随机访问**元素效率低\n\n\n---\n\n### 链表的实现\n\n#### 静态链表\n没什么好说的，就是直接定义好，基本不用。\n~~~\nstruct Node {\n\tint data;\n\t//指向下一个结点的指针\n\tstruct Node* next;\n};\n\n\nvoid test() {\n\n\tstruct Node node1 = {10, NULL };\n\tstruct Node node2 = {20, NULL };\n\tstruct Node node3 = {30, NULL };\n\tstruct Node node4 = {40, NULL };\n\tstruct Node node5 = {50, NULL };\n\tstruct Node node6 = {60, NULL };\n\n\tnode1.next = &node2;\n\tnode2.next = &node3;\n\tnode3.next = &node4;\n\tnode4.next = &node5;\n\tnode5.next = &node6;\n\n\t//辅助指针判断下一个结点是否为空\n\tstruct Node* pCurrent = &node1;\n\twhile (pCurrent != NULL) {\n\n\t\tprintf(\"%d\\n\", pCurrent->data);\n\n\t\tpCurrent = pCurrent->next;\n\t}\n\n}\n~~~\n\n#### 动态链表的实现\n\n定义头文件，使用最基本的链表结构实现六种基本功能：**初始化，插入，删除，便利，清空，销毁**。\n~~~\n#pragma once\n\n#include<stdlib.h>\n#include<stdio.h>\n#include<string.h>\n#include<stdbool.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n\n\t//定义结构体类型\n\tstruct LinkListNode {\n\t\tint data;\n\t\tstruct LinkListNode* next;\n\t};\n\n\n\t//初始化链表\n\tstruct LinkListNode* Init_LinkList();\n\n\t//在值为oldvalue的位置插入一个newvalue\n\tvoid InsertByValue_LinkList(struct LinkListNode* header, int oldValue, int newValue);\n\n\t//删除值为value的结点\n\tvoid RemoveByValue_LinkList(struct LinkListNode* header, int delValue);\n\n\t//遍历链表\n\tvoid Foreach_LinkList(struct LinkListNode* header);\n\n\t//销毁链表\n\tvoid Destroy_LinkList(struct LinkListNode* header);\n\n\t//清空链表\n\tvoid Clear_LinkList(struct LinkListNode* header);\n\n\n#ifdef __cplusplus\n}\n#endif // __cplusplus\n~~~\n\n实现文件，不要忘记引用头文件\n~~~\n#include \"LinkList.h\"\n~~~\n\n~~~\n//初始化链表\nstruct LinkListNode* Init_LinkList() {\n\n\t//为头结点分配内存\n\tstruct LinkListNode* header = malloc(sizeof(struct LinkListNode));\n\theader->data = 0;\n\theader->next = NULL;\n\n\t//定义辅助指针用于指向当前链表的尾部结点\n\tstruct LinkListNode* pRear = header;\n\n\tint val = 0;\n\n\twhile (true) {\n\n\t\tprintf(\"请输入需要插入的数据（输入0退出）\\n\");\n\t\tscanf(\"%d\", &val);\n\n\t\tif (val == 0)\n\t\t\tbreak;\n\n\t\tstruct LinkListNode* newNode = malloc(sizeof(struct LinkListNode));\n\t\tnewNode->data = val;\n\t\tnewNode->next = NULL;\n\n\t\tpRear->next = newNode;\n\t\tpRear = newNode;\n\n\t}\n\n\treturn header;\n\n}\n~~~\n其实链表的插入和删除结点操作十分相似，以下为示意图，就是定义两个指针一前一后记录目标元素的前驱结点和后继结点。\n![444fcf5f.png](https://miao.su/images/2019/07/17/444fcf5f.png)\n~~~\n//在值为oldvalue的位置插入一个newvalue\nvoid InsertByValue_LinkList(struct LinkListNode* header, int oldValue, int newValue) {\n\n\tif (NULL == header)\n\t\treturn;\n\n\t//两个辅助指针，一前一后用于定位\n\tstruct LinkListNode* prevPoint = header;\n\tstruct LinkListNode* currentPoint = prevPoint->next;\n\n\twhile (currentPoint != NULL) {\n\n\t\tif (currentPoint->data == oldValue)\n\t\t\tbreak;\n\n\t\tprevPoint = currentPoint;\n\t\tcurrentPoint = currentPoint->next;\n\n\t}\n\n\t//从while中跳出有两种情况，一种是currentPoint为NULL即未找到与oldValue，另一种是已经找到了\n\tif (currentPoint == NULL)\n\t\treturn;\n\n\tstruct LinkListNode* newNode = malloc(sizeof(struct LinkListNode));\n\t\n\tprevPoint->next = newNode;\n\tnewNode->next = currentPoint;\n\tnewNode->data = newValue;\n\n}\n~~~\n~~~\n//删除值为value的结点\nvoid RemoveByValue_LinkList(struct LinkListNode* header, int delValue) {\n\n\tif (NULL == header)\n\t\treturn;\n\n\tstruct LinkListNode* prePoint = header;\n\tstruct LinkListNode* currentPoint = header->next;\n\n\twhile (currentPoint != NULL) {\n\n\t\tif (currentPoint->data == delValue)\n\t\t\tbreak;\n\n\t\tprePoint = currentPoint;\n\t\tcurrentPoint = currentPoint->next;\n\n\t}\n\n\tif (NULL == currentPoint)\n\t\treturn;\n\n\t//重新建立删除结点的前驱结点和后继结点关系\n\tprePoint->next = currentPoint->next;\n\t//释放被删除节点的空间\n\tfree(currentPoint);\n\tcurrentPoint = NULL;\n\n}\n~~~\n~~~\n//遍历链表\nvoid Foreach_LinkList(struct LinkListNode* header) {\n\n\tif (NULL == header)\n\t\treturn;\n\n\tstruct LinkListNode* pCurrent = header->next;\n\n\twhile (pCurrent != NULL) {\n\n\t\tprintf(\"%d\\n\", pCurrent->data);\n\n\t\tpCurrent = pCurrent->next;\n\n\t}\n\n}\n~~~\n~~~\n//销毁链表，不保留头结点\nvoid Destroy_LinkList(struct LinkListNode* header) {\n\n\tif (NULL == header)\n\t\treturn;\n\n\t// 唯一与清空链表不同的操作，即一个从头开始释放，一个从头的下一个开始释放。\n\tstruct LinkListNode* currentPoint = header;\n\n\twhile (currentPoint != NULL) {\n\n\t\t//释放结点前，先用一个临时变量保存它的next结点地址\n\t\tstruct LinkListNode* tempPoint = currentPoint->next;\n\n\t\t//释放当前结点\n\t\tfree(currentPoint);\n\n\t\t//指向下一个结点\n\t\tcurrentPoint = tempPoint;\n\n\t}\n\n}\n~~~\n~~~\n//清空链表, 仅仅保留头结点\nvoid Clear_LinkList(struct LinkListNode* header) {\n\n\tif (NULL == header)\n\t\treturn;\n\n\tstruct LinkListNode* currentPoint = header->next;\n\n\twhile (currentPoint != NULL) {\n\n\t\t//释放结点前，先用一个临时变量保存它的next结点地址\n\t\tstruct LinkListNode* tempPoint = currentPoint->next;\n\n\t\t//释放当前结点\n\t\tfree(currentPoint);\n\n\t\t//指向下一个结点\n\t\tcurrentPoint = tempPoint;\n\n\t}\n\n\t//注意\n\theader = NULL;\n\n}\n~~~\n\n\nPS：实在搞不懂为什么整个寒假我就一直搁那死磕数据结构，头结点头指针，结构体嵌套指针根本搞不懂，还写了一寒假，哭了。为什么不先学基础💀\n\n早上起床后惯例去泡茶，把水壶放上底座然后回来看了几分钟电脑，觉得水烧开后，去厨房端回水壶，倒了些水进余了凉水的特百惠里允温水喝，然后再沏茶，把茶杯盖盖好。看了挺久电脑渴了，端起茶杯正准备惬意的来一口，一看，怎么颜色不是平时的褐色。。。茶叶怎么也没舒展。。。诶怎么杯子这么快就凉了。。。那一刻我才明白烧水没按开关的痛，而且允完我以为的“温水”后当时还喝过一口的，居然这也没反应过来！我是谁？我在哪？我在干嘛？\n\n\n\n\n\n\n\n","source":"_posts/2019-Holiday-Note-05.md","raw":"---\ntitle: Holiday Note_05\ndate: 2019-07-17 17:26:45\ncategories: C\ntags: [Note,C]\n---\n\n# Holiday Note_05\n\n放假第五天，接触了**函数指针**和**回调函数**的概念以及用法。不是那么好理解，但是却是一个异常重要的知识点，视频中表示无论花多少时间精力去理解都是值得的。我也是把代码从不使用回调函数到使用并且以不同方式使用后，才逐渐理解了一些，其思想有点类似与多态，有利于代码的复用以及维护。使用回调函数编写好接口后，其他用户调取时只要注意接口的函数指针类型以及返回值类型，便可以根据自己的业务需求自定义函数内部逻辑了。\n\n然后又重新复习了下**链表**，因为上个寒假我的C还只有三脚猫功夫的时候硬嗑过，再加上这个学期上一些杂课的时候好好读了《数据结构与算法——C语言实现》，这次再实现链表的各种功能时，以前积攒了一堆搞不懂的问题一瞬间迎刃而解的爽快感着实难以形容，真的是大为舒畅。\n\n还有今天早上烧水泡茶的操作把自己迷到了，记在末尾，不过相信这种蠢事一辈子可能都忘不了的了。。。😂\n\n\n<!-- more -->\n\n---\n\n## 函数指针\n\n**一个函数在编译时被分配一个入口地址，这个地址就称为函数的指针，函数名代表函数的入口地址。**\n\n要记住，函数名只不过是一个函数的**入口地址**，和数组类型指针有些类似，都有**三种方式**进行定义函数指针。\n\n\n\n- 1、先定义函数类型\n~~~\ntypedef int(FUNC_TYPE)(int, char);\nFUNC_TYPE* pFunc = func;\n\t\npFunc(10, 'a');\n~~~\n\n- 2、定义函数指针类型\n~~~\ntypedef int(*FUNCPOINT_TYPE)(int, char);\nFUNCPOINT_TYPE funcPoint = func;\n\nfuncPoint(20, 'b');\n~~~\n\n- 3、直接定义函数指针变量\n~~~\nint(*FuncPoint)(int, char) = func;\n\nfuncPoint(30, 'c');\n~~~\n\n上述函数指针指向的函数原型\n~~~\nint func(int a, char b) {\n\tprintf(\"Hello World!\\n\");\n}\n~~~\n\n---\n\n## 回调函数\n\n**务必理解该思想，此案例代码一定要读懂。**\n\n以下案例具体可描述为：用户希望将指定的数据进行打印。\n\n因此有这样一个问题：每次给定的数据类型是不固定的，因此在进行数据打印时，无法将函数功能固定死，当然也绝不能将所有类型的数据打印方法分别都实现。因此引入函数回调这样一个思想，假设用户将会**给定怎样的数据我们还不清楚**，我们做的功能仅仅是做好接口，通过用户传递的几个关键参数，我们可以确定每一个数据的地址确定并传出，如果我们提前写好打印方法，那么很明显，若换了另外一种数据，这个函数便无法使用了。因此我们不负责打印。用户根据我们的接口的规则设计相应的函数实现打印功能。接口有一个重要的参数便是函数指针了，用户需要打印何种类型的数据，便编写该类数据的打印函数并将其作为参数传递至接口。这样，在调用我们的接口时，函数指针将会指向用户编写好对应的函数进行功能实现，完成了代码的简化以及复用，大大减少了维护的成本。 \n\n\n\n这是编写的**接口函数**，函数指针类型的形参一般使用万能指针类型。\n~~~\nvoid printAllArray(void* data, int elementSize, int len, void(*print)(void *)) {\n\n    //传递过来的第一个参数是一个数据数组，第二个参数是每个数据的大小，第三个是数据的个数，第四个是函数指针\n\tchar* start = (char*)data;//将数据转换为字符指针类型来将每一个数据地址求出\n\n\tfor (int i = 0; i < len; ++i) {\n\t\tchar* eleAddr = start + i * elementSize;\n\n\t\t//下列语句不能写死，传递过来的数据类型是不确定的，为了代码的复用，应当根据用户需求，使用回调函数\n\t\t//printf(\"%d\\n\", *((int*)eleAddr));\n\n\t\t//print为函数指针变量，此写法今后不用修改，因为不管用户需要打印何种类型，print都指向了用户自定义的打印函数，printAllArray函数目的是求出需要打印的每个元素的地址\n\t\tprint(eleAddr);\n\t\t\n\t}\n\n}\n~~~\n\n用户自定函数1，用于打印int类型数据\n~~~\nvoid myPrintInt(void * eleAdd) {\n\n\t//因为这是用户自己写的函数，因此清楚需要转换成指定类型将数据打印出。\n\tint* pAddress = (int*)eleAdd;\n\tprintf(\"%d\\n\", *pAddress);\n\n}\n~~~\n\n用户自定函数2，打印struct类型数据\n~~~\nstruct Person {\n\tchar name[64];\n\tint age;\n};\n\nvoid myPrintPerson(void* dataAddress) {\n\n\tstruct Person* pAddress = (struct Person*)dataAddress;\n\tprintf(\"name = %s age = %d\\n\", pAddress->name, pAddress->age);\n\n}\n~~~\n\n可见，接口编写完后，无论打印什么类型的数据，此使打印何种类型数据仅仅是取决用户如何传递的参数信息以及用户对应不同数据针对接口编写的打印函数了\n~~~\nvoid test() {\n\t\n\tint arr[] = { 1, 2, 3, 4, 5 };\n\n\tstruct Person persons[5] = {\n\t\t{\"aaa\",10},\n\t\t{\"bbb\",20},\n\t\t{\"ccc\",30},\n\t\t{\"ddd\",40},\n\t\t{\"eee\",50},\n\t};\n\n\t//调用接口打印整型数组类型\n\tprintAllArray(arr, sizeof(arr[0]), 5, myPrintInt);\n\n\tprintf(\"--------------------\\n\");\n\n\t//调用接口打印结构体类型\n\tprintAllArray(persons, sizeof(persons[0]), 5, myPrintPerson);\n\n}\n~~~\n\n---\n\n## 链表\n\n > 在《数据结构与算法——C语言描述中》，链表，队列，栈被称为是最简单和最基本的三种数据结构。\n\n### 什么是链表：\n\n-\t链表通过指针将一些列数据结点，连接成一个数据链。相对于数组，链表具有更好的**动态性**（*非顺序存储*）。\n-\t**数据域**用来存储数据，**指针域**用于建立与下一个结点的联系。\n-\t建立链表时无需预先知道数据总量的，可以随机的分配空间，可以高效的在链表中的任意位置实时插入或删除数据。\n-\t链表的**开销**，主要是访问顺序性和组织链(指针域)的空间损失。\n\n---\n\n### 数组与链表的区别：\n\n数组：一次性分配一块连续的存储区域。\n\n优点：\n\n- 随机访问元素效率高\n\n缺点：\n- 需要分配一块连续的存储区域（很大区域，有可能分配失败）     \n- **删除和插入某个元素效率低**\n\n---\n\n链表：无需一次性分配一块连续的存储区域，只需分配n块节点存储区域，通过指针建立关系。\n\n优点：\n- 不需要一块连续的存储区域\n-  **删除和插入某个元素效率高**\n\n缺点：\n- **随机访问**元素效率低\n\n\n---\n\n### 链表的实现\n\n#### 静态链表\n没什么好说的，就是直接定义好，基本不用。\n~~~\nstruct Node {\n\tint data;\n\t//指向下一个结点的指针\n\tstruct Node* next;\n};\n\n\nvoid test() {\n\n\tstruct Node node1 = {10, NULL };\n\tstruct Node node2 = {20, NULL };\n\tstruct Node node3 = {30, NULL };\n\tstruct Node node4 = {40, NULL };\n\tstruct Node node5 = {50, NULL };\n\tstruct Node node6 = {60, NULL };\n\n\tnode1.next = &node2;\n\tnode2.next = &node3;\n\tnode3.next = &node4;\n\tnode4.next = &node5;\n\tnode5.next = &node6;\n\n\t//辅助指针判断下一个结点是否为空\n\tstruct Node* pCurrent = &node1;\n\twhile (pCurrent != NULL) {\n\n\t\tprintf(\"%d\\n\", pCurrent->data);\n\n\t\tpCurrent = pCurrent->next;\n\t}\n\n}\n~~~\n\n#### 动态链表的实现\n\n定义头文件，使用最基本的链表结构实现六种基本功能：**初始化，插入，删除，便利，清空，销毁**。\n~~~\n#pragma once\n\n#include<stdlib.h>\n#include<stdio.h>\n#include<string.h>\n#include<stdbool.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n\n\t//定义结构体类型\n\tstruct LinkListNode {\n\t\tint data;\n\t\tstruct LinkListNode* next;\n\t};\n\n\n\t//初始化链表\n\tstruct LinkListNode* Init_LinkList();\n\n\t//在值为oldvalue的位置插入一个newvalue\n\tvoid InsertByValue_LinkList(struct LinkListNode* header, int oldValue, int newValue);\n\n\t//删除值为value的结点\n\tvoid RemoveByValue_LinkList(struct LinkListNode* header, int delValue);\n\n\t//遍历链表\n\tvoid Foreach_LinkList(struct LinkListNode* header);\n\n\t//销毁链表\n\tvoid Destroy_LinkList(struct LinkListNode* header);\n\n\t//清空链表\n\tvoid Clear_LinkList(struct LinkListNode* header);\n\n\n#ifdef __cplusplus\n}\n#endif // __cplusplus\n~~~\n\n实现文件，不要忘记引用头文件\n~~~\n#include \"LinkList.h\"\n~~~\n\n~~~\n//初始化链表\nstruct LinkListNode* Init_LinkList() {\n\n\t//为头结点分配内存\n\tstruct LinkListNode* header = malloc(sizeof(struct LinkListNode));\n\theader->data = 0;\n\theader->next = NULL;\n\n\t//定义辅助指针用于指向当前链表的尾部结点\n\tstruct LinkListNode* pRear = header;\n\n\tint val = 0;\n\n\twhile (true) {\n\n\t\tprintf(\"请输入需要插入的数据（输入0退出）\\n\");\n\t\tscanf(\"%d\", &val);\n\n\t\tif (val == 0)\n\t\t\tbreak;\n\n\t\tstruct LinkListNode* newNode = malloc(sizeof(struct LinkListNode));\n\t\tnewNode->data = val;\n\t\tnewNode->next = NULL;\n\n\t\tpRear->next = newNode;\n\t\tpRear = newNode;\n\n\t}\n\n\treturn header;\n\n}\n~~~\n其实链表的插入和删除结点操作十分相似，以下为示意图，就是定义两个指针一前一后记录目标元素的前驱结点和后继结点。\n![444fcf5f.png](https://miao.su/images/2019/07/17/444fcf5f.png)\n~~~\n//在值为oldvalue的位置插入一个newvalue\nvoid InsertByValue_LinkList(struct LinkListNode* header, int oldValue, int newValue) {\n\n\tif (NULL == header)\n\t\treturn;\n\n\t//两个辅助指针，一前一后用于定位\n\tstruct LinkListNode* prevPoint = header;\n\tstruct LinkListNode* currentPoint = prevPoint->next;\n\n\twhile (currentPoint != NULL) {\n\n\t\tif (currentPoint->data == oldValue)\n\t\t\tbreak;\n\n\t\tprevPoint = currentPoint;\n\t\tcurrentPoint = currentPoint->next;\n\n\t}\n\n\t//从while中跳出有两种情况，一种是currentPoint为NULL即未找到与oldValue，另一种是已经找到了\n\tif (currentPoint == NULL)\n\t\treturn;\n\n\tstruct LinkListNode* newNode = malloc(sizeof(struct LinkListNode));\n\t\n\tprevPoint->next = newNode;\n\tnewNode->next = currentPoint;\n\tnewNode->data = newValue;\n\n}\n~~~\n~~~\n//删除值为value的结点\nvoid RemoveByValue_LinkList(struct LinkListNode* header, int delValue) {\n\n\tif (NULL == header)\n\t\treturn;\n\n\tstruct LinkListNode* prePoint = header;\n\tstruct LinkListNode* currentPoint = header->next;\n\n\twhile (currentPoint != NULL) {\n\n\t\tif (currentPoint->data == delValue)\n\t\t\tbreak;\n\n\t\tprePoint = currentPoint;\n\t\tcurrentPoint = currentPoint->next;\n\n\t}\n\n\tif (NULL == currentPoint)\n\t\treturn;\n\n\t//重新建立删除结点的前驱结点和后继结点关系\n\tprePoint->next = currentPoint->next;\n\t//释放被删除节点的空间\n\tfree(currentPoint);\n\tcurrentPoint = NULL;\n\n}\n~~~\n~~~\n//遍历链表\nvoid Foreach_LinkList(struct LinkListNode* header) {\n\n\tif (NULL == header)\n\t\treturn;\n\n\tstruct LinkListNode* pCurrent = header->next;\n\n\twhile (pCurrent != NULL) {\n\n\t\tprintf(\"%d\\n\", pCurrent->data);\n\n\t\tpCurrent = pCurrent->next;\n\n\t}\n\n}\n~~~\n~~~\n//销毁链表，不保留头结点\nvoid Destroy_LinkList(struct LinkListNode* header) {\n\n\tif (NULL == header)\n\t\treturn;\n\n\t// 唯一与清空链表不同的操作，即一个从头开始释放，一个从头的下一个开始释放。\n\tstruct LinkListNode* currentPoint = header;\n\n\twhile (currentPoint != NULL) {\n\n\t\t//释放结点前，先用一个临时变量保存它的next结点地址\n\t\tstruct LinkListNode* tempPoint = currentPoint->next;\n\n\t\t//释放当前结点\n\t\tfree(currentPoint);\n\n\t\t//指向下一个结点\n\t\tcurrentPoint = tempPoint;\n\n\t}\n\n}\n~~~\n~~~\n//清空链表, 仅仅保留头结点\nvoid Clear_LinkList(struct LinkListNode* header) {\n\n\tif (NULL == header)\n\t\treturn;\n\n\tstruct LinkListNode* currentPoint = header->next;\n\n\twhile (currentPoint != NULL) {\n\n\t\t//释放结点前，先用一个临时变量保存它的next结点地址\n\t\tstruct LinkListNode* tempPoint = currentPoint->next;\n\n\t\t//释放当前结点\n\t\tfree(currentPoint);\n\n\t\t//指向下一个结点\n\t\tcurrentPoint = tempPoint;\n\n\t}\n\n\t//注意\n\theader = NULL;\n\n}\n~~~\n\n\nPS：实在搞不懂为什么整个寒假我就一直搁那死磕数据结构，头结点头指针，结构体嵌套指针根本搞不懂，还写了一寒假，哭了。为什么不先学基础💀\n\n早上起床后惯例去泡茶，把水壶放上底座然后回来看了几分钟电脑，觉得水烧开后，去厨房端回水壶，倒了些水进余了凉水的特百惠里允温水喝，然后再沏茶，把茶杯盖盖好。看了挺久电脑渴了，端起茶杯正准备惬意的来一口，一看，怎么颜色不是平时的褐色。。。茶叶怎么也没舒展。。。诶怎么杯子这么快就凉了。。。那一刻我才明白烧水没按开关的痛，而且允完我以为的“温水”后当时还喝过一口的，居然这也没反应过来！我是谁？我在哪？我在干嘛？\n\n\n\n\n\n\n\n","slug":"2019-Holiday-Note-05","published":1,"updated":"2019-07-17T13:11:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihd000asmjbzofng2om","content":"<h1 id=\"Holiday-Note-05\"><a href=\"#Holiday-Note-05\" class=\"headerlink\" title=\"Holiday Note_05\"></a>Holiday Note_05</h1><p>放假第五天，接触了<strong>函数指针</strong>和<strong>回调函数</strong>的概念以及用法。不是那么好理解，但是却是一个异常重要的知识点，视频中表示无论花多少时间精力去理解都是值得的。我也是把代码从不使用回调函数到使用并且以不同方式使用后，才逐渐理解了一些，其思想有点类似与多态，有利于代码的复用以及维护。使用回调函数编写好接口后，其他用户调取时只要注意接口的函数指针类型以及返回值类型，便可以根据自己的业务需求自定义函数内部逻辑了。</p>\n<p>然后又重新复习了下<strong>链表</strong>，因为上个寒假我的C还只有三脚猫功夫的时候硬嗑过，再加上这个学期上一些杂课的时候好好读了《数据结构与算法——C语言实现》，这次再实现链表的各种功能时，以前积攒了一堆搞不懂的问题一瞬间迎刃而解的爽快感着实难以形容，真的是大为舒畅。</p>\n<p>还有今天早上烧水泡茶的操作把自己迷到了，记在末尾，不过相信这种蠢事一辈子可能都忘不了的了。。。😂</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h2><p><strong>一个函数在编译时被分配一个入口地址，这个地址就称为函数的指针，函数名代表函数的入口地址。</strong></p>\n<p>要记住，函数名只不过是一个函数的<strong>入口地址</strong>，和数组类型指针有些类似，都有<strong>三种方式</strong>进行定义函数指针。</p>\n<ul>\n<li><p>1、先定义函数类型</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef int(<span class=\"name\">FUNC_TYPE</span>)(<span class=\"name\">int</span>, char)<span class=\"comment\">;</span></span><br><span class=\"line\">FUNC_TYPE* pFunc = func<span class=\"comment\">;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">pFunc(<span class=\"number\">10</span>, 'a')<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2、定义函数指针类型</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef int(<span class=\"name\">*FUNCPOINT_TYPE</span>)(<span class=\"name\">int</span>, char)<span class=\"comment\">;</span></span><br><span class=\"line\">FUNCPOINT_TYPE funcPoint = func<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">funcPoint(<span class=\"number\">20</span>, 'b')<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3、直接定义函数指针变量</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int(<span class=\"name\">*FuncPoint</span>)(<span class=\"name\">int</span>, char) = func<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">funcPoint(<span class=\"number\">30</span>, 'c')<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>上述函数指针指向的函数原型</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">char</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h2><p><strong>务必理解该思想，此案例代码一定要读懂。</strong></p>\n<p>以下案例具体可描述为：用户希望将指定的数据进行打印。</p>\n<p>因此有这样一个问题：每次给定的数据类型是不固定的，因此在进行数据打印时，无法将函数功能固定死，当然也绝不能将所有类型的数据打印方法分别都实现。因此引入函数回调这样一个思想，假设用户将会<strong>给定怎样的数据我们还不清楚</strong>，我们做的功能仅仅是做好接口，通过用户传递的几个关键参数，我们可以确定每一个数据的地址确定并传出，如果我们提前写好打印方法，那么很明显，若换了另外一种数据，这个函数便无法使用了。因此我们不负责打印。用户根据我们的接口的规则设计相应的函数实现打印功能。接口有一个重要的参数便是函数指针了，用户需要打印何种类型的数据，便编写该类数据的打印函数并将其作为参数传递至接口。这样，在调用我们的接口时，函数指针将会指向用户编写好对应的函数进行功能实现，完成了代码的简化以及复用，大大减少了维护的成本。 </p>\n<p>这是编写的<strong>接口函数</strong>，函数指针类型的形参一般使用万能指针类型。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> printAllArray(<span class=\"keyword\">void</span>* data, <span class=\"keyword\">int</span> elementSize, <span class=\"keyword\">int</span> len, <span class=\"keyword\">void</span>(*<span class=\"built_in\">print</span>)(<span class=\"keyword\">void</span> *)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//传递过来的第一个参数是一个数据数组，第二个参数是每个数据的大小，第三个是数据的个数，第四个是函数指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* start = (<span class=\"keyword\">char</span>*)data;<span class=\"comment\">//将数据转换为字符指针类型来将每一个数据地址求出</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>* eleAddr = start + i * elementSize;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//下列语句不能写死，传递过来的数据类型是不确定的，为了代码的复用，应当根据用户需求，使用回调函数</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(\"%d\\n\", *((int*)eleAddr));</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//print为函数指针变量，此写法今后不用修改，因为不管用户需要打印何种类型，print都指向了用户自定义的打印函数，printAllArray函数目的是求出需要打印的每个元素的地址</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(eleAddr);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用户自定函数1，用于打印int类型数据</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintInt</span><span class=\"params\">(<span class=\"keyword\">void</span> * eleAdd)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//因为这是用户自己写的函数，因此清楚需要转换成指定类型将数据打印出。</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* pAddress = (<span class=\"keyword\">int</span>*)eleAdd;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, *pAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用户自定函数2，打印struct类型数据</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintPerson</span><span class=\"params\">(<span class=\"keyword\">void</span>* dataAddress)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>* <span class=\"title\">pAddress</span> = (<span class=\"title\">struct</span> <span class=\"title\">Person</span>*)<span class=\"title\">dataAddress</span>;</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"name = %s age = %d\\n\"</span>, pAddress-&gt;name, pAddress-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，接口编写完后，无论打印什么类型的数据，此使打印何种类型数据仅仅是取决用户如何传递的参数信息以及用户对应不同数据针对接口编写的打印函数了</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test() &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tint arr[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstruct Person persons[<span class=\"number\">5</span>] = &#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"aaa\"</span>,<span class=\"number\">10</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"bbb\"</span>,<span class=\"number\">20</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"ccc\"</span>,<span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"ddd\"</span>,<span class=\"number\">40</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"eee\"</span>,<span class=\"number\">50</span>&#125;,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//调用接口打印整型数组类型</span></span><br><span class=\"line\">\tprintAllArray(arr, sizeof(arr[<span class=\"number\">0</span>]), <span class=\"number\">5</span>, myPrintInt);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"--------------------<span class=\"subst\">\\n</span>\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//调用接口打印结构体类型</span></span><br><span class=\"line\">\tprintAllArray(persons, sizeof(persons[<span class=\"number\">0</span>]), <span class=\"number\">5</span>, myPrintPerson);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><blockquote>\n<p>在《数据结构与算法——C语言描述中》，链表，队列，栈被称为是最简单和最基本的三种数据结构。</p>\n</blockquote>\n<h3 id=\"什么是链表：\"><a href=\"#什么是链表：\" class=\"headerlink\" title=\"什么是链表：\"></a>什么是链表：</h3><ul>\n<li>链表通过指针将一些列数据结点，连接成一个数据链。相对于数组，链表具有更好的<strong>动态性</strong>（<em>非顺序存储</em>）。</li>\n<li><strong>数据域</strong>用来存储数据，<strong>指针域</strong>用于建立与下一个结点的联系。</li>\n<li>建立链表时无需预先知道数据总量的，可以随机的分配空间，可以高效的在链表中的任意位置实时插入或删除数据。</li>\n<li>链表的<strong>开销</strong>，主要是访问顺序性和组织链(指针域)的空间损失。</li>\n</ul>\n<hr>\n<h3 id=\"数组与链表的区别：\"><a href=\"#数组与链表的区别：\" class=\"headerlink\" title=\"数组与链表的区别：\"></a>数组与链表的区别：</h3><p>数组：一次性分配一块连续的存储区域。</p>\n<p>优点：</p>\n<ul>\n<li>随机访问元素效率高</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>需要分配一块连续的存储区域（很大区域，有可能分配失败）     </li>\n<li><strong>删除和插入某个元素效率低</strong></li>\n</ul>\n<hr>\n<p>链表：无需一次性分配一块连续的存储区域，只需分配n块节点存储区域，通过指针建立关系。</p>\n<p>优点：</p>\n<ul>\n<li>不需要一块连续的存储区域</li>\n<li><strong>删除和插入某个元素效率高</strong></li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><strong>随机访问</strong>元素效率低</li>\n</ul>\n<hr>\n<h3 id=\"链表的实现\"><a href=\"#链表的实现\" class=\"headerlink\" title=\"链表的实现\"></a>链表的实现</h3><h4 id=\"静态链表\"><a href=\"#静态链表\" class=\"headerlink\" title=\"静态链表\"></a>静态链表</h4><p>没什么好说的，就是直接定义好，基本不用。</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct <span class=\"keyword\">Node</span> <span class=\"title\">&#123;</span></span><br><span class=\"line\"><span class=\"title\">\tint</span> data;</span><br><span class=\"line\">\t//指向下一个结点的指针</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span><span class=\"title\">* next</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span> <span class=\"title\">node1</span> = &#123;<span class=\"number\">10</span>, NULL &#125;;</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span> <span class=\"title\">node2</span> = &#123;<span class=\"number\">20</span>, NULL &#125;;</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span> <span class=\"title\">node3</span> = &#123;<span class=\"number\">30</span>, NULL &#125;;</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span> <span class=\"title\">node4</span> = &#123;<span class=\"number\">40</span>, NULL &#125;;</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span> <span class=\"title\">node5</span> = &#123;<span class=\"number\">50</span>, NULL &#125;;</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span> <span class=\"title\">node6</span> = &#123;<span class=\"number\">60</span>, NULL &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode1.next = &amp;node2;</span><br><span class=\"line\">\tnode2.next = &amp;node3;</span><br><span class=\"line\">\tnode3.next = &amp;node4;</span><br><span class=\"line\">\tnode4.next = &amp;node5;</span><br><span class=\"line\">\tnode5.next = &amp;node6;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//辅助指针判断下一个结点是否为空</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span><span class=\"title\">* pCurrent</span> = &amp;node1;</span><br><span class=\"line\">\twhile (pCurrent != NULL) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprintf(<span class=\"string\">\"%d\\n\"</span>, pCurrent-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpCurrent = pCurrent-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"动态链表的实现\"><a href=\"#动态链表的实现\" class=\"headerlink\" title=\"动态链表的实现\"></a>动态链表的实现</h4><p>定义头文件，使用最基本的链表结构实现六种基本功能：<strong>初始化，插入，删除，便利，清空，销毁</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// __cplusplus</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//定义结构体类型</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> data;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化链表</span></span><br><span class=\"line\">\t<span class=\"function\">struct LinkListNode* <span class=\"title\">Init_LinkList</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//在值为oldvalue的位置插入一个newvalue</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertByValue_LinkList</span><span class=\"params\">(struct LinkListNode* header, <span class=\"keyword\">int</span> oldValue, <span class=\"keyword\">int</span> newValue)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//删除值为value的结点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">RemoveByValue_LinkList</span><span class=\"params\">(struct LinkListNode* header, <span class=\"keyword\">int</span> delValue)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//遍历链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foreach_LinkList</span><span class=\"params\">(struct LinkListNode* header)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//销毁链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy_LinkList</span><span class=\"params\">(struct LinkListNode* header)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//清空链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Clear_LinkList</span><span class=\"params\">(struct LinkListNode* header)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// __cplusplus</span></span></span><br></pre></td></tr></table></figure>\n\n<p>实现文件，不要忘记引用头文件</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"string\">\"LinkList.h\"</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化链表</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* Init_LinkList() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//为头结点分配内存</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* header = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>));</span><br><span class=\"line\">\theader-&gt;data = <span class=\"number\">0</span>;</span><br><span class=\"line\">\theader-&gt;next = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//定义辅助指针用于指向当前链表的尾部结点</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* pRear = header;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint val = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprintf(<span class=\"string\">\"请输入需要插入的数据（输入0退出）\\n\"</span>);</span><br><span class=\"line\">\t\tscanf(<span class=\"string\">\"%d\"</span>, &amp;val);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (val == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* newNode = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>));</span><br><span class=\"line\">\t\tnewNode-&gt;data = val;</span><br><span class=\"line\">\t\tnewNode-&gt;next = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpRear-&gt;next = newNode;</span><br><span class=\"line\">\t\tpRear = newNode;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> header;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实链表的插入和删除结点操作十分相似，以下为示意图，就是定义两个指针一前一后记录目标元素的前驱结点和后继结点。<br><img src=\"https://miao.su/images/2019/07/17/444fcf5f.png\" alt=\"444fcf5f.png\"></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在值为oldvalue的位置插入一个newvalue</span></span><br><span class=\"line\">void InsertByValue_LinkList(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* header, int oldValue, int newValue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == header)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//两个辅助指针，一前一后用于定位</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* prevPoint = header;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* currentPoint = prevPoint-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (currentPoint != NULL) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (currentPoint-&gt;data == oldValue)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprevPoint = currentPoint;</span><br><span class=\"line\">\t\tcurrentPoint = currentPoint-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//从while中跳出有两种情况，一种是currentPoint为NULL即未找到与oldValue，另一种是已经找到了</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (currentPoint == NULL)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* newNode = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprevPoint-&gt;next = newNode;</span><br><span class=\"line\">\tnewNode-&gt;next = currentPoint;</span><br><span class=\"line\">\tnewNode-&gt;data = newValue;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除值为value的结点</span></span><br><span class=\"line\">void <span class=\"built_in\">RemoveByValue_LinkList</span>(struct LinkListNode* <span class=\"built_in\">header</span>, int delValue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == <span class=\"built_in\">header</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* prePoint = <span class=\"built_in\">header</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* currentPoint = <span class=\"built_in\">header</span>-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (currentPoint != <span class=\"built_in\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (currentPoint-&gt;data == delValue)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprePoint = currentPoint;</span><br><span class=\"line\">\t\tcurrentPoint = currentPoint-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == currentPoint)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//重新建立删除结点的前驱结点和后继结点关系</span></span><br><span class=\"line\">\tprePoint-&gt;next = currentPoint-&gt;next;</span><br><span class=\"line\">\t<span class=\"comment\">//释放被删除节点的空间</span></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(currentPoint);</span><br><span class=\"line\">\tcurrentPoint = <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//遍历链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foreach_LinkList</span><span class=\"params\">(struct LinkListNode* header)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == header)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span>* <span class=\"title\">pCurrent</span> = <span class=\"title\">header</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pCurrent != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, pCurrent-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpCurrent = pCurrent-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//销毁链表，不保留头结点</span></span><br><span class=\"line\">void <span class=\"built_in\">Destroy_LinkList</span>(struct LinkListNode* <span class=\"built_in\">header</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == <span class=\"built_in\">header</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 唯一与清空链表不同的操作，即一个从头开始释放，一个从头的下一个开始释放。</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* currentPoint = <span class=\"built_in\">header</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (currentPoint != <span class=\"built_in\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//释放结点前，先用一个临时变量保存它的next结点地址</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* tempPoint = currentPoint-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//释放当前结点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(currentPoint);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//指向下一个结点</span></span><br><span class=\"line\">\t\tcurrentPoint = tempPoint;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//清空链表, 仅仅保留头结点</span></span><br><span class=\"line\">void <span class=\"built_in\">Clear_LinkList</span>(struct LinkListNode* <span class=\"built_in\">header</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == <span class=\"built_in\">header</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* currentPoint = <span class=\"built_in\">header</span>-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (currentPoint != <span class=\"built_in\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//释放结点前，先用一个临时变量保存它的next结点地址</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* tempPoint = currentPoint-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//释放当前结点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(currentPoint);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//指向下一个结点</span></span><br><span class=\"line\">\t\tcurrentPoint = tempPoint;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//注意</span></span><br><span class=\"line\">\theader = <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS：实在搞不懂为什么整个寒假我就一直搁那死磕数据结构，头结点头指针，结构体嵌套指针根本搞不懂，还写了一寒假，哭了。为什么不先学基础💀</p>\n<p>早上起床后惯例去泡茶，把水壶放上底座然后回来看了几分钟电脑，觉得水烧开后，去厨房端回水壶，倒了些水进余了凉水的特百惠里允温水喝，然后再沏茶，把茶杯盖盖好。看了挺久电脑渴了，端起茶杯正准备惬意的来一口，一看，怎么颜色不是平时的褐色。。。茶叶怎么也没舒展。。。诶怎么杯子这么快就凉了。。。那一刻我才明白烧水没按开关的痛，而且允完我以为的“温水”后当时还喝过一口的，居然这也没反应过来！我是谁？我在哪？我在干嘛？</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-05\"><a href=\"#Holiday-Note-05\" class=\"headerlink\" title=\"Holiday Note_05\"></a>Holiday Note_05</h1><p>放假第五天，接触了<strong>函数指针</strong>和<strong>回调函数</strong>的概念以及用法。不是那么好理解，但是却是一个异常重要的知识点，视频中表示无论花多少时间精力去理解都是值得的。我也是把代码从不使用回调函数到使用并且以不同方式使用后，才逐渐理解了一些，其思想有点类似与多态，有利于代码的复用以及维护。使用回调函数编写好接口后，其他用户调取时只要注意接口的函数指针类型以及返回值类型，便可以根据自己的业务需求自定义函数内部逻辑了。</p>\n<p>然后又重新复习了下<strong>链表</strong>，因为上个寒假我的C还只有三脚猫功夫的时候硬嗑过，再加上这个学期上一些杂课的时候好好读了《数据结构与算法——C语言实现》，这次再实现链表的各种功能时，以前积攒了一堆搞不懂的问题一瞬间迎刃而解的爽快感着实难以形容，真的是大为舒畅。</p>\n<p>还有今天早上烧水泡茶的操作把自己迷到了，记在末尾，不过相信这种蠢事一辈子可能都忘不了的了。。。😂</p>","more":"<hr>\n<h2 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h2><p><strong>一个函数在编译时被分配一个入口地址，这个地址就称为函数的指针，函数名代表函数的入口地址。</strong></p>\n<p>要记住，函数名只不过是一个函数的<strong>入口地址</strong>，和数组类型指针有些类似，都有<strong>三种方式</strong>进行定义函数指针。</p>\n<ul>\n<li><p>1、先定义函数类型</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef int(<span class=\"name\">FUNC_TYPE</span>)(<span class=\"name\">int</span>, char)<span class=\"comment\">;</span></span><br><span class=\"line\">FUNC_TYPE* pFunc = func<span class=\"comment\">;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">pFunc(<span class=\"number\">10</span>, 'a')<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2、定义函数指针类型</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef int(<span class=\"name\">*FUNCPOINT_TYPE</span>)(<span class=\"name\">int</span>, char)<span class=\"comment\">;</span></span><br><span class=\"line\">FUNCPOINT_TYPE funcPoint = func<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">funcPoint(<span class=\"number\">20</span>, 'b')<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3、直接定义函数指针变量</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int(<span class=\"name\">*FuncPoint</span>)(<span class=\"name\">int</span>, char) = func<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">funcPoint(<span class=\"number\">30</span>, 'c')<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>上述函数指针指向的函数原型</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">char</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h2><p><strong>务必理解该思想，此案例代码一定要读懂。</strong></p>\n<p>以下案例具体可描述为：用户希望将指定的数据进行打印。</p>\n<p>因此有这样一个问题：每次给定的数据类型是不固定的，因此在进行数据打印时，无法将函数功能固定死，当然也绝不能将所有类型的数据打印方法分别都实现。因此引入函数回调这样一个思想，假设用户将会<strong>给定怎样的数据我们还不清楚</strong>，我们做的功能仅仅是做好接口，通过用户传递的几个关键参数，我们可以确定每一个数据的地址确定并传出，如果我们提前写好打印方法，那么很明显，若换了另外一种数据，这个函数便无法使用了。因此我们不负责打印。用户根据我们的接口的规则设计相应的函数实现打印功能。接口有一个重要的参数便是函数指针了，用户需要打印何种类型的数据，便编写该类数据的打印函数并将其作为参数传递至接口。这样，在调用我们的接口时，函数指针将会指向用户编写好对应的函数进行功能实现，完成了代码的简化以及复用，大大减少了维护的成本。 </p>\n<p>这是编写的<strong>接口函数</strong>，函数指针类型的形参一般使用万能指针类型。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> printAllArray(<span class=\"keyword\">void</span>* data, <span class=\"keyword\">int</span> elementSize, <span class=\"keyword\">int</span> len, <span class=\"keyword\">void</span>(*<span class=\"built_in\">print</span>)(<span class=\"keyword\">void</span> *)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//传递过来的第一个参数是一个数据数组，第二个参数是每个数据的大小，第三个是数据的个数，第四个是函数指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* start = (<span class=\"keyword\">char</span>*)data;<span class=\"comment\">//将数据转换为字符指针类型来将每一个数据地址求出</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>* eleAddr = start + i * elementSize;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//下列语句不能写死，传递过来的数据类型是不确定的，为了代码的复用，应当根据用户需求，使用回调函数</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(\"%d\\n\", *((int*)eleAddr));</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//print为函数指针变量，此写法今后不用修改，因为不管用户需要打印何种类型，print都指向了用户自定义的打印函数，printAllArray函数目的是求出需要打印的每个元素的地址</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(eleAddr);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用户自定函数1，用于打印int类型数据</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintInt</span><span class=\"params\">(<span class=\"keyword\">void</span> * eleAdd)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//因为这是用户自己写的函数，因此清楚需要转换成指定类型将数据打印出。</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* pAddress = (<span class=\"keyword\">int</span>*)eleAdd;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, *pAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用户自定函数2，打印struct类型数据</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintPerson</span><span class=\"params\">(<span class=\"keyword\">void</span>* dataAddress)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>* <span class=\"title\">pAddress</span> = (<span class=\"title\">struct</span> <span class=\"title\">Person</span>*)<span class=\"title\">dataAddress</span>;</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"name = %s age = %d\\n\"</span>, pAddress-&gt;name, pAddress-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，接口编写完后，无论打印什么类型的数据，此使打印何种类型数据仅仅是取决用户如何传递的参数信息以及用户对应不同数据针对接口编写的打印函数了</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test() &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tint arr[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstruct Person persons[<span class=\"number\">5</span>] = &#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"aaa\"</span>,<span class=\"number\">10</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"bbb\"</span>,<span class=\"number\">20</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"ccc\"</span>,<span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"ddd\"</span>,<span class=\"number\">40</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"eee\"</span>,<span class=\"number\">50</span>&#125;,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//调用接口打印整型数组类型</span></span><br><span class=\"line\">\tprintAllArray(arr, sizeof(arr[<span class=\"number\">0</span>]), <span class=\"number\">5</span>, myPrintInt);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"--------------------<span class=\"subst\">\\n</span>\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//调用接口打印结构体类型</span></span><br><span class=\"line\">\tprintAllArray(persons, sizeof(persons[<span class=\"number\">0</span>]), <span class=\"number\">5</span>, myPrintPerson);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><blockquote>\n<p>在《数据结构与算法——C语言描述中》，链表，队列，栈被称为是最简单和最基本的三种数据结构。</p>\n</blockquote>\n<h3 id=\"什么是链表：\"><a href=\"#什么是链表：\" class=\"headerlink\" title=\"什么是链表：\"></a>什么是链表：</h3><ul>\n<li>链表通过指针将一些列数据结点，连接成一个数据链。相对于数组，链表具有更好的<strong>动态性</strong>（<em>非顺序存储</em>）。</li>\n<li><strong>数据域</strong>用来存储数据，<strong>指针域</strong>用于建立与下一个结点的联系。</li>\n<li>建立链表时无需预先知道数据总量的，可以随机的分配空间，可以高效的在链表中的任意位置实时插入或删除数据。</li>\n<li>链表的<strong>开销</strong>，主要是访问顺序性和组织链(指针域)的空间损失。</li>\n</ul>\n<hr>\n<h3 id=\"数组与链表的区别：\"><a href=\"#数组与链表的区别：\" class=\"headerlink\" title=\"数组与链表的区别：\"></a>数组与链表的区别：</h3><p>数组：一次性分配一块连续的存储区域。</p>\n<p>优点：</p>\n<ul>\n<li>随机访问元素效率高</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>需要分配一块连续的存储区域（很大区域，有可能分配失败）     </li>\n<li><strong>删除和插入某个元素效率低</strong></li>\n</ul>\n<hr>\n<p>链表：无需一次性分配一块连续的存储区域，只需分配n块节点存储区域，通过指针建立关系。</p>\n<p>优点：</p>\n<ul>\n<li>不需要一块连续的存储区域</li>\n<li><strong>删除和插入某个元素效率高</strong></li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><strong>随机访问</strong>元素效率低</li>\n</ul>\n<hr>\n<h3 id=\"链表的实现\"><a href=\"#链表的实现\" class=\"headerlink\" title=\"链表的实现\"></a>链表的实现</h3><h4 id=\"静态链表\"><a href=\"#静态链表\" class=\"headerlink\" title=\"静态链表\"></a>静态链表</h4><p>没什么好说的，就是直接定义好，基本不用。</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct <span class=\"keyword\">Node</span> <span class=\"title\">&#123;</span></span><br><span class=\"line\"><span class=\"title\">\tint</span> data;</span><br><span class=\"line\">\t//指向下一个结点的指针</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span><span class=\"title\">* next</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span> <span class=\"title\">node1</span> = &#123;<span class=\"number\">10</span>, NULL &#125;;</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span> <span class=\"title\">node2</span> = &#123;<span class=\"number\">20</span>, NULL &#125;;</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span> <span class=\"title\">node3</span> = &#123;<span class=\"number\">30</span>, NULL &#125;;</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span> <span class=\"title\">node4</span> = &#123;<span class=\"number\">40</span>, NULL &#125;;</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span> <span class=\"title\">node5</span> = &#123;<span class=\"number\">50</span>, NULL &#125;;</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span> <span class=\"title\">node6</span> = &#123;<span class=\"number\">60</span>, NULL &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode1.next = &amp;node2;</span><br><span class=\"line\">\tnode2.next = &amp;node3;</span><br><span class=\"line\">\tnode3.next = &amp;node4;</span><br><span class=\"line\">\tnode4.next = &amp;node5;</span><br><span class=\"line\">\tnode5.next = &amp;node6;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//辅助指针判断下一个结点是否为空</span><br><span class=\"line\">\tstruct <span class=\"keyword\">Node</span><span class=\"title\">* pCurrent</span> = &amp;node1;</span><br><span class=\"line\">\twhile (pCurrent != NULL) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprintf(<span class=\"string\">\"%d\\n\"</span>, pCurrent-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpCurrent = pCurrent-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"动态链表的实现\"><a href=\"#动态链表的实现\" class=\"headerlink\" title=\"动态链表的实现\"></a>动态链表的实现</h4><p>定义头文件，使用最基本的链表结构实现六种基本功能：<strong>初始化，插入，删除，便利，清空，销毁</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// __cplusplus</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//定义结构体类型</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> data;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化链表</span></span><br><span class=\"line\">\t<span class=\"function\">struct LinkListNode* <span class=\"title\">Init_LinkList</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//在值为oldvalue的位置插入一个newvalue</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertByValue_LinkList</span><span class=\"params\">(struct LinkListNode* header, <span class=\"keyword\">int</span> oldValue, <span class=\"keyword\">int</span> newValue)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//删除值为value的结点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">RemoveByValue_LinkList</span><span class=\"params\">(struct LinkListNode* header, <span class=\"keyword\">int</span> delValue)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//遍历链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foreach_LinkList</span><span class=\"params\">(struct LinkListNode* header)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//销毁链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy_LinkList</span><span class=\"params\">(struct LinkListNode* header)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//清空链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Clear_LinkList</span><span class=\"params\">(struct LinkListNode* header)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// __cplusplus</span></span></span><br></pre></td></tr></table></figure>\n\n<p>实现文件，不要忘记引用头文件</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"string\">\"LinkList.h\"</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化链表</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* Init_LinkList() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//为头结点分配内存</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* header = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>));</span><br><span class=\"line\">\theader-&gt;data = <span class=\"number\">0</span>;</span><br><span class=\"line\">\theader-&gt;next = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//定义辅助指针用于指向当前链表的尾部结点</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* pRear = header;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint val = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprintf(<span class=\"string\">\"请输入需要插入的数据（输入0退出）\\n\"</span>);</span><br><span class=\"line\">\t\tscanf(<span class=\"string\">\"%d\"</span>, &amp;val);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (val == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* newNode = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>));</span><br><span class=\"line\">\t\tnewNode-&gt;data = val;</span><br><span class=\"line\">\t\tnewNode-&gt;next = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpRear-&gt;next = newNode;</span><br><span class=\"line\">\t\tpRear = newNode;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> header;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实链表的插入和删除结点操作十分相似，以下为示意图，就是定义两个指针一前一后记录目标元素的前驱结点和后继结点。<br><img src=\"https://miao.su/images/2019/07/17/444fcf5f.png\" alt=\"444fcf5f.png\"></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在值为oldvalue的位置插入一个newvalue</span></span><br><span class=\"line\">void InsertByValue_LinkList(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* header, int oldValue, int newValue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == header)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//两个辅助指针，一前一后用于定位</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* prevPoint = header;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* currentPoint = prevPoint-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (currentPoint != NULL) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (currentPoint-&gt;data == oldValue)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprevPoint = currentPoint;</span><br><span class=\"line\">\t\tcurrentPoint = currentPoint-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//从while中跳出有两种情况，一种是currentPoint为NULL即未找到与oldValue，另一种是已经找到了</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (currentPoint == NULL)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>* newNode = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span></span>));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprevPoint-&gt;next = newNode;</span><br><span class=\"line\">\tnewNode-&gt;next = currentPoint;</span><br><span class=\"line\">\tnewNode-&gt;data = newValue;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除值为value的结点</span></span><br><span class=\"line\">void <span class=\"built_in\">RemoveByValue_LinkList</span>(struct LinkListNode* <span class=\"built_in\">header</span>, int delValue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == <span class=\"built_in\">header</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* prePoint = <span class=\"built_in\">header</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* currentPoint = <span class=\"built_in\">header</span>-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (currentPoint != <span class=\"built_in\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (currentPoint-&gt;data == delValue)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprePoint = currentPoint;</span><br><span class=\"line\">\t\tcurrentPoint = currentPoint-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == currentPoint)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//重新建立删除结点的前驱结点和后继结点关系</span></span><br><span class=\"line\">\tprePoint-&gt;next = currentPoint-&gt;next;</span><br><span class=\"line\">\t<span class=\"comment\">//释放被删除节点的空间</span></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(currentPoint);</span><br><span class=\"line\">\tcurrentPoint = <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//遍历链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foreach_LinkList</span><span class=\"params\">(struct LinkListNode* header)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == header)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkListNode</span>* <span class=\"title\">pCurrent</span> = <span class=\"title\">header</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pCurrent != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, pCurrent-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpCurrent = pCurrent-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//销毁链表，不保留头结点</span></span><br><span class=\"line\">void <span class=\"built_in\">Destroy_LinkList</span>(struct LinkListNode* <span class=\"built_in\">header</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == <span class=\"built_in\">header</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 唯一与清空链表不同的操作，即一个从头开始释放，一个从头的下一个开始释放。</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* currentPoint = <span class=\"built_in\">header</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (currentPoint != <span class=\"built_in\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//释放结点前，先用一个临时变量保存它的next结点地址</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* tempPoint = currentPoint-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//释放当前结点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(currentPoint);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//指向下一个结点</span></span><br><span class=\"line\">\t\tcurrentPoint = tempPoint;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//清空链表, 仅仅保留头结点</span></span><br><span class=\"line\">void <span class=\"built_in\">Clear_LinkList</span>(struct LinkListNode* <span class=\"built_in\">header</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == <span class=\"built_in\">header</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* currentPoint = <span class=\"built_in\">header</span>-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (currentPoint != <span class=\"built_in\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//释放结点前，先用一个临时变量保存它的next结点地址</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* tempPoint = currentPoint-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//释放当前结点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(currentPoint);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//指向下一个结点</span></span><br><span class=\"line\">\t\tcurrentPoint = tempPoint;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//注意</span></span><br><span class=\"line\">\theader = <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS：实在搞不懂为什么整个寒假我就一直搁那死磕数据结构，头结点头指针，结构体嵌套指针根本搞不懂，还写了一寒假，哭了。为什么不先学基础💀</p>\n<p>早上起床后惯例去泡茶，把水壶放上底座然后回来看了几分钟电脑，觉得水烧开后，去厨房端回水壶，倒了些水进余了凉水的特百惠里允温水喝，然后再沏茶，把茶杯盖盖好。看了挺久电脑渴了，端起茶杯正准备惬意的来一口，一看，怎么颜色不是平时的褐色。。。茶叶怎么也没舒展。。。诶怎么杯子这么快就凉了。。。那一刻我才明白烧水没按开关的痛，而且允完我以为的“温水”后当时还喝过一口的，居然这也没反应过来！我是谁？我在哪？我在干嘛？</p>"},{"title":"Holiday Note_03","date":"2019-07-15T09:06:15.000Z","_content":"\n# Holiday Note_03\n\n放假第三天。今天学习的主要内容是：1、**位运算**(感觉目前只有位异或和移位运算符挺实用的还能玩个骚操作，按位取反，位与，位或这些改变二进制位的运算初次接触还是挺晕的)。2、**数组的深入学习**(记住一句话，无论是几维数组，在除了sizeof和&这两种情况，数组名表示的是指向该数组第一个元素的指针，难点是理解数组类型指针解引用为指向数组首元素指针这一操作逻辑)。3、**结构体的深入学习**(重点理解结构体赋值的深拷贝，浅拷贝的内存模型，以及结构体嵌套指针)。\n对了，《C和指针》提到了两句话：\n> 源代码的可读性几乎总是比程序的运行时效率更为重要。\n> \n> 只要有可能，函数的指针形参都应该声明为const。\n\n我认为这是值得我去思考去实践的。BUT思考前，今晚先去好好去撸个串🍖放松一下\n\n<!-- more -->\n\n---\n\n## 位运算\n众所周知，C中最小的类型是char类型，占一个字节，而一个字节占八位，例如00011001这样八个字节的二进制数，代表的其实是25，而位运算便是对位进行操作，在一些场景下能提高程序运行效率。\n\n### 按位取反 ~\n一元运算符~将每个1变为0，将每个0变为1，如下所示\n~~~\n~(10011010)\n  01100101\n~~~\n\n### 位与(AND) &\n二进制运算符&通过对两个操作数逐位进行比较产生一个新值。对于每个位，*只有两个操作数的对应位都是1时结果才为1*。 有一个用途便是用位与运算符来判断一个数字的奇偶性，因为基数的最后一位一定是1，偶数最后一位一定是0，因此可以通过 &= 进行运算后的值进行判断。\n~~~\n   (10010011) \n & (00111101) \n = (00010001)\n~~~\n\n### 位或(OR) |\n二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1。\n~~~\n    (10010011)\n  | (00111101)\n  = (10111111)\n~~~\n\n### 位异或 ^\n二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0。这是个十分有意思的位逻辑运算符，可以完成不创建临时变量从而互换两值的操作。\n~~~\n    (10010011)\n  ^ (00111101)\n  = (10101110)\n~~~\n骚操作如下(需要理解)😜：\n~~~\n//原理如下\n// A ^ B = R\n// R ^ B = A\n// R ^ A = B\n// 即 A ^ B ^ B = A; A ^ B ^ A = B\n\nint num1 = 7, num2 = 9;\nnum1 = num1 ^ num2;//R = A ^ B\nnum2 = num1 ^ num2;//B = R ^ B 将num1赋给num2\nnum1 = num1 ^ num2;//R = R ^ A 将num2赋给num1\n\n~~~\n\n### 左移/右移运算符 <<  >>\n左移运算符<<将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。\n\n总的来说就是左移n位，就相当于乘以2的n次幂；右移运算符 >>，右移n位，就相当于除以2的n次幂（但是，进对于非负数适用，负数在不同机器结果可能不同）\n~~~\n(10001010) << 2\n(00101000)\n~~~\n\n---\n\n## 深入理解数组\n该部分不容易理解！\n\n最重要记住：**在C中，在几乎所有数组名的表达式中，数组名的值是一个指针常量，也就是数组第一个元素的地址。**\n\n只有在以下两种情况下，数组名不作为指针常量！\n- 当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。\n- 当数组名作为&操作符的操作数的时候，此时返回的是一个指向数组的指针(重难点，理解指向数组的指针)，而不是指向某个数组元素的指针常量。\n\n*务必理解以下代码*\n~~~\nint arr[10];\n//arr = NULL; //arr作为指针常量，不可修改\nint *p = arr; //此时arr作为指针常量来使用\nprintf(\"sizeof(arr):%d\\n\", sizeof(arr)); //此时sizeof结果为整个数组的长度即40而不是4\nprintf(\"&arr type is %s\\n\", typeid(&arr).name()); //int(*)[10]而不是int*\n~~~\n\n---\n### 定义指向整个数组类型的指针\n对于这个指向整个数组类型的指针，解引用后结果为指向数组首元素的指针\n\n~~~\nint arr[] = { 1, 2, 3, 4 };\n\nint* p = &arr;//warning C4047:  “初始化”:“int *”与“int (*)[4]”的间接级别不同\n\nprintf(\"%d\\n\", *(p+1));//打印结果为2，可见上一步骤int* p = &arr 失败，仅将p指向了arr\n~~~\n\ntypedef定义数组类型的写法\n~~~\n//以下为正确定义方式\n//1、先定义数组类型 ，再定义数组指针类型\n\ntypedef int (ARRAY_TYPE)[4];//即ARRAY_TYPE为int [4]类型的数组\nARRAY_TYPE myArray;//等价于int myArray[4];\n\n//对数组名取地址即指向整个数组的指针\nARRAY_TYPE* pArray = &arr;\n\n//重难点：*pArray表示拿到了pArray指向的整个数组！\n//即*pArray类型就是数组名，指向数组首元素的指针类型\n\nprintf(\"*(*pArray + 1)= %d\\n\", *(*pArray + 1));//打印结果为2\n~~~\n\n~~~\n//2、定义数组指针类型\ntypedef int(*ARRAY_POINTER)[4];\nARRAY_POINTER arrPointer = &arr;\n~~~\n\n~~~\n//3、直接定义数组指针变量\nint(*pArrParam)[4] = &arr;\n~~~\n\n### 二维数组数组名作为实参传递\n二维数组数组名作为实参传递时，由于二维数组的数组名也是指向数组首元素的指针，而二维数组的首元素是一维数组，因此形参类型为**指向整个一维数组的指针类型**！\n\n被调函数\n~~~\ntypedef int(*ARR_TYPE)[3];\n//形参也可以直接写int(*p)[3]\nvoid printArray(ARR_TYPE p, int len,int width) {\n\tfor (int i = 0; i < len; ++i) {\n\t\tfor (int j = 0; j < width; ++j) {\n\t\t\tprintf(\"arr[i][j] = %d\\n\", *(*(p + i) + j));//等价于p[i][j]\n\t\t}\n\t}\n}\n~~~\n主调函数\n~~~\nint arr[3][3] = {\n    {1,2,3},\n    {4,5,6},\n    {7,8,9}\n};\n\n//与一维数组类似,二维数组的数组名在使用sizeof()和取地址的情况下不再是指向数组首元素的指针了\n// 二维数组的首元素为一维数组，因此指向二维数组首元素的指针为数组类型指针\nint(*aPointer)[3] = arr;\n\n// aPointer + 1为跳过二维数组的第一个一维数组，而指向二维数组中的第二个一维数组\n// *(aPointer + 1)则是解引用使得指向表示该一维数组的一维数组首元素指针。aPointer是数组类型指针，解引用为该数组的首元素指针。\n//printf(\"*(*(aPointer + 1) +2 )= %d\\n\", *(*(aPointer + 1) + 2));//打印结果为6\n\n\n//二维数组作为参数传递时,注意接收二维数组数组名的形参类型是数组指针类型！！\nprintArray(arr, 3, 3);\n~~~\n\n---\n\n### 字符串的选择排序\n选择排序相比于冒泡排序来说，交换次数更少，因为选择排序最多交换排序元素个数-1次。思路为，每次循环以一个元素为标准，并将定义一个最小元素下标变量记录它的下标，通过循环遍历除这个元素之外所有元素与之进行比较，若比它小，则记录其下标并更新最小元素下标，若最小元素下标正常更新，循环完毕将此时最小元素小标的那个元素与标准元素互换，如此反复即可完成从小到大的选择排序。\n\n~~~\nvoid selectSort(char** p, int len) {//需要理解形参为char**\n\tfor (int i = 0; i < len; ++i) {\n\t\tint min = i;// 记录下标\n\n\t\tfor (int j = i + 1; j < len; ++j) {\n\t\t\tif(strcmp(p[j], p[min]) < 0) {\n\t\t\t\tmin = j;\n\t\t\t}\n\t\t}\n\n\t\tif (min != i) {\n\t\t\tchar *temp = p[i];\n\t\t\tp[i] = p[min];\n\t\t\tp[min] = temp;\n\t\t}\n\n\t}\n}\n\n\nvoid test() {\n    char* p[] = { \"eee\",\"bbb\",\"ppp\",\"KKK\",\"RRR\" };\n\n    selectSort(p, 5);\n}\n\n\nint main() {\n    test();\n}\n~~~\n\n---\n\n## 深入理解结构体\n### 结构体深拷贝与浅拷贝\n深拷贝的示意图\n![222141a0.png](https://miao.su/images/2019/07/15/222141a0.png)\n\n\n切记如果结构体内部有指针指向堆空间，那么就不能使用编译器默认的赋值行为，而应当**手动控制赋值过程**!否则将会产生两个致命错误\n\n- 同一块空间释放两次\n- 内存泄露\n\n~~~\n上述所说错误具体可以表现为，一个包含char *类型等到结构体，定义两个结构体变量\n且均使用malloc等内存分配函数为char *分配了空间，则进行拷贝操作即结构体变量1直接写等于结构体变量2，将会产生以上错误。\n\n若要避免，应当先释放一个char *分配的内存，再实际为其分配将要拷贝数据大小的空间，使用strcpy进行拷贝char *的数据。\n~~~\n浅拷贝的示意图\n![11110a763.png](https://miao.su/images/2019/07/15/11110a763.png)\n\n\n### 结构体嵌套指针\n\n以下为该练习的内存分配示意图\n![2d508273fe91945095cdc.png](https://miao.su/images/2019/07/15/2d508273fe91945095cdc.png)\n\n\n定义结构体\n~~~\nstruct Person {\n\tint age;\n\tchar* name;\n};\n~~~\n\n分配空间\n~~~\nstruct Person** allocateSpace() {\n\n\tstruct Person** temp;\n\ttemp = malloc(sizeof(struct Person*) * 3);\n\n\tfor (int i = 0; i < 3; ++i) {\n\n\t\ttemp[i] = malloc(sizeof(struct Person));\n\n\t\ttemp[i]->name = malloc(sizeof(char) * 64);\n\n\t\tsprintf(temp[i]->name, \"Name_%d\", i + 1);\n\n\t}\n\n\treturn temp;\n}\n~~~\n释放空间(今天的写法更加优雅更加专业😁)\n先判断最外层指针是否为空，再判断中间层指针是否为空，为空continue，最后判断内层指针是否为空并对其操作，这样对中层的指针进行操作便不用再写if条件了。\n~~~\nvoid freeSpace(struct Person** person) {\n\n\tif (NULL == person)\n\t\treturn;\n\n\tfor (int i = 0; i < 3; ++i) {\n\n\t\tif (person[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif (person[i]->name != NULL) {\n\n\t\t\tfree(person[i]->name);\n\t\t\tperson[i]->name = NULL;\n\n\t\t}\n\n\t\tfree(person[i]);\n\t\tperson[i] = NULL;\n\n\t}\n\n\tif (person != NULL) {\n\t\tfree(person);\n\t\tperson = NULL;\n\t}\n\n}\n~~~\n调用函数\n~~~\nvoid test() {\n\tstruct Person** person = NULL;\n\n\tperson = allocateSpace();\n\n\tfreeSpace(person);\n}\n\nint main() {\n\ttest();\n}\n~~~\n\nPS：前半段撸串前写的，后半段撸串完了写的。太久没出去过了，从电梯走到小区门口等滴滴都有些累。。。看来每天需要锻炼锻炼身体了。今天还有件说不上让我开心的事儿，但是确实是让我压抑了很久的纠结解脱了。","source":"_posts/2019-Holiday-Note-03.md","raw":"---\ntitle: Holiday Note_03\ndate: 2019-07-15 17:06:15\ncategories: C\ntags: [Note,C]\n---\n\n# Holiday Note_03\n\n放假第三天。今天学习的主要内容是：1、**位运算**(感觉目前只有位异或和移位运算符挺实用的还能玩个骚操作，按位取反，位与，位或这些改变二进制位的运算初次接触还是挺晕的)。2、**数组的深入学习**(记住一句话，无论是几维数组，在除了sizeof和&这两种情况，数组名表示的是指向该数组第一个元素的指针，难点是理解数组类型指针解引用为指向数组首元素指针这一操作逻辑)。3、**结构体的深入学习**(重点理解结构体赋值的深拷贝，浅拷贝的内存模型，以及结构体嵌套指针)。\n对了，《C和指针》提到了两句话：\n> 源代码的可读性几乎总是比程序的运行时效率更为重要。\n> \n> 只要有可能，函数的指针形参都应该声明为const。\n\n我认为这是值得我去思考去实践的。BUT思考前，今晚先去好好去撸个串🍖放松一下\n\n<!-- more -->\n\n---\n\n## 位运算\n众所周知，C中最小的类型是char类型，占一个字节，而一个字节占八位，例如00011001这样八个字节的二进制数，代表的其实是25，而位运算便是对位进行操作，在一些场景下能提高程序运行效率。\n\n### 按位取反 ~\n一元运算符~将每个1变为0，将每个0变为1，如下所示\n~~~\n~(10011010)\n  01100101\n~~~\n\n### 位与(AND) &\n二进制运算符&通过对两个操作数逐位进行比较产生一个新值。对于每个位，*只有两个操作数的对应位都是1时结果才为1*。 有一个用途便是用位与运算符来判断一个数字的奇偶性，因为基数的最后一位一定是1，偶数最后一位一定是0，因此可以通过 &= 进行运算后的值进行判断。\n~~~\n   (10010011) \n & (00111101) \n = (00010001)\n~~~\n\n### 位或(OR) |\n二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1。\n~~~\n    (10010011)\n  | (00111101)\n  = (10111111)\n~~~\n\n### 位异或 ^\n二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0。这是个十分有意思的位逻辑运算符，可以完成不创建临时变量从而互换两值的操作。\n~~~\n    (10010011)\n  ^ (00111101)\n  = (10101110)\n~~~\n骚操作如下(需要理解)😜：\n~~~\n//原理如下\n// A ^ B = R\n// R ^ B = A\n// R ^ A = B\n// 即 A ^ B ^ B = A; A ^ B ^ A = B\n\nint num1 = 7, num2 = 9;\nnum1 = num1 ^ num2;//R = A ^ B\nnum2 = num1 ^ num2;//B = R ^ B 将num1赋给num2\nnum1 = num1 ^ num2;//R = R ^ A 将num2赋给num1\n\n~~~\n\n### 左移/右移运算符 <<  >>\n左移运算符<<将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。\n\n总的来说就是左移n位，就相当于乘以2的n次幂；右移运算符 >>，右移n位，就相当于除以2的n次幂（但是，进对于非负数适用，负数在不同机器结果可能不同）\n~~~\n(10001010) << 2\n(00101000)\n~~~\n\n---\n\n## 深入理解数组\n该部分不容易理解！\n\n最重要记住：**在C中，在几乎所有数组名的表达式中，数组名的值是一个指针常量，也就是数组第一个元素的地址。**\n\n只有在以下两种情况下，数组名不作为指针常量！\n- 当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。\n- 当数组名作为&操作符的操作数的时候，此时返回的是一个指向数组的指针(重难点，理解指向数组的指针)，而不是指向某个数组元素的指针常量。\n\n*务必理解以下代码*\n~~~\nint arr[10];\n//arr = NULL; //arr作为指针常量，不可修改\nint *p = arr; //此时arr作为指针常量来使用\nprintf(\"sizeof(arr):%d\\n\", sizeof(arr)); //此时sizeof结果为整个数组的长度即40而不是4\nprintf(\"&arr type is %s\\n\", typeid(&arr).name()); //int(*)[10]而不是int*\n~~~\n\n---\n### 定义指向整个数组类型的指针\n对于这个指向整个数组类型的指针，解引用后结果为指向数组首元素的指针\n\n~~~\nint arr[] = { 1, 2, 3, 4 };\n\nint* p = &arr;//warning C4047:  “初始化”:“int *”与“int (*)[4]”的间接级别不同\n\nprintf(\"%d\\n\", *(p+1));//打印结果为2，可见上一步骤int* p = &arr 失败，仅将p指向了arr\n~~~\n\ntypedef定义数组类型的写法\n~~~\n//以下为正确定义方式\n//1、先定义数组类型 ，再定义数组指针类型\n\ntypedef int (ARRAY_TYPE)[4];//即ARRAY_TYPE为int [4]类型的数组\nARRAY_TYPE myArray;//等价于int myArray[4];\n\n//对数组名取地址即指向整个数组的指针\nARRAY_TYPE* pArray = &arr;\n\n//重难点：*pArray表示拿到了pArray指向的整个数组！\n//即*pArray类型就是数组名，指向数组首元素的指针类型\n\nprintf(\"*(*pArray + 1)= %d\\n\", *(*pArray + 1));//打印结果为2\n~~~\n\n~~~\n//2、定义数组指针类型\ntypedef int(*ARRAY_POINTER)[4];\nARRAY_POINTER arrPointer = &arr;\n~~~\n\n~~~\n//3、直接定义数组指针变量\nint(*pArrParam)[4] = &arr;\n~~~\n\n### 二维数组数组名作为实参传递\n二维数组数组名作为实参传递时，由于二维数组的数组名也是指向数组首元素的指针，而二维数组的首元素是一维数组，因此形参类型为**指向整个一维数组的指针类型**！\n\n被调函数\n~~~\ntypedef int(*ARR_TYPE)[3];\n//形参也可以直接写int(*p)[3]\nvoid printArray(ARR_TYPE p, int len,int width) {\n\tfor (int i = 0; i < len; ++i) {\n\t\tfor (int j = 0; j < width; ++j) {\n\t\t\tprintf(\"arr[i][j] = %d\\n\", *(*(p + i) + j));//等价于p[i][j]\n\t\t}\n\t}\n}\n~~~\n主调函数\n~~~\nint arr[3][3] = {\n    {1,2,3},\n    {4,5,6},\n    {7,8,9}\n};\n\n//与一维数组类似,二维数组的数组名在使用sizeof()和取地址的情况下不再是指向数组首元素的指针了\n// 二维数组的首元素为一维数组，因此指向二维数组首元素的指针为数组类型指针\nint(*aPointer)[3] = arr;\n\n// aPointer + 1为跳过二维数组的第一个一维数组，而指向二维数组中的第二个一维数组\n// *(aPointer + 1)则是解引用使得指向表示该一维数组的一维数组首元素指针。aPointer是数组类型指针，解引用为该数组的首元素指针。\n//printf(\"*(*(aPointer + 1) +2 )= %d\\n\", *(*(aPointer + 1) + 2));//打印结果为6\n\n\n//二维数组作为参数传递时,注意接收二维数组数组名的形参类型是数组指针类型！！\nprintArray(arr, 3, 3);\n~~~\n\n---\n\n### 字符串的选择排序\n选择排序相比于冒泡排序来说，交换次数更少，因为选择排序最多交换排序元素个数-1次。思路为，每次循环以一个元素为标准，并将定义一个最小元素下标变量记录它的下标，通过循环遍历除这个元素之外所有元素与之进行比较，若比它小，则记录其下标并更新最小元素下标，若最小元素下标正常更新，循环完毕将此时最小元素小标的那个元素与标准元素互换，如此反复即可完成从小到大的选择排序。\n\n~~~\nvoid selectSort(char** p, int len) {//需要理解形参为char**\n\tfor (int i = 0; i < len; ++i) {\n\t\tint min = i;// 记录下标\n\n\t\tfor (int j = i + 1; j < len; ++j) {\n\t\t\tif(strcmp(p[j], p[min]) < 0) {\n\t\t\t\tmin = j;\n\t\t\t}\n\t\t}\n\n\t\tif (min != i) {\n\t\t\tchar *temp = p[i];\n\t\t\tp[i] = p[min];\n\t\t\tp[min] = temp;\n\t\t}\n\n\t}\n}\n\n\nvoid test() {\n    char* p[] = { \"eee\",\"bbb\",\"ppp\",\"KKK\",\"RRR\" };\n\n    selectSort(p, 5);\n}\n\n\nint main() {\n    test();\n}\n~~~\n\n---\n\n## 深入理解结构体\n### 结构体深拷贝与浅拷贝\n深拷贝的示意图\n![222141a0.png](https://miao.su/images/2019/07/15/222141a0.png)\n\n\n切记如果结构体内部有指针指向堆空间，那么就不能使用编译器默认的赋值行为，而应当**手动控制赋值过程**!否则将会产生两个致命错误\n\n- 同一块空间释放两次\n- 内存泄露\n\n~~~\n上述所说错误具体可以表现为，一个包含char *类型等到结构体，定义两个结构体变量\n且均使用malloc等内存分配函数为char *分配了空间，则进行拷贝操作即结构体变量1直接写等于结构体变量2，将会产生以上错误。\n\n若要避免，应当先释放一个char *分配的内存，再实际为其分配将要拷贝数据大小的空间，使用strcpy进行拷贝char *的数据。\n~~~\n浅拷贝的示意图\n![11110a763.png](https://miao.su/images/2019/07/15/11110a763.png)\n\n\n### 结构体嵌套指针\n\n以下为该练习的内存分配示意图\n![2d508273fe91945095cdc.png](https://miao.su/images/2019/07/15/2d508273fe91945095cdc.png)\n\n\n定义结构体\n~~~\nstruct Person {\n\tint age;\n\tchar* name;\n};\n~~~\n\n分配空间\n~~~\nstruct Person** allocateSpace() {\n\n\tstruct Person** temp;\n\ttemp = malloc(sizeof(struct Person*) * 3);\n\n\tfor (int i = 0; i < 3; ++i) {\n\n\t\ttemp[i] = malloc(sizeof(struct Person));\n\n\t\ttemp[i]->name = malloc(sizeof(char) * 64);\n\n\t\tsprintf(temp[i]->name, \"Name_%d\", i + 1);\n\n\t}\n\n\treturn temp;\n}\n~~~\n释放空间(今天的写法更加优雅更加专业😁)\n先判断最外层指针是否为空，再判断中间层指针是否为空，为空continue，最后判断内层指针是否为空并对其操作，这样对中层的指针进行操作便不用再写if条件了。\n~~~\nvoid freeSpace(struct Person** person) {\n\n\tif (NULL == person)\n\t\treturn;\n\n\tfor (int i = 0; i < 3; ++i) {\n\n\t\tif (person[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif (person[i]->name != NULL) {\n\n\t\t\tfree(person[i]->name);\n\t\t\tperson[i]->name = NULL;\n\n\t\t}\n\n\t\tfree(person[i]);\n\t\tperson[i] = NULL;\n\n\t}\n\n\tif (person != NULL) {\n\t\tfree(person);\n\t\tperson = NULL;\n\t}\n\n}\n~~~\n调用函数\n~~~\nvoid test() {\n\tstruct Person** person = NULL;\n\n\tperson = allocateSpace();\n\n\tfreeSpace(person);\n}\n\nint main() {\n\ttest();\n}\n~~~\n\nPS：前半段撸串前写的，后半段撸串完了写的。太久没出去过了，从电梯走到小区门口等滴滴都有些累。。。看来每天需要锻炼锻炼身体了。今天还有件说不上让我开心的事儿，但是确实是让我压抑了很久的纠结解脱了。","slug":"2019-Holiday-Note-03","published":1,"updated":"2019-07-15T14:40:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihe000bsmjbyn22w62w","content":"<h1 id=\"Holiday-Note-03\"><a href=\"#Holiday-Note-03\" class=\"headerlink\" title=\"Holiday Note_03\"></a>Holiday Note_03</h1><p>放假第三天。今天学习的主要内容是：1、<strong>位运算</strong>(感觉目前只有位异或和移位运算符挺实用的还能玩个骚操作，按位取反，位与，位或这些改变二进制位的运算初次接触还是挺晕的)。2、<strong>数组的深入学习</strong>(记住一句话，无论是几维数组，在除了sizeof和&amp;这两种情况，数组名表示的是指向该数组第一个元素的指针，难点是理解数组类型指针解引用为指向数组首元素指针这一操作逻辑)。3、<strong>结构体的深入学习</strong>(重点理解结构体赋值的深拷贝，浅拷贝的内存模型，以及结构体嵌套指针)。<br>对了，《C和指针》提到了两句话：</p>\n<blockquote>\n<p>源代码的可读性几乎总是比程序的运行时效率更为重要。</p>\n<p>只要有可能，函数的指针形参都应该声明为const。</p>\n</blockquote>\n<p>我认为这是值得我去思考去实践的。BUT思考前，今晚先去好好去撸个串🍖放松一下</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><p>众所周知，C中最小的类型是char类型，占一个字节，而一个字节占八位，例如00011001这样八个字节的二进制数，代表的其实是25，而位运算便是对位进行操作，在一些场景下能提高程序运行效率。</p>\n<h3 id=\"按位取反\"><a href=\"#按位取反\" class=\"headerlink\" title=\"按位取反 ~\"></a>按位取反 ~</h3><p>一元运算符~将每个1变为0，将每个0变为1，如下所示</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~(<span class=\"number\">10011010</span>)</span><br><span class=\"line\">  <span class=\"number\">01100101</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"位与-AND-amp\"><a href=\"#位与-AND-amp\" class=\"headerlink\" title=\"位与(AND) &amp;\"></a>位与(AND) &amp;</h3><p>二进制运算符&amp;通过对两个操作数逐位进行比较产生一个新值。对于每个位，<em>只有两个操作数的对应位都是1时结果才为1</em>。 有一个用途便是用位与运算符来判断一个数字的奇偶性，因为基数的最后一位一定是1，偶数最后一位一定是0，因此可以通过 &amp;= 进行运算后的值进行判断。</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">  (10010011) </span></span><br><span class=\"line\">&amp; (00111101) </span><br><span class=\"line\"><span class=\"section\">= (00010001)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"位或-OR\"><a href=\"#位或-OR\" class=\"headerlink\" title=\"位或(OR) |\"></a>位或(OR) |</h3><p>二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1。</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">  (10010011)</span></span><br><span class=\"line\">| (00111101)</span><br><span class=\"line\"><span class=\"section\">= (10111111)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"位异或\"><a href=\"#位异或\" class=\"headerlink\" title=\"位异或 ^\"></a>位异或 ^</h3><p>二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0。这是个十分有意思的位逻辑运算符，可以完成不创建临时变量从而互换两值的操作。</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">  (10010011)</span></span><br><span class=\"line\">^ (00111101)</span><br><span class=\"line\"><span class=\"section\">= (10101110)</span></span><br></pre></td></tr></table></figure>\n\n<p>骚操作如下(需要理解)😜：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//原理如下</span></span><br><span class=\"line\"><span class=\"comment\">// A ^ B = R</span></span><br><span class=\"line\"><span class=\"comment\">// R ^ B = A</span></span><br><span class=\"line\"><span class=\"comment\">// R ^ A = B</span></span><br><span class=\"line\"><span class=\"comment\">// 即 A ^ B ^ B = A; A ^ B ^ A = B</span></span><br><span class=\"line\"></span><br><span class=\"line\">int num1 = <span class=\"number\">7</span>, num2 = <span class=\"number\">9</span>;</span><br><span class=\"line\">num1 = num1 ^ num2;<span class=\"comment\">//R = A ^ B</span></span><br><span class=\"line\">num2 = num1 ^ num2;<span class=\"comment\">//B = R ^ B 将num1赋给num2</span></span><br><span class=\"line\">num1 = num1 ^ num2;<span class=\"comment\">//R = R ^ A 将num2赋给num1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"左移-右移运算符-lt-lt-gt-gt\"><a href=\"#左移-右移运算符-lt-lt-gt-gt\" class=\"headerlink\" title=\"左移/右移运算符 &lt;&lt;  &gt;&gt;\"></a>左移/右移运算符 &lt;&lt;  &gt;&gt;</h3><p>左移运算符&lt;&lt;将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。</p>\n<p>总的来说就是左移n位，就相当于乘以2的n次幂；右移运算符 &gt;&gt;，右移n位，就相当于除以2的n次幂（但是，进对于非负数适用，负数在不同机器结果可能不同）</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">10001010</span>) &lt;&lt; <span class=\"number\">2</span></span><br><span class=\"line\">(<span class=\"number\">00101000</span>)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"深入理解数组\"><a href=\"#深入理解数组\" class=\"headerlink\" title=\"深入理解数组\"></a>深入理解数组</h2><p>该部分不容易理解！</p>\n<p>最重要记住：<strong>在C中，在几乎所有数组名的表达式中，数组名的值是一个指针常量，也就是数组第一个元素的地址。</strong></p>\n<p>只有在以下两种情况下，数组名不作为指针常量！</p>\n<ul>\n<li>当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。</li>\n<li>当数组名作为&amp;操作符的操作数的时候，此时返回的是一个指向数组的指针(重难点，理解指向数组的指针)，而不是指向某个数组元素的指针常量。</li>\n</ul>\n<p><em>务必理解以下代码</em></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"comment\">//arr = NULL; //arr作为指针常量，不可修改</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr; <span class=\"comment\">//此时arr作为指针常量来使用</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(arr):%d\\n\"</span>, <span class=\"keyword\">sizeof</span>(arr)); <span class=\"comment\">//此时sizeof结果为整个数组的长度即40而不是4</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;arr type is %s\\n\"</span>, <span class=\"keyword\">typeid</span>(&amp;arr).name()); <span class=\"comment\">//int(*)[10]而不是int*</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"定义指向整个数组类型的指针\"><a href=\"#定义指向整个数组类型的指针\" class=\"headerlink\" title=\"定义指向整个数组类型的指针\"></a>定义指向整个数组类型的指针</h3><p>对于这个指向整个数组类型的指针，解引用后结果为指向数组首元素的指针</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int arr[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int* p = &amp;arr;<span class=\"comment\">//warning C4047:  “初始化”:“int *”与“int (*)[4]”的间接级别不同</span></span><br><span class=\"line\"></span><br><span class=\"line\">printf(<span class=\"string\">\"%d<span class=\"subst\">\\n</span>\"</span>, *(p+<span class=\"number\">1</span>));<span class=\"comment\">//打印结果为2，可见上一步骤int* p = &amp;arr 失败，仅将p指向了arr</span></span><br></pre></td></tr></table></figure>\n\n<p>typedef定义数组类型的写法</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以下为正确定义方式</span></span><br><span class=\"line\"><span class=\"comment\">//1、先定义数组类型 ，再定义数组指针类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">typedef int (ARRAY_TYPE)[<span class=\"number\">4</span>];<span class=\"comment\">//即ARRAY_TYPE为int [4]类型的数组</span></span><br><span class=\"line\">ARRAY_TYPE myArray;<span class=\"comment\">//等价于int myArray[4];</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对数组名取地址即指向整个数组的指针</span></span><br><span class=\"line\">ARRAY_TYPE* pArray = &amp;arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//重难点：*pArray表示拿到了pArray指向的整个数组！</span></span><br><span class=\"line\"><span class=\"comment\">//即*pArray类型就是数组名，指向数组首元素的指针类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">printf(<span class=\"string\">\"*(*pArray + 1)= %d<span class=\"subst\">\\n</span>\"</span>, *(*pArray + <span class=\"number\">1</span>));<span class=\"comment\">//打印结果为2</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//2、定义数组指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span>(*ARRAY_POINTER)[<span class=\"number\">4</span>];</span><br><span class=\"line\">ARRAY_POINTER arrPointer = &amp;arr;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//3、直接定义数组指针变量</span></span><br><span class=\"line\">int(*pArrParam)[<span class=\"number\">4</span>] = <span class=\"meta\">&amp;arr;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二维数组数组名作为实参传递\"><a href=\"#二维数组数组名作为实参传递\" class=\"headerlink\" title=\"二维数组数组名作为实参传递\"></a>二维数组数组名作为实参传递</h3><p>二维数组数组名作为实参传递时，由于二维数组的数组名也是指向数组首元素的指针，而二维数组的首元素是一维数组，因此形参类型为<strong>指向整个一维数组的指针类型</strong>！</p>\n<p>被调函数</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span>(*ARR_TYPE)[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">//形参也可以直接写int(*p)[3]</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> printArray(ARR_TYPE p, <span class=\"keyword\">int</span> len,<span class=\"keyword\">int</span> <span class=\"built_in\">width</span>) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">width</span>; ++j) &#123;</span><br><span class=\"line\">\t\t\tprintf(<span class=\"string\">\"arr[i][j] = %d\\n\"</span>, *(*(p + i) + j));<span class=\"comment\">//等价于p[i][j]</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主调函数</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int arr[<span class=\"number\">3</span>][<span class=\"number\">3</span>] = &#123;</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//与一维数组类似,二维数组的数组名在使用sizeof()和取地址的情况下不再是指向数组首元素的指针了</span></span><br><span class=\"line\"><span class=\"comment\">// 二维数组的首元素为一维数组，因此指向二维数组首元素的指针为数组类型指针</span></span><br><span class=\"line\">int(*aPointer)[<span class=\"number\">3</span>] = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// aPointer + 1为跳过二维数组的第一个一维数组，而指向二维数组中的第二个一维数组</span></span><br><span class=\"line\"><span class=\"comment\">// *(aPointer + 1)则是解引用使得指向表示该一维数组的一维数组首元素指针。aPointer是数组类型指针，解引用为该数组的首元素指针。</span></span><br><span class=\"line\"><span class=\"comment\">//printf(\"*(*(aPointer + 1) +2 )= %d\\n\", *(*(aPointer + 1) + 2));//打印结果为6</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//二维数组作为参数传递时,注意接收二维数组数组名的形参类型是数组指针类型！！</span></span><br><span class=\"line\">printArray(arr, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"字符串的选择排序\"><a href=\"#字符串的选择排序\" class=\"headerlink\" title=\"字符串的选择排序\"></a>字符串的选择排序</h3><p>选择排序相比于冒泡排序来说，交换次数更少，因为选择排序最多交换排序元素个数-1次。思路为，每次循环以一个元素为标准，并将定义一个最小元素下标变量记录它的下标，通过循环遍历除这个元素之外所有元素与之进行比较，若比它小，则记录其下标并更新最小元素下标，若最小元素下标正常更新，循环完毕将此时最小元素小标的那个元素与标准元素互换，如此反复即可完成从小到大的选择排序。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> selectSort(<span class=\"keyword\">char</span>** p, <span class=\"keyword\">int</span> len) &#123;<span class=\"comment\">//需要理解形参为char**</span></span><br><span class=\"line\">\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> <span class=\"built_in\">min</span> = i;<span class=\"comment\">// 记录下标</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; len; ++j) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">if</span>(strcmp(p[j], p[<span class=\"built_in\">min</span>]) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">min</span> = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">if</span> (<span class=\"built_in\">min</span> != i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">char</span> *temp = p[i];</span><br><span class=\"line\">\t\t\tp[i] = p[<span class=\"built_in\">min</span>];</span><br><span class=\"line\">\t\t\tp[<span class=\"built_in\">min</span>] = temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> test() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* p[] = &#123; <span class=\"string\">\"eee\"</span>,<span class=\"string\">\"bbb\"</span>,<span class=\"string\">\"ppp\"</span>,<span class=\"string\">\"KKK\"</span>,<span class=\"string\">\"RRR\"</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    selectSort(p, <span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main() &#123;</span><br><span class=\"line\">    test();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"深入理解结构体\"><a href=\"#深入理解结构体\" class=\"headerlink\" title=\"深入理解结构体\"></a>深入理解结构体</h2><h3 id=\"结构体深拷贝与浅拷贝\"><a href=\"#结构体深拷贝与浅拷贝\" class=\"headerlink\" title=\"结构体深拷贝与浅拷贝\"></a>结构体深拷贝与浅拷贝</h3><p>深拷贝的示意图<br><img src=\"https://miao.su/images/2019/07/15/222141a0.png\" alt=\"222141a0.png\"></p>\n<p>切记如果结构体内部有指针指向堆空间，那么就不能使用编译器默认的赋值行为，而应当<strong>手动控制赋值过程</strong>!否则将会产生两个致命错误</p>\n<ul>\n<li>同一块空间释放两次</li>\n<li>内存泄露</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上述所说错误具体可以表现为，一个包含<span class=\"keyword\">char</span> *类型等到结构体，定义两个结构体变量</span><br><span class=\"line\">且均使用<span class=\"built_in\">malloc</span>等内存分配函数为<span class=\"keyword\">char</span> *分配了空间，则进行拷贝操作即结构体变量<span class=\"number\">1</span>直接写等于结构体变量<span class=\"number\">2</span>，将会产生以上错误。</span><br><span class=\"line\"></span><br><span class=\"line\">若要避免，应当先释放一个<span class=\"keyword\">char</span> *分配的内存，再实际为其分配将要拷贝数据大小的空间，使用<span class=\"built_in\">strcpy</span>进行拷贝<span class=\"keyword\">char</span> *的数据。</span><br></pre></td></tr></table></figure>\n\n<p>浅拷贝的示意图<br><img src=\"https://miao.su/images/2019/07/15/11110a763.png\" alt=\"11110a763.png\"></p>\n<h3 id=\"结构体嵌套指针\"><a href=\"#结构体嵌套指针\" class=\"headerlink\" title=\"结构体嵌套指针\"></a>结构体嵌套指针</h3><p>以下为该练习的内存分配示意图<br><img src=\"https://miao.su/images/2019/07/15/2d508273fe91945095cdc.png\" alt=\"2d508273fe91945095cdc.png\"></p>\n<p>定义结构体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>分配空间</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>** allocateSpace() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>** temp;</span><br><span class=\"line\">\ttemp = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*) * <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttemp[i] = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttemp[i]-&gt;name = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"built_in\">char</span>) * <span class=\"number\">64</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsprintf(temp[i]-&gt;name, <span class=\"string\">\"Name_%d\"</span>, i + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>释放空间(今天的写法更加优雅更加专业😁)<br>先判断最外层指针是否为空，再判断中间层指针是否为空，为空continue，最后判断内层指针是否为空并对其操作，这样对中层的指针进行操作便不用再写if条件了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">freeSpace</span><span class=\"params\">(struct Person** person)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == person)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (person[i] == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (person[i]-&gt;name != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(person[i]-&gt;name);</span><br><span class=\"line\">\t\t\tperson[i]-&gt;name = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(person[i]);</span><br><span class=\"line\">\t\tperson[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (person != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(person);</span><br><span class=\"line\">\t\tperson = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>** <span class=\"title\">person</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tperson = allocateSpace();</span><br><span class=\"line\"></span><br><span class=\"line\">\tfreeSpace(person);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\ttest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS：前半段撸串前写的，后半段撸串完了写的。太久没出去过了，从电梯走到小区门口等滴滴都有些累。。。看来每天需要锻炼锻炼身体了。今天还有件说不上让我开心的事儿，但是确实是让我压抑了很久的纠结解脱了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-03\"><a href=\"#Holiday-Note-03\" class=\"headerlink\" title=\"Holiday Note_03\"></a>Holiday Note_03</h1><p>放假第三天。今天学习的主要内容是：1、<strong>位运算</strong>(感觉目前只有位异或和移位运算符挺实用的还能玩个骚操作，按位取反，位与，位或这些改变二进制位的运算初次接触还是挺晕的)。2、<strong>数组的深入学习</strong>(记住一句话，无论是几维数组，在除了sizeof和&amp;这两种情况，数组名表示的是指向该数组第一个元素的指针，难点是理解数组类型指针解引用为指向数组首元素指针这一操作逻辑)。3、<strong>结构体的深入学习</strong>(重点理解结构体赋值的深拷贝，浅拷贝的内存模型，以及结构体嵌套指针)。<br>对了，《C和指针》提到了两句话：</p>\n<blockquote>\n<p>源代码的可读性几乎总是比程序的运行时效率更为重要。</p>\n<p>只要有可能，函数的指针形参都应该声明为const。</p>\n</blockquote>\n<p>我认为这是值得我去思考去实践的。BUT思考前，今晚先去好好去撸个串🍖放松一下</p>","more":"<hr>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><p>众所周知，C中最小的类型是char类型，占一个字节，而一个字节占八位，例如00011001这样八个字节的二进制数，代表的其实是25，而位运算便是对位进行操作，在一些场景下能提高程序运行效率。</p>\n<h3 id=\"按位取反\"><a href=\"#按位取反\" class=\"headerlink\" title=\"按位取反 ~\"></a>按位取反 ~</h3><p>一元运算符~将每个1变为0，将每个0变为1，如下所示</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~(<span class=\"number\">10011010</span>)</span><br><span class=\"line\">  <span class=\"number\">01100101</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"位与-AND-amp\"><a href=\"#位与-AND-amp\" class=\"headerlink\" title=\"位与(AND) &amp;\"></a>位与(AND) &amp;</h3><p>二进制运算符&amp;通过对两个操作数逐位进行比较产生一个新值。对于每个位，<em>只有两个操作数的对应位都是1时结果才为1</em>。 有一个用途便是用位与运算符来判断一个数字的奇偶性，因为基数的最后一位一定是1，偶数最后一位一定是0，因此可以通过 &amp;= 进行运算后的值进行判断。</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">  (10010011) </span></span><br><span class=\"line\">&amp; (00111101) </span><br><span class=\"line\"><span class=\"section\">= (00010001)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"位或-OR\"><a href=\"#位或-OR\" class=\"headerlink\" title=\"位或(OR) |\"></a>位或(OR) |</h3><p>二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1。</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">  (10010011)</span></span><br><span class=\"line\">| (00111101)</span><br><span class=\"line\"><span class=\"section\">= (10111111)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"位异或\"><a href=\"#位异或\" class=\"headerlink\" title=\"位异或 ^\"></a>位异或 ^</h3><p>二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0。这是个十分有意思的位逻辑运算符，可以完成不创建临时变量从而互换两值的操作。</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">  (10010011)</span></span><br><span class=\"line\">^ (00111101)</span><br><span class=\"line\"><span class=\"section\">= (10101110)</span></span><br></pre></td></tr></table></figure>\n\n<p>骚操作如下(需要理解)😜：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//原理如下</span></span><br><span class=\"line\"><span class=\"comment\">// A ^ B = R</span></span><br><span class=\"line\"><span class=\"comment\">// R ^ B = A</span></span><br><span class=\"line\"><span class=\"comment\">// R ^ A = B</span></span><br><span class=\"line\"><span class=\"comment\">// 即 A ^ B ^ B = A; A ^ B ^ A = B</span></span><br><span class=\"line\"></span><br><span class=\"line\">int num1 = <span class=\"number\">7</span>, num2 = <span class=\"number\">9</span>;</span><br><span class=\"line\">num1 = num1 ^ num2;<span class=\"comment\">//R = A ^ B</span></span><br><span class=\"line\">num2 = num1 ^ num2;<span class=\"comment\">//B = R ^ B 将num1赋给num2</span></span><br><span class=\"line\">num1 = num1 ^ num2;<span class=\"comment\">//R = R ^ A 将num2赋给num1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"左移-右移运算符-lt-lt-gt-gt\"><a href=\"#左移-右移运算符-lt-lt-gt-gt\" class=\"headerlink\" title=\"左移/右移运算符 &lt;&lt;  &gt;&gt;\"></a>左移/右移运算符 &lt;&lt;  &gt;&gt;</h3><p>左移运算符&lt;&lt;将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。</p>\n<p>总的来说就是左移n位，就相当于乘以2的n次幂；右移运算符 &gt;&gt;，右移n位，就相当于除以2的n次幂（但是，进对于非负数适用，负数在不同机器结果可能不同）</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">10001010</span>) &lt;&lt; <span class=\"number\">2</span></span><br><span class=\"line\">(<span class=\"number\">00101000</span>)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"深入理解数组\"><a href=\"#深入理解数组\" class=\"headerlink\" title=\"深入理解数组\"></a>深入理解数组</h2><p>该部分不容易理解！</p>\n<p>最重要记住：<strong>在C中，在几乎所有数组名的表达式中，数组名的值是一个指针常量，也就是数组第一个元素的地址。</strong></p>\n<p>只有在以下两种情况下，数组名不作为指针常量！</p>\n<ul>\n<li>当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。</li>\n<li>当数组名作为&amp;操作符的操作数的时候，此时返回的是一个指向数组的指针(重难点，理解指向数组的指针)，而不是指向某个数组元素的指针常量。</li>\n</ul>\n<p><em>务必理解以下代码</em></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"comment\">//arr = NULL; //arr作为指针常量，不可修改</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr; <span class=\"comment\">//此时arr作为指针常量来使用</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(arr):%d\\n\"</span>, <span class=\"keyword\">sizeof</span>(arr)); <span class=\"comment\">//此时sizeof结果为整个数组的长度即40而不是4</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;arr type is %s\\n\"</span>, <span class=\"keyword\">typeid</span>(&amp;arr).name()); <span class=\"comment\">//int(*)[10]而不是int*</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"定义指向整个数组类型的指针\"><a href=\"#定义指向整个数组类型的指针\" class=\"headerlink\" title=\"定义指向整个数组类型的指针\"></a>定义指向整个数组类型的指针</h3><p>对于这个指向整个数组类型的指针，解引用后结果为指向数组首元素的指针</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int arr[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int* p = &amp;arr;<span class=\"comment\">//warning C4047:  “初始化”:“int *”与“int (*)[4]”的间接级别不同</span></span><br><span class=\"line\"></span><br><span class=\"line\">printf(<span class=\"string\">\"%d<span class=\"subst\">\\n</span>\"</span>, *(p+<span class=\"number\">1</span>));<span class=\"comment\">//打印结果为2，可见上一步骤int* p = &amp;arr 失败，仅将p指向了arr</span></span><br></pre></td></tr></table></figure>\n\n<p>typedef定义数组类型的写法</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以下为正确定义方式</span></span><br><span class=\"line\"><span class=\"comment\">//1、先定义数组类型 ，再定义数组指针类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">typedef int (ARRAY_TYPE)[<span class=\"number\">4</span>];<span class=\"comment\">//即ARRAY_TYPE为int [4]类型的数组</span></span><br><span class=\"line\">ARRAY_TYPE myArray;<span class=\"comment\">//等价于int myArray[4];</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对数组名取地址即指向整个数组的指针</span></span><br><span class=\"line\">ARRAY_TYPE* pArray = &amp;arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//重难点：*pArray表示拿到了pArray指向的整个数组！</span></span><br><span class=\"line\"><span class=\"comment\">//即*pArray类型就是数组名，指向数组首元素的指针类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">printf(<span class=\"string\">\"*(*pArray + 1)= %d<span class=\"subst\">\\n</span>\"</span>, *(*pArray + <span class=\"number\">1</span>));<span class=\"comment\">//打印结果为2</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//2、定义数组指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span>(*ARRAY_POINTER)[<span class=\"number\">4</span>];</span><br><span class=\"line\">ARRAY_POINTER arrPointer = &amp;arr;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//3、直接定义数组指针变量</span></span><br><span class=\"line\">int(*pArrParam)[<span class=\"number\">4</span>] = <span class=\"meta\">&amp;arr;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二维数组数组名作为实参传递\"><a href=\"#二维数组数组名作为实参传递\" class=\"headerlink\" title=\"二维数组数组名作为实参传递\"></a>二维数组数组名作为实参传递</h3><p>二维数组数组名作为实参传递时，由于二维数组的数组名也是指向数组首元素的指针，而二维数组的首元素是一维数组，因此形参类型为<strong>指向整个一维数组的指针类型</strong>！</p>\n<p>被调函数</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span>(*ARR_TYPE)[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">//形参也可以直接写int(*p)[3]</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> printArray(ARR_TYPE p, <span class=\"keyword\">int</span> len,<span class=\"keyword\">int</span> <span class=\"built_in\">width</span>) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">width</span>; ++j) &#123;</span><br><span class=\"line\">\t\t\tprintf(<span class=\"string\">\"arr[i][j] = %d\\n\"</span>, *(*(p + i) + j));<span class=\"comment\">//等价于p[i][j]</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主调函数</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int arr[<span class=\"number\">3</span>][<span class=\"number\">3</span>] = &#123;</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//与一维数组类似,二维数组的数组名在使用sizeof()和取地址的情况下不再是指向数组首元素的指针了</span></span><br><span class=\"line\"><span class=\"comment\">// 二维数组的首元素为一维数组，因此指向二维数组首元素的指针为数组类型指针</span></span><br><span class=\"line\">int(*aPointer)[<span class=\"number\">3</span>] = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// aPointer + 1为跳过二维数组的第一个一维数组，而指向二维数组中的第二个一维数组</span></span><br><span class=\"line\"><span class=\"comment\">// *(aPointer + 1)则是解引用使得指向表示该一维数组的一维数组首元素指针。aPointer是数组类型指针，解引用为该数组的首元素指针。</span></span><br><span class=\"line\"><span class=\"comment\">//printf(\"*(*(aPointer + 1) +2 )= %d\\n\", *(*(aPointer + 1) + 2));//打印结果为6</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//二维数组作为参数传递时,注意接收二维数组数组名的形参类型是数组指针类型！！</span></span><br><span class=\"line\">printArray(arr, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"字符串的选择排序\"><a href=\"#字符串的选择排序\" class=\"headerlink\" title=\"字符串的选择排序\"></a>字符串的选择排序</h3><p>选择排序相比于冒泡排序来说，交换次数更少，因为选择排序最多交换排序元素个数-1次。思路为，每次循环以一个元素为标准，并将定义一个最小元素下标变量记录它的下标，通过循环遍历除这个元素之外所有元素与之进行比较，若比它小，则记录其下标并更新最小元素下标，若最小元素下标正常更新，循环完毕将此时最小元素小标的那个元素与标准元素互换，如此反复即可完成从小到大的选择排序。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> selectSort(<span class=\"keyword\">char</span>** p, <span class=\"keyword\">int</span> len) &#123;<span class=\"comment\">//需要理解形参为char**</span></span><br><span class=\"line\">\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> <span class=\"built_in\">min</span> = i;<span class=\"comment\">// 记录下标</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; len; ++j) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">if</span>(strcmp(p[j], p[<span class=\"built_in\">min</span>]) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">min</span> = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">if</span> (<span class=\"built_in\">min</span> != i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">char</span> *temp = p[i];</span><br><span class=\"line\">\t\t\tp[i] = p[<span class=\"built_in\">min</span>];</span><br><span class=\"line\">\t\t\tp[<span class=\"built_in\">min</span>] = temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> test() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* p[] = &#123; <span class=\"string\">\"eee\"</span>,<span class=\"string\">\"bbb\"</span>,<span class=\"string\">\"ppp\"</span>,<span class=\"string\">\"KKK\"</span>,<span class=\"string\">\"RRR\"</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    selectSort(p, <span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main() &#123;</span><br><span class=\"line\">    test();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"深入理解结构体\"><a href=\"#深入理解结构体\" class=\"headerlink\" title=\"深入理解结构体\"></a>深入理解结构体</h2><h3 id=\"结构体深拷贝与浅拷贝\"><a href=\"#结构体深拷贝与浅拷贝\" class=\"headerlink\" title=\"结构体深拷贝与浅拷贝\"></a>结构体深拷贝与浅拷贝</h3><p>深拷贝的示意图<br><img src=\"https://miao.su/images/2019/07/15/222141a0.png\" alt=\"222141a0.png\"></p>\n<p>切记如果结构体内部有指针指向堆空间，那么就不能使用编译器默认的赋值行为，而应当<strong>手动控制赋值过程</strong>!否则将会产生两个致命错误</p>\n<ul>\n<li>同一块空间释放两次</li>\n<li>内存泄露</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上述所说错误具体可以表现为，一个包含<span class=\"keyword\">char</span> *类型等到结构体，定义两个结构体变量</span><br><span class=\"line\">且均使用<span class=\"built_in\">malloc</span>等内存分配函数为<span class=\"keyword\">char</span> *分配了空间，则进行拷贝操作即结构体变量<span class=\"number\">1</span>直接写等于结构体变量<span class=\"number\">2</span>，将会产生以上错误。</span><br><span class=\"line\"></span><br><span class=\"line\">若要避免，应当先释放一个<span class=\"keyword\">char</span> *分配的内存，再实际为其分配将要拷贝数据大小的空间，使用<span class=\"built_in\">strcpy</span>进行拷贝<span class=\"keyword\">char</span> *的数据。</span><br></pre></td></tr></table></figure>\n\n<p>浅拷贝的示意图<br><img src=\"https://miao.su/images/2019/07/15/11110a763.png\" alt=\"11110a763.png\"></p>\n<h3 id=\"结构体嵌套指针\"><a href=\"#结构体嵌套指针\" class=\"headerlink\" title=\"结构体嵌套指针\"></a>结构体嵌套指针</h3><p>以下为该练习的内存分配示意图<br><img src=\"https://miao.su/images/2019/07/15/2d508273fe91945095cdc.png\" alt=\"2d508273fe91945095cdc.png\"></p>\n<p>定义结构体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>分配空间</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>** allocateSpace() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>** temp;</span><br><span class=\"line\">\ttemp = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*) * <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttemp[i] = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttemp[i]-&gt;name = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"built_in\">char</span>) * <span class=\"number\">64</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsprintf(temp[i]-&gt;name, <span class=\"string\">\"Name_%d\"</span>, i + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>释放空间(今天的写法更加优雅更加专业😁)<br>先判断最外层指针是否为空，再判断中间层指针是否为空，为空continue，最后判断内层指针是否为空并对其操作，这样对中层的指针进行操作便不用再写if条件了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">freeSpace</span><span class=\"params\">(struct Person** person)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == person)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (person[i] == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (person[i]-&gt;name != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(person[i]-&gt;name);</span><br><span class=\"line\">\t\t\tperson[i]-&gt;name = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(person[i]);</span><br><span class=\"line\">\t\tperson[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (person != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(person);</span><br><span class=\"line\">\t\tperson = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>** <span class=\"title\">person</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tperson = allocateSpace();</span><br><span class=\"line\"></span><br><span class=\"line\">\tfreeSpace(person);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\ttest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS：前半段撸串前写的，后半段撸串完了写的。太久没出去过了，从电梯走到小区门口等滴滴都有些累。。。看来每天需要锻炼锻炼身体了。今天还有件说不上让我开心的事儿，但是确实是让我压抑了很久的纠结解脱了。</p>"},{"title":"Holiday Note_05","date":"2019-07-18T08:53:07.000Z","_content":"\n# Holiday Note_05\n\n放假第六天。今天的内容内容不多，重点是**链表反转**，**函数递归**。然后就是简单了解了下**预处理**，**静态库和动态库**以及**面向接口编程**的内容了。\n\n<!-- more -->\n\n---\n\n## 链表反转\n\n跟昨天重学链表一样，又是豁然开朗的感觉。之前看到链表反转的题目，想了半天做不出，看别人博客的解题思路还看不懂**定义三指针**的作用何在。其实三个指针就是记录位置，一个中间的用来判断是不是NULL，另外两个一前一后保证链表地址不丢失可以重新进行连接，画个图，把指针的指向画出来就明白为什么要三个指针了。\n\n\n![20180407202437512045a5.png](https://miao.su/images/2019/07/18/20180407202437512045a5.png)\n~~~\nvoid Reserve_LinkList(struct LinkListNode* header) {\n\n\tif (NULL == header)\n\t\treturn;\n\n    //header是头结点\n\tstruct LinkListNode* pHead = header->next;\n\tstruct LinkListNode* pPrev = NULL;\n\tstruct LinkListNode* pNext = NULL;\n\n\twhile (pHead != NULL) {\n\n        //记录下来后结点的地址\n\t\tpNext = pHead->next;\n        //该结点指向前结点，第一次执行是指向NULL\n\t\tpHead->next = pPrev;\n        //更新前结点指向的地址-->\n\t\tpPrev = pHead; \n        //更新当前结点的地址 -->\n\t\tpHead = pNext;\n\n\t}\n    \n    //当前 结点指向空时退出循环，此时 前 结点指向的是该链表的最后一个结点\n\theader->next = pPrev;\n\n}\n~~~\n\n---\n\n## 函数递归\n\nC通过运行时**堆栈**来支持递归函数的实现。递归函数就是直接或间接调用自身的函数。若递归没有退出条件则会使得栈移除从而程序挂掉。因此**写递归最重要的就是设置退出条件！**\n\n### 普通函数调用\n~~~\nvoid funB(int b){\n\n\tprintf(\"b = %d\\n\", b);\n\n}\n\nvoid funA(int a){\n\n\tfunB(a - 1);\n\tprintf(\"a = %d\\n\", a);\n\n}\n\nint main(void){\n\n\tfunA(2);\n\n}\n~~~\n\n![142374.png](https://miao.su/images/2019/07/18/142374.png)\n\n---\n\n### 递归函数调用\n~~~\nvoid fun(int a){\n\t\n\tif (a == 1){\n\t\tprintf(\"a = %d\\n\", a);\n\t\treturn; //中断函数很重要\n\t}\n\n\tfun(a - 1);\n\tprintf(\"a = %d\\n\", a);\n\n}\n\nint main(void){\n\n\tfun(2);\n\n}\n~~~\n![23879c.png](https://miao.su/images/2019/07/18/23879c.png)\n\n---\n\n### 递归逆序打印链表(不改变数据位置)\n\n只要结点不为NULL，继续调用直到为空，此时执行的第一个打印是的链表最后的一个数据，再不断的返回直到反向打印完所有数据退出函数。\n~~~\nvoid ReservePrint_LinkList(struct LinkListNode* header) {\n\n\tif (NULL == header)\n\t\treturn;\n\n\tReservePrint_LinkList(header->next);\n\n\tprintf(\"%d \", header->data);\n\n}\n~~~\n\n---\n\n## 预处理\n\n### 文件包含指令#incude<>和#include\"\"区别\n\n- \"\" 表示系统先在file1.c所在的当前目录找file1.h，如果找不到，再按系统指定的目录检索。\n- < > 表示系统直接按系统指定的目录检索。\n\n注意：\n1. #include <>常用于包含库函数的头文件；\n2. #include \"\"常用于包含自定义的头文件；\n3. 理论上#include可以包含任意格式的文件(.c .h等) ，但一般用于头文件的包含；\n\n### 宏定义\n\n1.\t宏名一般用大写，以便于与变量区别；\n2.\t宏定义可以是常数、表达式等；\n3.\t**宏定义不作语法检查**，只有在编译被宏展开后的源程序才会报错；\n4.\t**宏定义不是C语言**，不在行末加分号；\n5.\t宏名有效范围为**从定义到本源文件结束**；\n6.\t可以用#undef命令终止宏定义的作用域；\n7.\t在宏定义中，可以引用已定义的宏名；\n8.  在预编译时将宏名替换成字符串的过程称为“宏展开”\n\n\n#### 一些特殊的预定宏\n\nC编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。\n\n~~~\n__FILE__\t    宏所在文件的源文件名 \n__LINE__\t    宏所在行的行号\n__DATE__\t    代码编译的日期\n__TIME__\t    代码编译的时间\n\nvoid test()\n{\n\tprintf(\"%s\\n\", __FILE__);\n\tprintf(\"%d\\n\", __LINE__);\n\tprintf(\"%s\\n\", __DATE__);\n\tprintf(\"%s\\n\", __TIME__);\n}\n~~~\n\n---\n\n## 静态库和动态库\n\n**库是已经写好的、成熟的、可复用的代码**。库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。\n\n感觉挺简单的，也就了解了一下静态库和动态库怎么创建和使用，我也就没有自己写了，偷了回懒。\n\n### 静态库的缺点\n>浪费空间，不方便更新和移植。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间。一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序。\n- 静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；\n- 程序在运行时与函数库再无瓜葛，移植方便。\n- 浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。\n\n### 动态链接的思想\n> 要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，**就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接**。也就是说，把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想。\n\n---\n\n## 面向接口编程\n\n案列比较简单，主要就是函数回调的思想，客户和企业沟通完接口后，根据接口所定义的参数和函数指针，分别开发业务代码和被调用的实现代码。\n\n> 模块要求松、接口要求紧。\n\n\nPS:天津今天下了点小雨，最近天气都很不好，每天都灰蒙蒙的挺压抑的。","source":"_posts/2019-Holiday-Note-06.md","raw":"---\ntitle: Holiday Note_05\ndate: 2019-07-18 16:53:07\ncategories: C\ntags: [Note,C]\n---\n\n# Holiday Note_05\n\n放假第六天。今天的内容内容不多，重点是**链表反转**，**函数递归**。然后就是简单了解了下**预处理**，**静态库和动态库**以及**面向接口编程**的内容了。\n\n<!-- more -->\n\n---\n\n## 链表反转\n\n跟昨天重学链表一样，又是豁然开朗的感觉。之前看到链表反转的题目，想了半天做不出，看别人博客的解题思路还看不懂**定义三指针**的作用何在。其实三个指针就是记录位置，一个中间的用来判断是不是NULL，另外两个一前一后保证链表地址不丢失可以重新进行连接，画个图，把指针的指向画出来就明白为什么要三个指针了。\n\n\n![20180407202437512045a5.png](https://miao.su/images/2019/07/18/20180407202437512045a5.png)\n~~~\nvoid Reserve_LinkList(struct LinkListNode* header) {\n\n\tif (NULL == header)\n\t\treturn;\n\n    //header是头结点\n\tstruct LinkListNode* pHead = header->next;\n\tstruct LinkListNode* pPrev = NULL;\n\tstruct LinkListNode* pNext = NULL;\n\n\twhile (pHead != NULL) {\n\n        //记录下来后结点的地址\n\t\tpNext = pHead->next;\n        //该结点指向前结点，第一次执行是指向NULL\n\t\tpHead->next = pPrev;\n        //更新前结点指向的地址-->\n\t\tpPrev = pHead; \n        //更新当前结点的地址 -->\n\t\tpHead = pNext;\n\n\t}\n    \n    //当前 结点指向空时退出循环，此时 前 结点指向的是该链表的最后一个结点\n\theader->next = pPrev;\n\n}\n~~~\n\n---\n\n## 函数递归\n\nC通过运行时**堆栈**来支持递归函数的实现。递归函数就是直接或间接调用自身的函数。若递归没有退出条件则会使得栈移除从而程序挂掉。因此**写递归最重要的就是设置退出条件！**\n\n### 普通函数调用\n~~~\nvoid funB(int b){\n\n\tprintf(\"b = %d\\n\", b);\n\n}\n\nvoid funA(int a){\n\n\tfunB(a - 1);\n\tprintf(\"a = %d\\n\", a);\n\n}\n\nint main(void){\n\n\tfunA(2);\n\n}\n~~~\n\n![142374.png](https://miao.su/images/2019/07/18/142374.png)\n\n---\n\n### 递归函数调用\n~~~\nvoid fun(int a){\n\t\n\tif (a == 1){\n\t\tprintf(\"a = %d\\n\", a);\n\t\treturn; //中断函数很重要\n\t}\n\n\tfun(a - 1);\n\tprintf(\"a = %d\\n\", a);\n\n}\n\nint main(void){\n\n\tfun(2);\n\n}\n~~~\n![23879c.png](https://miao.su/images/2019/07/18/23879c.png)\n\n---\n\n### 递归逆序打印链表(不改变数据位置)\n\n只要结点不为NULL，继续调用直到为空，此时执行的第一个打印是的链表最后的一个数据，再不断的返回直到反向打印完所有数据退出函数。\n~~~\nvoid ReservePrint_LinkList(struct LinkListNode* header) {\n\n\tif (NULL == header)\n\t\treturn;\n\n\tReservePrint_LinkList(header->next);\n\n\tprintf(\"%d \", header->data);\n\n}\n~~~\n\n---\n\n## 预处理\n\n### 文件包含指令#incude<>和#include\"\"区别\n\n- \"\" 表示系统先在file1.c所在的当前目录找file1.h，如果找不到，再按系统指定的目录检索。\n- < > 表示系统直接按系统指定的目录检索。\n\n注意：\n1. #include <>常用于包含库函数的头文件；\n2. #include \"\"常用于包含自定义的头文件；\n3. 理论上#include可以包含任意格式的文件(.c .h等) ，但一般用于头文件的包含；\n\n### 宏定义\n\n1.\t宏名一般用大写，以便于与变量区别；\n2.\t宏定义可以是常数、表达式等；\n3.\t**宏定义不作语法检查**，只有在编译被宏展开后的源程序才会报错；\n4.\t**宏定义不是C语言**，不在行末加分号；\n5.\t宏名有效范围为**从定义到本源文件结束**；\n6.\t可以用#undef命令终止宏定义的作用域；\n7.\t在宏定义中，可以引用已定义的宏名；\n8.  在预编译时将宏名替换成字符串的过程称为“宏展开”\n\n\n#### 一些特殊的预定宏\n\nC编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。\n\n~~~\n__FILE__\t    宏所在文件的源文件名 \n__LINE__\t    宏所在行的行号\n__DATE__\t    代码编译的日期\n__TIME__\t    代码编译的时间\n\nvoid test()\n{\n\tprintf(\"%s\\n\", __FILE__);\n\tprintf(\"%d\\n\", __LINE__);\n\tprintf(\"%s\\n\", __DATE__);\n\tprintf(\"%s\\n\", __TIME__);\n}\n~~~\n\n---\n\n## 静态库和动态库\n\n**库是已经写好的、成熟的、可复用的代码**。库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。\n\n感觉挺简单的，也就了解了一下静态库和动态库怎么创建和使用，我也就没有自己写了，偷了回懒。\n\n### 静态库的缺点\n>浪费空间，不方便更新和移植。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间。一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序。\n- 静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；\n- 程序在运行时与函数库再无瓜葛，移植方便。\n- 浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。\n\n### 动态链接的思想\n> 要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，**就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接**。也就是说，把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想。\n\n---\n\n## 面向接口编程\n\n案列比较简单，主要就是函数回调的思想，客户和企业沟通完接口后，根据接口所定义的参数和函数指针，分别开发业务代码和被调用的实现代码。\n\n> 模块要求松、接口要求紧。\n\n\nPS:天津今天下了点小雨，最近天气都很不好，每天都灰蒙蒙的挺压抑的。","slug":"2019-Holiday-Note-06","published":1,"updated":"2019-07-18T09:59:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihg000esmjblpy5gh32","content":"<h1 id=\"Holiday-Note-05\"><a href=\"#Holiday-Note-05\" class=\"headerlink\" title=\"Holiday Note_05\"></a>Holiday Note_05</h1><p>放假第六天。今天的内容内容不多，重点是<strong>链表反转</strong>，<strong>函数递归</strong>。然后就是简单了解了下<strong>预处理</strong>，<strong>静态库和动态库</strong>以及<strong>面向接口编程</strong>的内容了。</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"链表反转\"><a href=\"#链表反转\" class=\"headerlink\" title=\"链表反转\"></a>链表反转</h2><p>跟昨天重学链表一样，又是豁然开朗的感觉。之前看到链表反转的题目，想了半天做不出，看别人博客的解题思路还看不懂<strong>定义三指针</strong>的作用何在。其实三个指针就是记录位置，一个中间的用来判断是不是NULL，另外两个一前一后保证链表地址不丢失可以重新进行连接，画个图，把指针的指向画出来就明白为什么要三个指针了。</p>\n<p><img src=\"https://miao.su/images/2019/07/18/20180407202437512045a5.png\" alt=\"20180407202437512045a5.png\"></p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void <span class=\"built_in\">Reserve_LinkList</span>(struct LinkListNode* <span class=\"built_in\">header</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == <span class=\"built_in\">header</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//header是头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* pHead = <span class=\"built_in\">header</span>-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* pPrev = <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* pNext = <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pHead != <span class=\"built_in\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//记录下来后结点的地址</span></span><br><span class=\"line\">\t\tpNext = pHead-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">//该结点指向前结点，第一次执行是指向NULL</span></span><br><span class=\"line\">\t\tpHead-&gt;next = pPrev;</span><br><span class=\"line\">        <span class=\"comment\">//更新前结点指向的地址--&gt;</span></span><br><span class=\"line\">\t\tpPrev = pHead; </span><br><span class=\"line\">        <span class=\"comment\">//更新当前结点的地址 --&gt;</span></span><br><span class=\"line\">\t\tpHead = pNext;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//当前 结点指向空时退出循环，此时 前 结点指向的是该链表的最后一个结点</span></span><br><span class=\"line\">\t<span class=\"built_in\">header</span>-&gt;next = pPrev;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"函数递归\"><a href=\"#函数递归\" class=\"headerlink\" title=\"函数递归\"></a>函数递归</h2><p>C通过运行时<strong>堆栈</strong>来支持递归函数的实现。递归函数就是直接或间接调用自身的函数。若递归没有退出条件则会使得栈移除从而程序挂掉。因此<strong>写递归最重要的就是设置退出条件！</strong></p>\n<h3 id=\"普通函数调用\"><a href=\"#普通函数调用\" class=\"headerlink\" title=\"普通函数调用\"></a>普通函数调用</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funB</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"b = %d\\n\"</span>, b);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funA</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunB(a - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a = %d\\n\"</span>, a);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunA(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://miao.su/images/2019/07/18/142374.png\" alt=\"142374.png\"></p>\n<hr>\n<h3 id=\"递归函数调用\"><a href=\"#递归函数调用\" class=\"headerlink\" title=\"递归函数调用\"></a>递归函数调用</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void <span class=\"function\"><span class=\"title\">fun</span><span class=\"params\">(int a)</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tprintf(<span class=\"string\">\"a = %d\\n\"</span>, a);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>; <span class=\"comment\">//中断函数很重要</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">fun</span><span class=\"params\">(a - <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"a = %d\\n\"</span>, a);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">fun</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://miao.su/images/2019/07/18/23879c.png\" alt=\"23879c.png\"></p>\n<hr>\n<h3 id=\"递归逆序打印链表-不改变数据位置\"><a href=\"#递归逆序打印链表-不改变数据位置\" class=\"headerlink\" title=\"递归逆序打印链表(不改变数据位置)\"></a>递归逆序打印链表(不改变数据位置)</h3><p>只要结点不为NULL，继续调用直到为空，此时执行的第一个打印是的链表最后的一个数据，再不断的返回直到反向打印完所有数据退出函数。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">void</span> ReservePrint_LinkList(struct LinkListNode* <span class=\"keyword\">header</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">NULL</span> == <span class=\"keyword\">header</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tReservePrint_LinkList(<span class=\"keyword\">header</span>-&gt;next);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"%d \"</span>, <span class=\"keyword\">header</span>-&gt;<span class=\"built_in\">data</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h2><h3 id=\"文件包含指令-incude-lt-gt-和-include””区别\"><a href=\"#文件包含指令-incude-lt-gt-和-include””区别\" class=\"headerlink\" title=\"文件包含指令#incude&lt;&gt;和#include””区别\"></a>文件包含指令#incude&lt;&gt;和#include””区别</h3><ul>\n<li>“” 表示系统先在file1.c所在的当前目录找file1.h，如果找不到，再按系统指定的目录检索。</li>\n<li>&lt; &gt; 表示系统直接按系统指定的目录检索。</li>\n</ul>\n<p>注意：</p>\n<ol>\n<li>#include &lt;&gt;常用于包含库函数的头文件；</li>\n<li>#include “”常用于包含自定义的头文件；</li>\n<li>理论上#include可以包含任意格式的文件(.c .h等) ，但一般用于头文件的包含；</li>\n</ol>\n<h3 id=\"宏定义\"><a href=\"#宏定义\" class=\"headerlink\" title=\"宏定义\"></a>宏定义</h3><ol>\n<li>宏名一般用大写，以便于与变量区别；</li>\n<li>宏定义可以是常数、表达式等；</li>\n<li><strong>宏定义不作语法检查</strong>，只有在编译被宏展开后的源程序才会报错；</li>\n<li><strong>宏定义不是C语言</strong>，不在行末加分号；</li>\n<li>宏名有效范围为<strong>从定义到本源文件结束</strong>；</li>\n<li>可以用#undef命令终止宏定义的作用域；</li>\n<li>在宏定义中，可以引用已定义的宏名；</li>\n<li>在预编译时将宏名替换成字符串的过程称为“宏展开”</li>\n</ol>\n<h4 id=\"一些特殊的预定宏\"><a href=\"#一些特殊的预定宏\" class=\"headerlink\" title=\"一些特殊的预定宏\"></a>一些特殊的预定宏</h4><p>C编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。</p>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">__FILE__</span>\t    宏所在文件的源文件名 </span><br><span class=\"line\"><span class=\"keyword\">__LINE__</span>\t    宏所在行的行号</span><br><span class=\"line\"><span class=\"keyword\">__DATE__</span>\t    代码编译的日期</span><br><span class=\"line\"><span class=\"keyword\">__TIME__</span>\t    代码编译的时间</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> test()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">__FILE__</span>);</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"%d\\n\"</span>, <span class=\"keyword\">__LINE__</span>);</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">__DATE__</span>);</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">__TIME__</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"静态库和动态库\"><a href=\"#静态库和动态库\" class=\"headerlink\" title=\"静态库和动态库\"></a>静态库和动态库</h2><p><strong>库是已经写好的、成熟的、可复用的代码</strong>。库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。</p>\n<p>感觉挺简单的，也就了解了一下静态库和动态库怎么创建和使用，我也就没有自己写了，偷了回懒。</p>\n<h3 id=\"静态库的缺点\"><a href=\"#静态库的缺点\" class=\"headerlink\" title=\"静态库的缺点\"></a>静态库的缺点</h3><blockquote>\n<p>浪费空间，不方便更新和移植。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间。一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序。</p>\n<ul>\n<li>静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；</li>\n<li>程序在运行时与函数库再无瓜葛，移植方便。</li>\n<li>浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li>\n</ul>\n</blockquote>\n<h3 id=\"动态链接的思想\"><a href=\"#动态链接的思想\" class=\"headerlink\" title=\"动态链接的思想\"></a>动态链接的思想</h3><blockquote>\n<p>要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，<strong>就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接</strong>。也就是说，把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想。</p>\n</blockquote>\n<hr>\n<h2 id=\"面向接口编程\"><a href=\"#面向接口编程\" class=\"headerlink\" title=\"面向接口编程\"></a>面向接口编程</h2><p>案列比较简单，主要就是函数回调的思想，客户和企业沟通完接口后，根据接口所定义的参数和函数指针，分别开发业务代码和被调用的实现代码。</p>\n<blockquote>\n<p>模块要求松、接口要求紧。</p>\n</blockquote>\n<p>PS:天津今天下了点小雨，最近天气都很不好，每天都灰蒙蒙的挺压抑的。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-05\"><a href=\"#Holiday-Note-05\" class=\"headerlink\" title=\"Holiday Note_05\"></a>Holiday Note_05</h1><p>放假第六天。今天的内容内容不多，重点是<strong>链表反转</strong>，<strong>函数递归</strong>。然后就是简单了解了下<strong>预处理</strong>，<strong>静态库和动态库</strong>以及<strong>面向接口编程</strong>的内容了。</p>","more":"<hr>\n<h2 id=\"链表反转\"><a href=\"#链表反转\" class=\"headerlink\" title=\"链表反转\"></a>链表反转</h2><p>跟昨天重学链表一样，又是豁然开朗的感觉。之前看到链表反转的题目，想了半天做不出，看别人博客的解题思路还看不懂<strong>定义三指针</strong>的作用何在。其实三个指针就是记录位置，一个中间的用来判断是不是NULL，另外两个一前一后保证链表地址不丢失可以重新进行连接，画个图，把指针的指向画出来就明白为什么要三个指针了。</p>\n<p><img src=\"https://miao.su/images/2019/07/18/20180407202437512045a5.png\" alt=\"20180407202437512045a5.png\"></p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void <span class=\"built_in\">Reserve_LinkList</span>(struct LinkListNode* <span class=\"built_in\">header</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == <span class=\"built_in\">header</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//header是头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* pHead = <span class=\"built_in\">header</span>-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* pPrev = <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"type\">LinkListNode</span>* pNext = <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pHead != <span class=\"built_in\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//记录下来后结点的地址</span></span><br><span class=\"line\">\t\tpNext = pHead-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">//该结点指向前结点，第一次执行是指向NULL</span></span><br><span class=\"line\">\t\tpHead-&gt;next = pPrev;</span><br><span class=\"line\">        <span class=\"comment\">//更新前结点指向的地址--&gt;</span></span><br><span class=\"line\">\t\tpPrev = pHead; </span><br><span class=\"line\">        <span class=\"comment\">//更新当前结点的地址 --&gt;</span></span><br><span class=\"line\">\t\tpHead = pNext;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//当前 结点指向空时退出循环，此时 前 结点指向的是该链表的最后一个结点</span></span><br><span class=\"line\">\t<span class=\"built_in\">header</span>-&gt;next = pPrev;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"函数递归\"><a href=\"#函数递归\" class=\"headerlink\" title=\"函数递归\"></a>函数递归</h2><p>C通过运行时<strong>堆栈</strong>来支持递归函数的实现。递归函数就是直接或间接调用自身的函数。若递归没有退出条件则会使得栈移除从而程序挂掉。因此<strong>写递归最重要的就是设置退出条件！</strong></p>\n<h3 id=\"普通函数调用\"><a href=\"#普通函数调用\" class=\"headerlink\" title=\"普通函数调用\"></a>普通函数调用</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funB</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"b = %d\\n\"</span>, b);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funA</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunB(a - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a = %d\\n\"</span>, a);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfunA(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://miao.su/images/2019/07/18/142374.png\" alt=\"142374.png\"></p>\n<hr>\n<h3 id=\"递归函数调用\"><a href=\"#递归函数调用\" class=\"headerlink\" title=\"递归函数调用\"></a>递归函数调用</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void <span class=\"function\"><span class=\"title\">fun</span><span class=\"params\">(int a)</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tprintf(<span class=\"string\">\"a = %d\\n\"</span>, a);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>; <span class=\"comment\">//中断函数很重要</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">fun</span><span class=\"params\">(a - <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"a = %d\\n\"</span>, a);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">fun</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://miao.su/images/2019/07/18/23879c.png\" alt=\"23879c.png\"></p>\n<hr>\n<h3 id=\"递归逆序打印链表-不改变数据位置\"><a href=\"#递归逆序打印链表-不改变数据位置\" class=\"headerlink\" title=\"递归逆序打印链表(不改变数据位置)\"></a>递归逆序打印链表(不改变数据位置)</h3><p>只要结点不为NULL，继续调用直到为空，此时执行的第一个打印是的链表最后的一个数据，再不断的返回直到反向打印完所有数据退出函数。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">void</span> ReservePrint_LinkList(struct LinkListNode* <span class=\"keyword\">header</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">NULL</span> == <span class=\"keyword\">header</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tReservePrint_LinkList(<span class=\"keyword\">header</span>-&gt;next);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"%d \"</span>, <span class=\"keyword\">header</span>-&gt;<span class=\"built_in\">data</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h2><h3 id=\"文件包含指令-incude-lt-gt-和-include””区别\"><a href=\"#文件包含指令-incude-lt-gt-和-include””区别\" class=\"headerlink\" title=\"文件包含指令#incude&lt;&gt;和#include””区别\"></a>文件包含指令#incude&lt;&gt;和#include””区别</h3><ul>\n<li>“” 表示系统先在file1.c所在的当前目录找file1.h，如果找不到，再按系统指定的目录检索。</li>\n<li>&lt; &gt; 表示系统直接按系统指定的目录检索。</li>\n</ul>\n<p>注意：</p>\n<ol>\n<li>#include &lt;&gt;常用于包含库函数的头文件；</li>\n<li>#include “”常用于包含自定义的头文件；</li>\n<li>理论上#include可以包含任意格式的文件(.c .h等) ，但一般用于头文件的包含；</li>\n</ol>\n<h3 id=\"宏定义\"><a href=\"#宏定义\" class=\"headerlink\" title=\"宏定义\"></a>宏定义</h3><ol>\n<li>宏名一般用大写，以便于与变量区别；</li>\n<li>宏定义可以是常数、表达式等；</li>\n<li><strong>宏定义不作语法检查</strong>，只有在编译被宏展开后的源程序才会报错；</li>\n<li><strong>宏定义不是C语言</strong>，不在行末加分号；</li>\n<li>宏名有效范围为<strong>从定义到本源文件结束</strong>；</li>\n<li>可以用#undef命令终止宏定义的作用域；</li>\n<li>在宏定义中，可以引用已定义的宏名；</li>\n<li>在预编译时将宏名替换成字符串的过程称为“宏展开”</li>\n</ol>\n<h4 id=\"一些特殊的预定宏\"><a href=\"#一些特殊的预定宏\" class=\"headerlink\" title=\"一些特殊的预定宏\"></a>一些特殊的预定宏</h4><p>C编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。</p>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">__FILE__</span>\t    宏所在文件的源文件名 </span><br><span class=\"line\"><span class=\"keyword\">__LINE__</span>\t    宏所在行的行号</span><br><span class=\"line\"><span class=\"keyword\">__DATE__</span>\t    代码编译的日期</span><br><span class=\"line\"><span class=\"keyword\">__TIME__</span>\t    代码编译的时间</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> test()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">__FILE__</span>);</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"%d\\n\"</span>, <span class=\"keyword\">__LINE__</span>);</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">__DATE__</span>);</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">__TIME__</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"静态库和动态库\"><a href=\"#静态库和动态库\" class=\"headerlink\" title=\"静态库和动态库\"></a>静态库和动态库</h2><p><strong>库是已经写好的、成熟的、可复用的代码</strong>。库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。</p>\n<p>感觉挺简单的，也就了解了一下静态库和动态库怎么创建和使用，我也就没有自己写了，偷了回懒。</p>\n<h3 id=\"静态库的缺点\"><a href=\"#静态库的缺点\" class=\"headerlink\" title=\"静态库的缺点\"></a>静态库的缺点</h3><blockquote>\n<p>浪费空间，不方便更新和移植。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间。一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序。</p>\n<ul>\n<li>静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；</li>\n<li>程序在运行时与函数库再无瓜葛，移植方便。</li>\n<li>浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li>\n</ul>\n</blockquote>\n<h3 id=\"动态链接的思想\"><a href=\"#动态链接的思想\" class=\"headerlink\" title=\"动态链接的思想\"></a>动态链接的思想</h3><blockquote>\n<p>要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，<strong>就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接</strong>。也就是说，把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想。</p>\n</blockquote>\n<hr>\n<h2 id=\"面向接口编程\"><a href=\"#面向接口编程\" class=\"headerlink\" title=\"面向接口编程\"></a>面向接口编程</h2><p>案列比较简单，主要就是函数回调的思想，客户和企业沟通完接口后，根据接口所定义的参数和函数指针，分别开发业务代码和被调用的实现代码。</p>\n<blockquote>\n<p>模块要求松、接口要求紧。</p>\n</blockquote>\n<p>PS:天津今天下了点小雨，最近天气都很不好，每天都灰蒙蒙的挺压抑的。</p>"},{"title":"Holiday Note_07","date":"2019-07-19T12:07:00.000Z","_content":"\n# Holiday Note_07\n\n一周了。今天接触了**动态数组**，挺简单的，主要考虑的应该是每一次增加的空间大小的逻辑。又学习了另外一种结构的**单向链表**，也就是额外用一个链表结构去嵌套结点结构的设计。最重要的学习了**封装**的方式去实现对数据结构的操作，不再返回链表的指针，而是使用万能指针避免使用者进行操作数据结构时对数据进行修改；并且广泛使用**回调函数**增加了数据结构的复用性。随着使用回调函数的次数增多，也逐渐开始体会到了封装所带来的便利了，理解这一部分尤其重要。对于**单向链表各个函数定义的参数那部分一定要读懂其设置的含义**。\n\n<!-- more -->\n---\n\n## 动态数组\n\n第一次接触动态数组，听名字DynamicArray感觉很厉害，其实实现起来，和普通的数组结构差不多，主要有三个成员，分别是**数组空间首地址(二维指针)，容量大小，当前大小**，唯一不同的就是判断空间不足时需要再分配一块新空间，再将原空间的数据拷贝过去。\n\n### 动态数组头文件\n~~~\nstruct DynamicArray {\n\n\t//数组存储元素的空间的首地址\n\tvoid** addr;\n\n\t//数组能够在内存中存取的最大元素的个数\n\tint capacity;\n\n\t//当前存储数据的内存中一共有多少个元素\n\tint size;\n\n};\n\n//初始化数组\nstruct DynamicArray* Init_DynamicArray(int capacity);\n\n//插入元素\nvoid Insert_DynamicArray(struct DynamicArray* arr, int pos, void* data);\n\n//按位置删除\nvoid DeleteByPos_DynamicArray(struct DynamicArray* arr, int pos);\n\n//按值删除\nvoid DeleteByValue_DynamicArray(struct DynamicArray* arr, void* delData, int(*CompareCallback)(void*, void*));\n\n//遍历数组\nvoid Foreach_DynamicArray(struct DynamicArray* arr, void(*_callback)(void*));\n\n//销毁数组\nvoid Destroy_DynamicArray(struct DynamicArray* arr);\n~~~\n\n---\n\n### 动态数组实现文件\n#### 初始化数组\n~~~\nstruct DynamicArray* Init_DynamicArray(int capacity) {\n\n\tif (capacity <= 0) {\n\t\treturn NULL;\n\t}\n\n\tstruct DynamicArray* arr = malloc(sizeof(struct DynamicArray));\n\n\tif (NULL == arr) {\n\t\treturn NULL;\n\t}\n\n\tarr->addr = malloc(sizeof(void*) * capacity);\n\n\tarr->capacity = capacity;\n\n\tarr->size = 0;\n\n\treturn arr;\n\n}\n~~~\n\n#### 插入元素(重点，需要判断空间是否足够集进行**分配空间**，**拷贝数据**，**释放原空间**操作)\n~~~\nvoid Insert_DynamicArray(struct DynamicArray* arr, int pos, void* data) {\n\n\tif (NULL == arr) {\n\t\treturn;\n\t}\n\n\tif (NULL == data) {\n\t\treturn;\n\t}\n\n\t//传入的位置不管是小于0还是大于容量，都让插入的位置为最后一个，因为数组元素间不能不连续\n\tif (pos < 0 || pos >= arr->capacity) {\n\n\t\tpos = arr->size;\n\n\t}\n\n\t//当存储的数据个数已经等于容量时，需要增长数组空间\n\tif (arr->size >= arr->capacity) {\n\n\t\t//分配更大的内存空间，暂时不考虑增长策略，默认直接翻倍\n\t\tint newCapacity = arr->capacity * 2;\n\t\tvoid** newAddr = malloc(sizeof(void*) * newCapacity);\n\n\t\t//将原空间的数据拷贝至新分配的空间中\n\t\tmemcpy(newAddr, arr->addr, sizeof(void*) * arr->size);\n\n\t\t//释放原空间内存\n\t\tfree(arr->addr);\n\n\t\t//更新数组的指向以及容量\n\t\tarr->addr = newAddr;\n\t\tarr->capacity = newCapacity;\n\t}\n\n    //为要插入的元素腾出空间\n\tfor (int i = arr->size - 1; i >= pos; --i) {\n\n\t\tarr->addr[i + 1] = arr->addr[i];\n\n\t}\n\n\t//将元素插入并且更新数组存储数据个数\n\tarr->addr[pos] = data;\n\tarr->size++;\n\n}\n~~~\n\n#### 按位置删除\n功能不够完善，当*删除最后一个元素时*，即pos == size-1的情况时，并未进入循环，而是直接size--，实际该元素仍然存在，在测试文件中，我仍可以将依旧删除的最后一个元素进行打印输出。\n~~~\nvoid DeleteByPos_DynamicArray(struct DynamicArray* arr, int pos) {\n\n\tif (NULL == arr) {\n\t\treturn;\n\t}\n\n\tif (pos < 0 || pos > arr->size - 1) {\n\t\treturn;\n\t}\n\n\t//！！！！！\n\t//当删除最后一个元素时，即pos == size-1的情况时，并未进入循环，而是直接size--，实际该元素仍然存在\n\tfor (int i = pos; i < arr->size - 1; ++i) {\n\n\t\tarr->addr[i] = arr->addr[i + 1];\n\n\t}\n\n\tarr->size--;\n\n}\n~~~\n\n#### 按值删除\n使用了回调函数对数据进行比对操作，传递数据地址和需要删除的值的指针，用户根据不同数据类型编写对应的比对函数。\n~~~\nvoid DeleteByValue_DynamicArray(struct DynamicArray* arr, void* delData, int(*CompareCallback)(void*, void*)) {\n\n\tif (NULL == arr) {\n\t\treturn;\n\t}\n\n\tif (NULL == delData) {\n\t\treturn;\n\t}\n\n\tif (NULL == CompareCallback) {\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < arr->size; ++i) {\n\n\t\tif (CompareCallback(arr->addr[i], delData)) {\n\n\t\t\tDeleteByPos_DynamicArray(arr, i);\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n~~~\n\n#### 遍历数组\n同样使用了回调函数\n~~~\nvoid Foreach_DynamicArray(struct DynamicArray* arr, void(*_callback)(void*)) {\n\n\tif (NULL == arr)\n\t\treturn;\n\n\tfor (int i = 0; i < arr->size; ++i) {\n\n\t\t_callback(arr->addr[i]);\n\n\t}\n\n}\n~~~\n\n#### 销毁数组\n~~~\nvoid Destroy_DynamicArray(struct DynamicArray* arr) {\n\n\tif (NULL == arr) {\n\t\treturn;\n\t}\n\n\tif (arr->addr != NULL) {\n\t\tfree(arr->addr);\n\t\tarr->addr = NULL;\n\t}\n\n\tfree(arr);\n\tarr = NULL;\n\n}\n~~~\n\n---\n\n### 动态数组测试文件\n定义一个结构体数组，调用动态数组进行存储并操作，测试文件需要根据定义的数据类型编写对应回调函数才能调用写好的数据结构操作数据，注意看最后的将删除元素打印步骤。\n~~~\nstruct Person {\n\tchar name[64];\n\tint age;\n};\n\n//遍历回调函数\nvoid myPrint(void* data) {\n\n\tstruct Person* arrayData = (struct Person*)data;\n\tprintf(\"name: %s age: %d\\n\", arrayData->name, arrayData->age);\n\n}\n\n//比较回调函数\nint myCompare(void* arrData, void* delData) {\n\n\tif (NULL == arrData) {\n\t\treturn 0;\n\t}\n\n\tif (NULL == delData) {\n\t\treturn 0;\n\t}\n\n\tstruct Person* ArrData = (struct Person*)arrData;\n\tstruct Person* DelData = (struct Person*)delData;\n\n\treturn (strcmp(ArrData->name, DelData->name) == 0) && (ArrData->age == DelData->age);\n\n}\n\nvoid test() {\n\n\tstruct Person person1 = { \"aaa\",10 };\n\tstruct Person person2 = { \"bbb\",20 };\n\tstruct Person person3 = { \"ccc\",30 };\n\tstruct Person person4 = { \"ddd\",40 };\n\tstruct Person person5 = { \"eee\",50 };\n\n\tstruct Person person6 = { \"fff\",60 };\n\n\t// 初始化一个容量只有5的动态数组\n\tstruct DynamicArray * testArray= Init_DynamicArray(5);\n\n\tInsert_DynamicArray(testArray, 0, &person1);\n\tInsert_DynamicArray(testArray, 0, &person2);\n\tInsert_DynamicArray(testArray, 0, &person3);\n\tInsert_DynamicArray(testArray, 1, &person4);\n\tInsert_DynamicArray(testArray, 1, &person5);\n\n\tprintf(\"当前数组的容量为 %d \\n\", testArray->capacity);\n\n\t//插入六个数据检测是否实现容量增长\n\tInsert_DynamicArray(testArray, 666, &person6);\n\n\tprintf(\"此时数组的容量为 %d \\n\", testArray->capacity);\n\n\tForeach_DynamicArray(testArray, myPrint);// 3 5 4 2 1 6\n\n\tDeleteByPos_DynamicArray(testArray, 5);\n\n\tprintf(\"------按位置删除-----\\n\");\n\n\tForeach_DynamicArray(testArray,myPrint);// 3 5 4 2 1\n\n\tstruct Person pTest = { \"aaa\", 10 };\n\tDeleteByValue_DynamicArray(testArray, &pTest, myCompare);\n\n\tprintf(\"-------按值删除------\\n\");\n\n\tForeach_DynamicArray(testArray, myPrint);//3 5 4 2\n\n\n\tprintf(\"----\\n\");\n\n\t//按值删除的内部由于调用了按位置删除的函数，因此，对数组当前最后一个元素进行删除时依旧存在没有真正删除的问题\n\t//因为按位置删除对最后一个元素的删除时，并未采取清除或替换操作，仅仅是进行了size--操作，因此可以通过直接访问该元素地址进行输出\n\tprintf(\"第五个元素并未删除 name: %s age: %d\\n\", ((struct Person*)testArray->addr[4])->name, ((struct Person*)testArray->addr[4])->age);\n\tprintf(\"第六个元素并未删除 name: %s age: %d\\n\", ((struct Person*)testArray->addr[5])->name, ((struct Person*)testArray->addr[5])->age);\n\n\tDestroy_DynamicArray(testArray);\n\n}\n\n\nint main() {\n\ttest();\n}\n~~~\n测试输入如下：\n![699829f16d3528ced1cf85eeff57238906a5.png](https://miao.su/images/2019/07/19/699829f16d3528ced1cf85eeff57238906a5.png)\n\n## 单向链表\n与之前写的链表不同的是，这次定义了**两个结构体**，一个是*结点结构*，一个是*链表结构*，其中链表结构嵌套了结点结构，存放了**链表的头结点**，**结点个数**。后期可以根据需要加入类似**尾指针**，让尾插法更加高效的操作链表的一系列成员。\n\n还有一点就是，**封装的思想**。之前写的链表，初始化传递回去的直接就是一个*指向数据结构首地址的数据结构类型指针*，虽然这样可以更加方便操作数据结构，但不加以约束的会带来许多**弊端**：拿到指针后可以随意修改数据，还可以对数据进行清空。\n\n因此这次在实现单向链表时，**初始化数据结构**后传递回去的是一个**万能指针类型**，这样用户在得到该指针后，只能使用这个指针调用我们数据结构已经写好的功能，比如获取结点个数等之前可以直接通过指针操作获取的数据。\n\n在写数据结构的过程中，由于传递的是万能指针类型，所以实现各个功能都需要进行强转万能指针对数据结构进行操作，因为是自己实现数据结构，知道数据结构的类型因此可以通过强转进行操作，而用户则不能进行这种操作。\n\n而且封装的思想还体现在了**插入数据**时接收数据的形参也是万能指针，即我们写数据结构时无需考虑用户传递的数据类型，当实现遍历打印，按值删除这些需要**明确清楚数据类型的功能**时，在函数的形参中使用**函数指针**，这些**回调函数**均由用户去实现，我们的函数指针指向用户写好的回调函数后，根据返回值便可以对数据进行上述功能的实现了。\n\n### 单向链表头文件\n**这部分是重点！！！**\n\n增加了使用typedef给万能指针，函数指针重新命名的操作，目的是增加程序的可读性。而且不在头文件中定义数据结构了而是放到了实现文件中，也是封装的思想，**让用户看到更少的细节**，仅需要注重调用功能的实现。\n~~~\n//使用void*保护链表\n\ttypedef void* LList;\n\ttypedef void(*FOREACH)(void* );\n\ttypedef int(*COMPARE)(void*, void*);\n\n\t//初始化链表，不再返回指向链表指针类型\n\tLList Init_LinkList();\n\n\t//插入结点\n\tvoid Insert_LinkList(LList list, int pos, void* data);\n\n\t//遍历链表\n\tvoid ForEach_LinkList(LList list, FOREACH myfoeach);\n\n\t//按位置删除结点\n\tvoid DeleteByPos_LinkList(LList list, int pos);\n\n\t//按值删除结点\n\tvoid DeleteByValue_LinkList(LList list, void* data, COMPARE compare);\n\n\t//链表大小\n\tint Size_LinkList(LList list);\n\n\t//清空链表\n\tvoid Clear_LinkList(LList list);\n\n\t//销毁链表\n\tvoid Destroy_LinkList(LList list);\n~~~\n\n---\n\n### 单向链表实现文件\n#### 单向链表数据结构的定义\n\n~~~\n// 结点数据类型\nstruct LinkNode {\n\tvoid* data;\n\tstruct LinkNode* next;\n};\n\n// 链表数据类型\nstruct LinkList {\n\tstruct LinkNode header;\n\tint size;\n};\n~~~\n\n\n#### 初始化链表，不再返回指向链表指针类型\n~~~\nLList Init_LinkList() {\n\n\tstruct LinkList* list = malloc(sizeof(struct LinkList));\n\n\tif (NULL == list) {\n\t\treturn NULL;\n\t}\n\n\tlist->header.next = NULL;\n\tlist->header.data = NULL;\n\tlist->size = 0;\n\n\treturn list;\n\n}\n~~~\n\n\n\n#### 插入结点(比较重要)\n中间有两条语句是插入结点后重新连接链表的操作，因为没画图，就脑子想了想，结果debug了一个半小时，差点崩溃了，所以数据结构画图很重要啊！！\n~~~\nvoid Insert_LinkList(LList list, int pos, void* data) {\n\n\tif (NULL == list) {\n\t\treturn;\n\t}\n\n\tif (NULL == data) {\n\t\treturn;\n\t}\n\n\t//传入的list是void*类型，需要进行强转\n\tstruct LinkList* myList = (struct LinkList*)list;\n\n\tif (pos < 0 || pos > myList->size) {\n\n\t\tpos = myList->size;\n\n\t}\n\n\t//查找插入位置的前一个结点(重点！)\n\tstruct LinkNode* pCurrent = &(myList->header);\n\tfor (int i = 0; i < pos; ++i) {\n\n\t\tpCurrent = pCurrent->next;\n\n\t}\n\n\tstruct LinkNode* newNode = malloc(sizeof(struct LinkNode));\n\tnewNode->next = NULL;\n\tnewNode->data = data;\n\n\t// 插入结点，两条语句的先后顺序很关键，画图！！！再写\n\tnewNode->next = pCurrent->next;\n\tpCurrent->next = newNode;\n\n\tmyList->size++;\n\n}\n~~~\n\n#### 遍历链表\n\n~~~\nvoid ForEach_LinkList(LList list, FOREACH myfoeach) {\n\n\tif (NULL == list) {\n\t\treturn;\n\t}\n\n\tif(NULL == myfoeach) {\n\t\treturn;\n\t}\n\n\t//传入的list是void*类型，需要进行强转\n\tstruct LinkList* myList = (struct Links*)list;\n\n\tstruct LinkNode* pCurrent = myList->header.next;\n\t\n\twhile (pCurrent != NULL) {\n\t\tmyfoeach(pCurrent->data);\n\t\tpCurrent = pCurrent->next;\n\t}\n\n}\n~~~\n\n\n\n#### 按位置删除结点\n~~~\nvoid DeleteByPos_LinkList(LList list, int pos) {\n\n\tif (NULL == list) {\n\t\treturn;\n\t}\n\n\tstruct LinkList* myList = (struct LinkList*)list;\n\n\tif (pos < 0 || pos > myList->size) {\n\t\treturn;\n\t}\n\n\t// 重点理解以下的pCurrent指针和for循环功能\n\tstruct LinkNode* pCurrent = &(myList->header);\n\n\t//找到要删除的结点的前一个结点位置\n\tfor (int i = 0; i < pos; ++i) {\n\n\t\tpCurrent = pCurrent->next;\n\n\t}\n\n\t//将被删除结点的前驱结点和后继结点进行连接\n\tstruct LinkNode* pDel = pCurrent->next;\n\tpCurrent->next = pDel->next;\n\n\tfree(pDel);\n\tpDel = NULL;\n\n\tmyList->size--;\n\n}\n~~~\n\n\n\n#### 按值删除结点(比较重要)\n~~~\nvoid DeleteByValue_LinkList(LList list, void* data, COMPARE compare) {\n\n\tif (NULL == list)\n\t{\n\t\treturn;\n\t}\n\n\tif (NULL == data) {\n\t\treturn;\n\t}\n\n\tif (NULL == compare) {\n\t\treturn;\n\t}\n\n\tstruct LinkList* myList = (struct LinkList*)list;\n\n\t//两个辅助指针变量\n\tstruct LinkNode* pPre = &(myList->header);\n\tstruct LinkNode* pCurrent = myList->header.next;\n\n\twhile (pCurrent != NULL) {\n\t\t\n\t\tif (compare(pCurrent->data, data)) {\n\t\t\t// 找到要删除的结点\n\t\t\tpPre->next = pCurrent->next;\t\t\n\t\t\tbreak;\n\t\t}\n\t\tpPre = pCurrent;\n\t\tpCurrent = pCurrent->next;\n\t}\n\n\t//释放被删除的结点\n\tfree(pCurrent);\n\tpCurrent = NULL;\n\n\tmyList->size--;\n\n}\n~~~\n\n#### 链表大小\n~~~\nint Size_LinkList(LList list) {\n\n\tif (NULL == list) {\n\t\treturn -1;\n\t}\n\t\n\tstruct LinkList* myList = (struct LinkList*)list;\n\n\treturn myList->size;\n\n}\n~~~\n\n#### 清空链表\n~~~\nvoid Clear_LinkList(LList list) {\n\n\tif (NULL == list) {\n\t\treturn;\n\t}\n\n\tstruct LinkList* myList = (struct LinkList*)list;\n\n\tstruct LinkNode* pCurrent = myList->header.next;\n\n\twhile (pCurrent != NULL) {\n\t\t\n\t\t//先记录下一个结点的地址\n\t\tstruct LinkNode* pNext = pCurrent->next;\n\t\t//释放当前结点的空间\n\t\tfree(pCurrent);\n\t\tpCurrent = pNext;\n\n\t}\n\n\tmyList->header.next = NULL;\n\n\t//将链表大小置为0\n\tmyList->size = 0;\n\n}\n~~~\n\n#### 销毁链表\n~~~\nvoid Destroy_LinkList(LList list) {\n\n\tif (NULL == list) {\n\t\treturn;\n\t}\n\n\tClear_LinkList(list);\n\n\tfree(list);\n\tlist = NULL;\n\n}\n~~~\n\n\n\n#### 我认为比较重要的一个循环\n在插入和按位置删除结点都使用了这个循环，用途是找到**需要操作的结点的前一个结点**。\n~~~\nstruct LinkNode* pCurrent = &(myList->header);\nfor (int i = 0; i < pos; ++i) {\n\n    pCurrent = pCurrent->next;\n    \n}\n~~~\n\n### 单向链表测试文件\n~~~\nstruct Person {\n\tchar name[64];\n\tint age;\n};\n\n//用于对链表遍历的数据进行转换\nvoid myPrint(void* data) {\n\n\tstruct Person* Data = (struct Person*)data;\n\tprintf(\"name: %s age: %d\\n\", Data->name, Data->age);\n\n}\n\n//用于对按值删除的数据进行比较\nint myCompare(void* pre, void* cur) {\n\n\tstruct Person* p1 = (struct Person*)pre;\n\tstruct Person* p2 = (struct Person*)cur;\n\n\treturn (strcmp(p1->name, p2->name) == 0) && (p1->age == p2->age);\n\n}\n\nvoid test() {\n\n\tstruct Person p1 = { \"aa\",1 };\n\tstruct Person p2 = { \"bb\",2 };\n\tstruct Person p3 = { \"cc\",3 };\n\tstruct Person p4 = { \"dd\",4 };\n\tstruct Person p5 = { \"ee\",5 };\n\tstruct Person p6 = { \"ff\",6 };\n\tstruct Person p7 = { \"gg\",7 };\n\n\t//初始化链表\n\tLList testList = Init_LinkList();\n\n\t// 插入数据\n\tInsert_LinkList(testList, 0, &p1);\n\tInsert_LinkList(testList, 1, &p2);\n\tInsert_LinkList(testList, 2, &p3);\n\tInsert_LinkList(testList, 3, &p4);\n\tInsert_LinkList(testList, 4, &p5);\n\tInsert_LinkList(testList, 5, &p6);\n\tInsert_LinkList(testList, 6, &p7);\n\n\tprintf(\"链表大小初始为 %d \\n\", Size_LinkList(testList));\n\n\tForEach_LinkList(testList, myPrint);\n\tprintf(\"-----------------\\n\");\n\n\t//按位置删除\n\tDeleteByPos_LinkList(testList, 1);\n\n\tForEach_LinkList(testList, myPrint);\n\tprintf(\"-----------------\\n\");\n\n\t//按值删除\n\tstruct Person testDel = { \"gg\", 7};\n\tDeleteByValue_LinkList(testList, &testDel, myCompare);\n\n\n\tForEach_LinkList(testList, myPrint);\n\tprintf(\"-----------------\\n\");\n\n\tprintf(\"链表大小为 %d \\n\", Size_LinkList(testList));\n\n\t//清空链表\n\tClear_LinkList(testList);\n\n\tprintf(\"清空后链表大小为 %d \\n\", Size_LinkList(testList));\n\n\t//销毁链表\n\tDestroy_LinkList(testList);\n\n}\n\nint main() {\n\ttest();\n}\n~~~\n测试输出如下：\n![6607952a5f706902e176b84c1cbcca38405c.png](https://miao.su/images/2019/07/19/6607952a5f706902e176b84c1cbcca38405c.png)\nPS:一周了，多写一篇周记吧。","source":"_posts/2019-Holiday-Note-07.md","raw":"---\ntitle: Holiday Note_07\ndate: 2019-07-19 20:07:00\ncategories: C\ntags: [Note,C,DataStructure]\n---\n\n# Holiday Note_07\n\n一周了。今天接触了**动态数组**，挺简单的，主要考虑的应该是每一次增加的空间大小的逻辑。又学习了另外一种结构的**单向链表**，也就是额外用一个链表结构去嵌套结点结构的设计。最重要的学习了**封装**的方式去实现对数据结构的操作，不再返回链表的指针，而是使用万能指针避免使用者进行操作数据结构时对数据进行修改；并且广泛使用**回调函数**增加了数据结构的复用性。随着使用回调函数的次数增多，也逐渐开始体会到了封装所带来的便利了，理解这一部分尤其重要。对于**单向链表各个函数定义的参数那部分一定要读懂其设置的含义**。\n\n<!-- more -->\n---\n\n## 动态数组\n\n第一次接触动态数组，听名字DynamicArray感觉很厉害，其实实现起来，和普通的数组结构差不多，主要有三个成员，分别是**数组空间首地址(二维指针)，容量大小，当前大小**，唯一不同的就是判断空间不足时需要再分配一块新空间，再将原空间的数据拷贝过去。\n\n### 动态数组头文件\n~~~\nstruct DynamicArray {\n\n\t//数组存储元素的空间的首地址\n\tvoid** addr;\n\n\t//数组能够在内存中存取的最大元素的个数\n\tint capacity;\n\n\t//当前存储数据的内存中一共有多少个元素\n\tint size;\n\n};\n\n//初始化数组\nstruct DynamicArray* Init_DynamicArray(int capacity);\n\n//插入元素\nvoid Insert_DynamicArray(struct DynamicArray* arr, int pos, void* data);\n\n//按位置删除\nvoid DeleteByPos_DynamicArray(struct DynamicArray* arr, int pos);\n\n//按值删除\nvoid DeleteByValue_DynamicArray(struct DynamicArray* arr, void* delData, int(*CompareCallback)(void*, void*));\n\n//遍历数组\nvoid Foreach_DynamicArray(struct DynamicArray* arr, void(*_callback)(void*));\n\n//销毁数组\nvoid Destroy_DynamicArray(struct DynamicArray* arr);\n~~~\n\n---\n\n### 动态数组实现文件\n#### 初始化数组\n~~~\nstruct DynamicArray* Init_DynamicArray(int capacity) {\n\n\tif (capacity <= 0) {\n\t\treturn NULL;\n\t}\n\n\tstruct DynamicArray* arr = malloc(sizeof(struct DynamicArray));\n\n\tif (NULL == arr) {\n\t\treturn NULL;\n\t}\n\n\tarr->addr = malloc(sizeof(void*) * capacity);\n\n\tarr->capacity = capacity;\n\n\tarr->size = 0;\n\n\treturn arr;\n\n}\n~~~\n\n#### 插入元素(重点，需要判断空间是否足够集进行**分配空间**，**拷贝数据**，**释放原空间**操作)\n~~~\nvoid Insert_DynamicArray(struct DynamicArray* arr, int pos, void* data) {\n\n\tif (NULL == arr) {\n\t\treturn;\n\t}\n\n\tif (NULL == data) {\n\t\treturn;\n\t}\n\n\t//传入的位置不管是小于0还是大于容量，都让插入的位置为最后一个，因为数组元素间不能不连续\n\tif (pos < 0 || pos >= arr->capacity) {\n\n\t\tpos = arr->size;\n\n\t}\n\n\t//当存储的数据个数已经等于容量时，需要增长数组空间\n\tif (arr->size >= arr->capacity) {\n\n\t\t//分配更大的内存空间，暂时不考虑增长策略，默认直接翻倍\n\t\tint newCapacity = arr->capacity * 2;\n\t\tvoid** newAddr = malloc(sizeof(void*) * newCapacity);\n\n\t\t//将原空间的数据拷贝至新分配的空间中\n\t\tmemcpy(newAddr, arr->addr, sizeof(void*) * arr->size);\n\n\t\t//释放原空间内存\n\t\tfree(arr->addr);\n\n\t\t//更新数组的指向以及容量\n\t\tarr->addr = newAddr;\n\t\tarr->capacity = newCapacity;\n\t}\n\n    //为要插入的元素腾出空间\n\tfor (int i = arr->size - 1; i >= pos; --i) {\n\n\t\tarr->addr[i + 1] = arr->addr[i];\n\n\t}\n\n\t//将元素插入并且更新数组存储数据个数\n\tarr->addr[pos] = data;\n\tarr->size++;\n\n}\n~~~\n\n#### 按位置删除\n功能不够完善，当*删除最后一个元素时*，即pos == size-1的情况时，并未进入循环，而是直接size--，实际该元素仍然存在，在测试文件中，我仍可以将依旧删除的最后一个元素进行打印输出。\n~~~\nvoid DeleteByPos_DynamicArray(struct DynamicArray* arr, int pos) {\n\n\tif (NULL == arr) {\n\t\treturn;\n\t}\n\n\tif (pos < 0 || pos > arr->size - 1) {\n\t\treturn;\n\t}\n\n\t//！！！！！\n\t//当删除最后一个元素时，即pos == size-1的情况时，并未进入循环，而是直接size--，实际该元素仍然存在\n\tfor (int i = pos; i < arr->size - 1; ++i) {\n\n\t\tarr->addr[i] = arr->addr[i + 1];\n\n\t}\n\n\tarr->size--;\n\n}\n~~~\n\n#### 按值删除\n使用了回调函数对数据进行比对操作，传递数据地址和需要删除的值的指针，用户根据不同数据类型编写对应的比对函数。\n~~~\nvoid DeleteByValue_DynamicArray(struct DynamicArray* arr, void* delData, int(*CompareCallback)(void*, void*)) {\n\n\tif (NULL == arr) {\n\t\treturn;\n\t}\n\n\tif (NULL == delData) {\n\t\treturn;\n\t}\n\n\tif (NULL == CompareCallback) {\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < arr->size; ++i) {\n\n\t\tif (CompareCallback(arr->addr[i], delData)) {\n\n\t\t\tDeleteByPos_DynamicArray(arr, i);\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n~~~\n\n#### 遍历数组\n同样使用了回调函数\n~~~\nvoid Foreach_DynamicArray(struct DynamicArray* arr, void(*_callback)(void*)) {\n\n\tif (NULL == arr)\n\t\treturn;\n\n\tfor (int i = 0; i < arr->size; ++i) {\n\n\t\t_callback(arr->addr[i]);\n\n\t}\n\n}\n~~~\n\n#### 销毁数组\n~~~\nvoid Destroy_DynamicArray(struct DynamicArray* arr) {\n\n\tif (NULL == arr) {\n\t\treturn;\n\t}\n\n\tif (arr->addr != NULL) {\n\t\tfree(arr->addr);\n\t\tarr->addr = NULL;\n\t}\n\n\tfree(arr);\n\tarr = NULL;\n\n}\n~~~\n\n---\n\n### 动态数组测试文件\n定义一个结构体数组，调用动态数组进行存储并操作，测试文件需要根据定义的数据类型编写对应回调函数才能调用写好的数据结构操作数据，注意看最后的将删除元素打印步骤。\n~~~\nstruct Person {\n\tchar name[64];\n\tint age;\n};\n\n//遍历回调函数\nvoid myPrint(void* data) {\n\n\tstruct Person* arrayData = (struct Person*)data;\n\tprintf(\"name: %s age: %d\\n\", arrayData->name, arrayData->age);\n\n}\n\n//比较回调函数\nint myCompare(void* arrData, void* delData) {\n\n\tif (NULL == arrData) {\n\t\treturn 0;\n\t}\n\n\tif (NULL == delData) {\n\t\treturn 0;\n\t}\n\n\tstruct Person* ArrData = (struct Person*)arrData;\n\tstruct Person* DelData = (struct Person*)delData;\n\n\treturn (strcmp(ArrData->name, DelData->name) == 0) && (ArrData->age == DelData->age);\n\n}\n\nvoid test() {\n\n\tstruct Person person1 = { \"aaa\",10 };\n\tstruct Person person2 = { \"bbb\",20 };\n\tstruct Person person3 = { \"ccc\",30 };\n\tstruct Person person4 = { \"ddd\",40 };\n\tstruct Person person5 = { \"eee\",50 };\n\n\tstruct Person person6 = { \"fff\",60 };\n\n\t// 初始化一个容量只有5的动态数组\n\tstruct DynamicArray * testArray= Init_DynamicArray(5);\n\n\tInsert_DynamicArray(testArray, 0, &person1);\n\tInsert_DynamicArray(testArray, 0, &person2);\n\tInsert_DynamicArray(testArray, 0, &person3);\n\tInsert_DynamicArray(testArray, 1, &person4);\n\tInsert_DynamicArray(testArray, 1, &person5);\n\n\tprintf(\"当前数组的容量为 %d \\n\", testArray->capacity);\n\n\t//插入六个数据检测是否实现容量增长\n\tInsert_DynamicArray(testArray, 666, &person6);\n\n\tprintf(\"此时数组的容量为 %d \\n\", testArray->capacity);\n\n\tForeach_DynamicArray(testArray, myPrint);// 3 5 4 2 1 6\n\n\tDeleteByPos_DynamicArray(testArray, 5);\n\n\tprintf(\"------按位置删除-----\\n\");\n\n\tForeach_DynamicArray(testArray,myPrint);// 3 5 4 2 1\n\n\tstruct Person pTest = { \"aaa\", 10 };\n\tDeleteByValue_DynamicArray(testArray, &pTest, myCompare);\n\n\tprintf(\"-------按值删除------\\n\");\n\n\tForeach_DynamicArray(testArray, myPrint);//3 5 4 2\n\n\n\tprintf(\"----\\n\");\n\n\t//按值删除的内部由于调用了按位置删除的函数，因此，对数组当前最后一个元素进行删除时依旧存在没有真正删除的问题\n\t//因为按位置删除对最后一个元素的删除时，并未采取清除或替换操作，仅仅是进行了size--操作，因此可以通过直接访问该元素地址进行输出\n\tprintf(\"第五个元素并未删除 name: %s age: %d\\n\", ((struct Person*)testArray->addr[4])->name, ((struct Person*)testArray->addr[4])->age);\n\tprintf(\"第六个元素并未删除 name: %s age: %d\\n\", ((struct Person*)testArray->addr[5])->name, ((struct Person*)testArray->addr[5])->age);\n\n\tDestroy_DynamicArray(testArray);\n\n}\n\n\nint main() {\n\ttest();\n}\n~~~\n测试输入如下：\n![699829f16d3528ced1cf85eeff57238906a5.png](https://miao.su/images/2019/07/19/699829f16d3528ced1cf85eeff57238906a5.png)\n\n## 单向链表\n与之前写的链表不同的是，这次定义了**两个结构体**，一个是*结点结构*，一个是*链表结构*，其中链表结构嵌套了结点结构，存放了**链表的头结点**，**结点个数**。后期可以根据需要加入类似**尾指针**，让尾插法更加高效的操作链表的一系列成员。\n\n还有一点就是，**封装的思想**。之前写的链表，初始化传递回去的直接就是一个*指向数据结构首地址的数据结构类型指针*，虽然这样可以更加方便操作数据结构，但不加以约束的会带来许多**弊端**：拿到指针后可以随意修改数据，还可以对数据进行清空。\n\n因此这次在实现单向链表时，**初始化数据结构**后传递回去的是一个**万能指针类型**，这样用户在得到该指针后，只能使用这个指针调用我们数据结构已经写好的功能，比如获取结点个数等之前可以直接通过指针操作获取的数据。\n\n在写数据结构的过程中，由于传递的是万能指针类型，所以实现各个功能都需要进行强转万能指针对数据结构进行操作，因为是自己实现数据结构，知道数据结构的类型因此可以通过强转进行操作，而用户则不能进行这种操作。\n\n而且封装的思想还体现在了**插入数据**时接收数据的形参也是万能指针，即我们写数据结构时无需考虑用户传递的数据类型，当实现遍历打印，按值删除这些需要**明确清楚数据类型的功能**时，在函数的形参中使用**函数指针**，这些**回调函数**均由用户去实现，我们的函数指针指向用户写好的回调函数后，根据返回值便可以对数据进行上述功能的实现了。\n\n### 单向链表头文件\n**这部分是重点！！！**\n\n增加了使用typedef给万能指针，函数指针重新命名的操作，目的是增加程序的可读性。而且不在头文件中定义数据结构了而是放到了实现文件中，也是封装的思想，**让用户看到更少的细节**，仅需要注重调用功能的实现。\n~~~\n//使用void*保护链表\n\ttypedef void* LList;\n\ttypedef void(*FOREACH)(void* );\n\ttypedef int(*COMPARE)(void*, void*);\n\n\t//初始化链表，不再返回指向链表指针类型\n\tLList Init_LinkList();\n\n\t//插入结点\n\tvoid Insert_LinkList(LList list, int pos, void* data);\n\n\t//遍历链表\n\tvoid ForEach_LinkList(LList list, FOREACH myfoeach);\n\n\t//按位置删除结点\n\tvoid DeleteByPos_LinkList(LList list, int pos);\n\n\t//按值删除结点\n\tvoid DeleteByValue_LinkList(LList list, void* data, COMPARE compare);\n\n\t//链表大小\n\tint Size_LinkList(LList list);\n\n\t//清空链表\n\tvoid Clear_LinkList(LList list);\n\n\t//销毁链表\n\tvoid Destroy_LinkList(LList list);\n~~~\n\n---\n\n### 单向链表实现文件\n#### 单向链表数据结构的定义\n\n~~~\n// 结点数据类型\nstruct LinkNode {\n\tvoid* data;\n\tstruct LinkNode* next;\n};\n\n// 链表数据类型\nstruct LinkList {\n\tstruct LinkNode header;\n\tint size;\n};\n~~~\n\n\n#### 初始化链表，不再返回指向链表指针类型\n~~~\nLList Init_LinkList() {\n\n\tstruct LinkList* list = malloc(sizeof(struct LinkList));\n\n\tif (NULL == list) {\n\t\treturn NULL;\n\t}\n\n\tlist->header.next = NULL;\n\tlist->header.data = NULL;\n\tlist->size = 0;\n\n\treturn list;\n\n}\n~~~\n\n\n\n#### 插入结点(比较重要)\n中间有两条语句是插入结点后重新连接链表的操作，因为没画图，就脑子想了想，结果debug了一个半小时，差点崩溃了，所以数据结构画图很重要啊！！\n~~~\nvoid Insert_LinkList(LList list, int pos, void* data) {\n\n\tif (NULL == list) {\n\t\treturn;\n\t}\n\n\tif (NULL == data) {\n\t\treturn;\n\t}\n\n\t//传入的list是void*类型，需要进行强转\n\tstruct LinkList* myList = (struct LinkList*)list;\n\n\tif (pos < 0 || pos > myList->size) {\n\n\t\tpos = myList->size;\n\n\t}\n\n\t//查找插入位置的前一个结点(重点！)\n\tstruct LinkNode* pCurrent = &(myList->header);\n\tfor (int i = 0; i < pos; ++i) {\n\n\t\tpCurrent = pCurrent->next;\n\n\t}\n\n\tstruct LinkNode* newNode = malloc(sizeof(struct LinkNode));\n\tnewNode->next = NULL;\n\tnewNode->data = data;\n\n\t// 插入结点，两条语句的先后顺序很关键，画图！！！再写\n\tnewNode->next = pCurrent->next;\n\tpCurrent->next = newNode;\n\n\tmyList->size++;\n\n}\n~~~\n\n#### 遍历链表\n\n~~~\nvoid ForEach_LinkList(LList list, FOREACH myfoeach) {\n\n\tif (NULL == list) {\n\t\treturn;\n\t}\n\n\tif(NULL == myfoeach) {\n\t\treturn;\n\t}\n\n\t//传入的list是void*类型，需要进行强转\n\tstruct LinkList* myList = (struct Links*)list;\n\n\tstruct LinkNode* pCurrent = myList->header.next;\n\t\n\twhile (pCurrent != NULL) {\n\t\tmyfoeach(pCurrent->data);\n\t\tpCurrent = pCurrent->next;\n\t}\n\n}\n~~~\n\n\n\n#### 按位置删除结点\n~~~\nvoid DeleteByPos_LinkList(LList list, int pos) {\n\n\tif (NULL == list) {\n\t\treturn;\n\t}\n\n\tstruct LinkList* myList = (struct LinkList*)list;\n\n\tif (pos < 0 || pos > myList->size) {\n\t\treturn;\n\t}\n\n\t// 重点理解以下的pCurrent指针和for循环功能\n\tstruct LinkNode* pCurrent = &(myList->header);\n\n\t//找到要删除的结点的前一个结点位置\n\tfor (int i = 0; i < pos; ++i) {\n\n\t\tpCurrent = pCurrent->next;\n\n\t}\n\n\t//将被删除结点的前驱结点和后继结点进行连接\n\tstruct LinkNode* pDel = pCurrent->next;\n\tpCurrent->next = pDel->next;\n\n\tfree(pDel);\n\tpDel = NULL;\n\n\tmyList->size--;\n\n}\n~~~\n\n\n\n#### 按值删除结点(比较重要)\n~~~\nvoid DeleteByValue_LinkList(LList list, void* data, COMPARE compare) {\n\n\tif (NULL == list)\n\t{\n\t\treturn;\n\t}\n\n\tif (NULL == data) {\n\t\treturn;\n\t}\n\n\tif (NULL == compare) {\n\t\treturn;\n\t}\n\n\tstruct LinkList* myList = (struct LinkList*)list;\n\n\t//两个辅助指针变量\n\tstruct LinkNode* pPre = &(myList->header);\n\tstruct LinkNode* pCurrent = myList->header.next;\n\n\twhile (pCurrent != NULL) {\n\t\t\n\t\tif (compare(pCurrent->data, data)) {\n\t\t\t// 找到要删除的结点\n\t\t\tpPre->next = pCurrent->next;\t\t\n\t\t\tbreak;\n\t\t}\n\t\tpPre = pCurrent;\n\t\tpCurrent = pCurrent->next;\n\t}\n\n\t//释放被删除的结点\n\tfree(pCurrent);\n\tpCurrent = NULL;\n\n\tmyList->size--;\n\n}\n~~~\n\n#### 链表大小\n~~~\nint Size_LinkList(LList list) {\n\n\tif (NULL == list) {\n\t\treturn -1;\n\t}\n\t\n\tstruct LinkList* myList = (struct LinkList*)list;\n\n\treturn myList->size;\n\n}\n~~~\n\n#### 清空链表\n~~~\nvoid Clear_LinkList(LList list) {\n\n\tif (NULL == list) {\n\t\treturn;\n\t}\n\n\tstruct LinkList* myList = (struct LinkList*)list;\n\n\tstruct LinkNode* pCurrent = myList->header.next;\n\n\twhile (pCurrent != NULL) {\n\t\t\n\t\t//先记录下一个结点的地址\n\t\tstruct LinkNode* pNext = pCurrent->next;\n\t\t//释放当前结点的空间\n\t\tfree(pCurrent);\n\t\tpCurrent = pNext;\n\n\t}\n\n\tmyList->header.next = NULL;\n\n\t//将链表大小置为0\n\tmyList->size = 0;\n\n}\n~~~\n\n#### 销毁链表\n~~~\nvoid Destroy_LinkList(LList list) {\n\n\tif (NULL == list) {\n\t\treturn;\n\t}\n\n\tClear_LinkList(list);\n\n\tfree(list);\n\tlist = NULL;\n\n}\n~~~\n\n\n\n#### 我认为比较重要的一个循环\n在插入和按位置删除结点都使用了这个循环，用途是找到**需要操作的结点的前一个结点**。\n~~~\nstruct LinkNode* pCurrent = &(myList->header);\nfor (int i = 0; i < pos; ++i) {\n\n    pCurrent = pCurrent->next;\n    \n}\n~~~\n\n### 单向链表测试文件\n~~~\nstruct Person {\n\tchar name[64];\n\tint age;\n};\n\n//用于对链表遍历的数据进行转换\nvoid myPrint(void* data) {\n\n\tstruct Person* Data = (struct Person*)data;\n\tprintf(\"name: %s age: %d\\n\", Data->name, Data->age);\n\n}\n\n//用于对按值删除的数据进行比较\nint myCompare(void* pre, void* cur) {\n\n\tstruct Person* p1 = (struct Person*)pre;\n\tstruct Person* p2 = (struct Person*)cur;\n\n\treturn (strcmp(p1->name, p2->name) == 0) && (p1->age == p2->age);\n\n}\n\nvoid test() {\n\n\tstruct Person p1 = { \"aa\",1 };\n\tstruct Person p2 = { \"bb\",2 };\n\tstruct Person p3 = { \"cc\",3 };\n\tstruct Person p4 = { \"dd\",4 };\n\tstruct Person p5 = { \"ee\",5 };\n\tstruct Person p6 = { \"ff\",6 };\n\tstruct Person p7 = { \"gg\",7 };\n\n\t//初始化链表\n\tLList testList = Init_LinkList();\n\n\t// 插入数据\n\tInsert_LinkList(testList, 0, &p1);\n\tInsert_LinkList(testList, 1, &p2);\n\tInsert_LinkList(testList, 2, &p3);\n\tInsert_LinkList(testList, 3, &p4);\n\tInsert_LinkList(testList, 4, &p5);\n\tInsert_LinkList(testList, 5, &p6);\n\tInsert_LinkList(testList, 6, &p7);\n\n\tprintf(\"链表大小初始为 %d \\n\", Size_LinkList(testList));\n\n\tForEach_LinkList(testList, myPrint);\n\tprintf(\"-----------------\\n\");\n\n\t//按位置删除\n\tDeleteByPos_LinkList(testList, 1);\n\n\tForEach_LinkList(testList, myPrint);\n\tprintf(\"-----------------\\n\");\n\n\t//按值删除\n\tstruct Person testDel = { \"gg\", 7};\n\tDeleteByValue_LinkList(testList, &testDel, myCompare);\n\n\n\tForEach_LinkList(testList, myPrint);\n\tprintf(\"-----------------\\n\");\n\n\tprintf(\"链表大小为 %d \\n\", Size_LinkList(testList));\n\n\t//清空链表\n\tClear_LinkList(testList);\n\n\tprintf(\"清空后链表大小为 %d \\n\", Size_LinkList(testList));\n\n\t//销毁链表\n\tDestroy_LinkList(testList);\n\n}\n\nint main() {\n\ttest();\n}\n~~~\n测试输出如下：\n![6607952a5f706902e176b84c1cbcca38405c.png](https://miao.su/images/2019/07/19/6607952a5f706902e176b84c1cbcca38405c.png)\nPS:一周了，多写一篇周记吧。","slug":"2019-Holiday-Note-07","published":1,"updated":"2019-07-19T13:59:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihh000fsmjb484v4xj0","content":"<h1 id=\"Holiday-Note-07\"><a href=\"#Holiday-Note-07\" class=\"headerlink\" title=\"Holiday Note_07\"></a>Holiday Note_07</h1><p>一周了。今天接触了<strong>动态数组</strong>，挺简单的，主要考虑的应该是每一次增加的空间大小的逻辑。又学习了另外一种结构的<strong>单向链表</strong>，也就是额外用一个链表结构去嵌套结点结构的设计。最重要的学习了<strong>封装</strong>的方式去实现对数据结构的操作，不再返回链表的指针，而是使用万能指针避免使用者进行操作数据结构时对数据进行修改；并且广泛使用<strong>回调函数</strong>增加了数据结构的复用性。随着使用回调函数的次数增多，也逐渐开始体会到了封装所带来的便利了，理解这一部分尤其重要。对于<strong>单向链表各个函数定义的参数那部分一定要读懂其设置的含义</strong>。</p>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"动态数组\"><a href=\"#动态数组\" class=\"headerlink\" title=\"动态数组\"></a>动态数组</h2><p>第一次接触动态数组，听名字DynamicArray感觉很厉害，其实实现起来，和普通的数组结构差不多，主要有三个成员，分别是<strong>数组空间首地址(二维指针)，容量大小，当前大小</strong>，唯一不同的就是判断空间不足时需要再分配一块新空间，再将原空间的数据拷贝过去。</p>\n<h3 id=\"动态数组头文件\"><a href=\"#动态数组头文件\" class=\"headerlink\" title=\"动态数组头文件\"></a>动态数组头文件</h3><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> DynamicArray &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//数组存储元素的空间的首地址</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>** addr;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//数组能够在内存中存取的最大元素的个数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//当前存储数据的内存中一共有多少个元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化数组</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> DynamicArray* Init_DynamicArray(<span class=\"keyword\">int</span> capacity);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//插入元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert_DynamicArray</span>(<span class=\"params\"><span class=\"keyword\">struct</span> DynamicArray* arr, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">void</span>* data</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按位置删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByPos_DynamicArray</span>(<span class=\"params\"><span class=\"keyword\">struct</span> DynamicArray* arr, <span class=\"keyword\">int</span> pos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按值删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByValue_DynamicArray</span>(<span class=\"params\"><span class=\"keyword\">struct</span> DynamicArray* arr, <span class=\"keyword\">void</span>* delData, <span class=\"keyword\">int</span>(*CompareCallback</span>)(<span class=\"params\"><span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*</span>))</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foreach_DynamicArray</span>(<span class=\"params\"><span class=\"keyword\">struct</span> DynamicArray* arr, <span class=\"keyword\">void</span>(*_callback</span>)(<span class=\"params\"><span class=\"keyword\">void</span>*</span>))</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//销毁数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy_DynamicArray</span>(<span class=\"params\"><span class=\"keyword\">struct</span> DynamicArray* arr</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"动态数组实现文件\"><a href=\"#动态数组实现文件\" class=\"headerlink\" title=\"动态数组实现文件\"></a>动态数组实现文件</h3><h4 id=\"初始化数组\"><a href=\"#初始化数组\" class=\"headerlink\" title=\"初始化数组\"></a>初始化数组</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DynamicArray</span></span>* Init_DynamicArray(int capacity) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (capacity &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DynamicArray</span></span>* arr = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DynamicArray</span></span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == arr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tarr-&gt;addr = malloc(<span class=\"keyword\">sizeof</span>(void*) * capacity);</span><br><span class=\"line\"></span><br><span class=\"line\">\tarr-&gt;capacity = capacity;</span><br><span class=\"line\"></span><br><span class=\"line\">\tarr-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"插入元素-重点，需要判断空间是否足够集进行分配空间，拷贝数据，释放原空间操作\"><a href=\"#插入元素-重点，需要判断空间是否足够集进行分配空间，拷贝数据，释放原空间操作\" class=\"headerlink\" title=\"插入元素(重点，需要判断空间是否足够集进行分配空间，拷贝数据，释放原空间操作)\"></a>插入元素(重点，需要判断空间是否足够集进行<strong>分配空间</strong>，<strong>拷贝数据</strong>，<strong>释放原空间</strong>操作)</h4><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Insert_DynamicArray(struct DynamicArray* arr, int pos, void* <span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == arr) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == <span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//传入的位置不管是小于0还是大于容量，都让插入的位置为最后一个，因为数组元素间不能不连续</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">if</span> (pos &lt; 0 || pos &gt;= arr-&gt;</span>capacity) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">pos</span> = arr-&gt;</span>size;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//当存储的数据个数已经等于容量时，需要增长数组空间</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">if</span> (arr-&gt;</span><span class=\"function\"><span class=\"title\">size</span> &gt;= arr-&gt;</span>capacity) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//分配更大的内存空间，暂时不考虑增长策略，默认直接翻倍</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">int</span> newCapacity = arr-&gt;</span>capacity * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tvoid** newAddr = malloc(sizeof(void*) * newCapacity);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将原空间的数据拷贝至新分配的空间中</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">memcpy</span>(newAddr, arr-&gt;</span><span class=\"function\"><span class=\"title\">addr</span>, sizeof(void*) * arr-&gt;</span>size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//释放原空间内存</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">free</span>(arr-&gt;</span>addr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//更新数组的指向以及容量</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">arr</span>-&gt;</span>addr = newAddr;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">arr</span>-&gt;</span>capacity = newCapacity;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//为要插入的元素腾出空间</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">for</span> (int i = arr-&gt;</span>size - <span class=\"number\">1</span>; i &gt;= pos; --i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">arr</span>-&gt;</span><span class=\"function\"><span class=\"title\">addr</span>[i + 1] = arr-&gt;</span>addr[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将元素插入并且更新数组存储数据个数</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">arr</span>-&gt;</span>addr[pos] = <span class=\"keyword\">data</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">arr</span>-&gt;</span>size++;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按位置删除\"><a href=\"#按位置删除\" class=\"headerlink\" title=\"按位置删除\"></a>按位置删除</h4><p>功能不够完善，当<em>删除最后一个元素时</em>，即pos == size-1的情况时，并未进入循环，而是直接size–，实际该元素仍然存在，在测试文件中，我仍可以将依旧删除的最后一个元素进行打印输出。</p>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void DeleteByPos_DynamicArray(struct DynamicArray* arr, <span class=\"keyword\">int</span> pos) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">NULL</span> == arr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pos &lt; <span class=\"number\">0</span> || pos &gt; arr-&gt;size - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//！！！！！</span></span><br><span class=\"line\">\t<span class=\"comment\">//当删除最后一个元素时，即pos == size-1的情况时，并未进入循环，而是直接size--，实际该元素仍然存在</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = pos; i &lt; arr-&gt;size - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tarr-&gt;addr[i] = arr-&gt;addr[i + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tarr-&gt;size--;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按值删除\"><a href=\"#按值删除\" class=\"headerlink\" title=\"按值删除\"></a>按值删除</h4><p>使用了回调函数对数据进行比对操作，传递数据地址和需要删除的值的指针，用户根据不同数据类型编写对应的比对函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByValue_DynamicArray</span><span class=\"params\">(struct DynamicArray* arr, <span class=\"keyword\">void</span>* delData, <span class=\"keyword\">int</span>(*CompareCallback)(<span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*))</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == arr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == delData) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == CompareCallback) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arr-&gt;size; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (CompareCallback(arr-&gt;addr[i], delData)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tDeleteByPos_DynamicArray(arr, i);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"遍历数组\"><a href=\"#遍历数组\" class=\"headerlink\" title=\"遍历数组\"></a>遍历数组</h4><p>同样使用了回调函数</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Foreach_DynamicArray(struct DynamicArray* arr, void<span class=\"comment\">(*_callback)(void*)</span>) <span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\tif (NULL == arr)</span></span><br><span class=\"line\"><span class=\"comment\">\t\treturn;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\tfor (int i = 0; i &lt; arr-&gt;size; ++i) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\t\t_callback(arr-&gt;addr[i]);</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"销毁数组\"><a href=\"#销毁数组\" class=\"headerlink\" title=\"销毁数组\"></a>销毁数组</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy_DynamicArray</span><span class=\"params\">(struct DynamicArray* arr)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == arr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (arr-&gt;addr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(arr-&gt;addr);</span><br><span class=\"line\">\t\tarr-&gt;addr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(arr);</span><br><span class=\"line\">\tarr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"动态数组测试文件\"><a href=\"#动态数组测试文件\" class=\"headerlink\" title=\"动态数组测试文件\"></a>动态数组测试文件</h3><p>定义一个结构体数组，调用动态数组进行存储并操作，测试文件需要根据定义的数据类型编写对应回调函数才能调用写好的数据结构操作数据，注意看最后的将删除元素打印步骤。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历回调函数</span></span><br><span class=\"line\">void myPrint(void* data) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>* arrayData = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)data;</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"name: %s age: %d\\n\"</span>, arrayData-&gt;name, arrayData-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//比较回调函数</span></span><br><span class=\"line\">int myCompare(void* arrData, void* delData) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == arrData) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == delData) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>* ArrData = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)arrData;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>* DelData = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)delData;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (strcmp(ArrData-&gt;name, DelData-&gt;name) == <span class=\"number\">0</span>) &amp;&amp; (ArrData-&gt;age == DelData-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> person1 = &#123; <span class=\"string\">\"aaa\"</span>,<span class=\"number\">10</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> person2 = &#123; <span class=\"string\">\"bbb\"</span>,<span class=\"number\">20</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> person3 = &#123; <span class=\"string\">\"ccc\"</span>,<span class=\"number\">30</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> person4 = &#123; <span class=\"string\">\"ddd\"</span>,<span class=\"number\">40</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> person5 = &#123; <span class=\"string\">\"eee\"</span>,<span class=\"number\">50</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> person6 = &#123; <span class=\"string\">\"fff\"</span>,<span class=\"number\">60</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 初始化一个容量只有5的动态数组</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DynamicArray</span></span> * testArray= Init_DynamicArray(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tInsert_DynamicArray(testArray, <span class=\"number\">0</span>, &amp;person1);</span><br><span class=\"line\">\tInsert_DynamicArray(testArray, <span class=\"number\">0</span>, &amp;person2);</span><br><span class=\"line\">\tInsert_DynamicArray(testArray, <span class=\"number\">0</span>, &amp;person3);</span><br><span class=\"line\">\tInsert_DynamicArray(testArray, <span class=\"number\">1</span>, &amp;person4);</span><br><span class=\"line\">\tInsert_DynamicArray(testArray, <span class=\"number\">1</span>, &amp;person5);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"当前数组的容量为 %d \\n\"</span>, testArray-&gt;capacity);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//插入六个数据检测是否实现容量增长</span></span><br><span class=\"line\">\tInsert_DynamicArray(testArray, <span class=\"number\">666</span>, &amp;person6);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"此时数组的容量为 %d \\n\"</span>, testArray-&gt;capacity);</span><br><span class=\"line\"></span><br><span class=\"line\">\tForeach_DynamicArray(testArray, myPrint);<span class=\"comment\">// 3 5 4 2 1 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tDeleteByPos_DynamicArray(testArray, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"------按位置删除-----\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tForeach_DynamicArray(testArray,myPrint);<span class=\"comment\">// 3 5 4 2 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> pTest = &#123; <span class=\"string\">\"aaa\"</span>, <span class=\"number\">10</span> &#125;;</span><br><span class=\"line\">\tDeleteByValue_DynamicArray(testArray, &amp;pTest, myCompare);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"-------按值删除------\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tForeach_DynamicArray(testArray, myPrint);<span class=\"comment\">//3 5 4 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"----\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//按值删除的内部由于调用了按位置删除的函数，因此，对数组当前最后一个元素进行删除时依旧存在没有真正删除的问题</span></span><br><span class=\"line\">\t<span class=\"comment\">//因为按位置删除对最后一个元素的删除时，并未采取清除或替换操作，仅仅是进行了size--操作，因此可以通过直接访问该元素地址进行输出</span></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"第五个元素并未删除 name: %s age: %d\\n\"</span>, ((<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)testArray-&gt;addr[<span class=\"number\">4</span>])-&gt;name, ((<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)testArray-&gt;addr[<span class=\"number\">4</span>])-&gt;age);</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"第六个元素并未删除 name: %s age: %d\\n\"</span>, ((<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)testArray-&gt;addr[<span class=\"number\">5</span>])-&gt;name, ((<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)testArray-&gt;addr[<span class=\"number\">5</span>])-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">\tDestroy_DynamicArray(testArray);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\ttest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试输入如下：<br><img src=\"https://miao.su/images/2019/07/19/699829f16d3528ced1cf85eeff57238906a5.png\" alt=\"699829f16d3528ced1cf85eeff57238906a5.png\"></p>\n<h2 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h2><p>与之前写的链表不同的是，这次定义了<strong>两个结构体</strong>，一个是<em>结点结构</em>，一个是<em>链表结构</em>，其中链表结构嵌套了结点结构，存放了<strong>链表的头结点</strong>，<strong>结点个数</strong>。后期可以根据需要加入类似<strong>尾指针</strong>，让尾插法更加高效的操作链表的一系列成员。</p>\n<p>还有一点就是，<strong>封装的思想</strong>。之前写的链表，初始化传递回去的直接就是一个<em>指向数据结构首地址的数据结构类型指针</em>，虽然这样可以更加方便操作数据结构，但不加以约束的会带来许多<strong>弊端</strong>：拿到指针后可以随意修改数据，还可以对数据进行清空。</p>\n<p>因此这次在实现单向链表时，<strong>初始化数据结构</strong>后传递回去的是一个<strong>万能指针类型</strong>，这样用户在得到该指针后，只能使用这个指针调用我们数据结构已经写好的功能，比如获取结点个数等之前可以直接通过指针操作获取的数据。</p>\n<p>在写数据结构的过程中，由于传递的是万能指针类型，所以实现各个功能都需要进行强转万能指针对数据结构进行操作，因为是自己实现数据结构，知道数据结构的类型因此可以通过强转进行操作，而用户则不能进行这种操作。</p>\n<p>而且封装的思想还体现在了<strong>插入数据</strong>时接收数据的形参也是万能指针，即我们写数据结构时无需考虑用户传递的数据类型，当实现遍历打印，按值删除这些需要<strong>明确清楚数据类型的功能</strong>时，在函数的形参中使用<strong>函数指针</strong>，这些<strong>回调函数</strong>均由用户去实现，我们的函数指针指向用户写好的回调函数后，根据返回值便可以对数据进行上述功能的实现了。</p>\n<h3 id=\"单向链表头文件\"><a href=\"#单向链表头文件\" class=\"headerlink\" title=\"单向链表头文件\"></a>单向链表头文件</h3><p><strong>这部分是重点！！！</strong></p>\n<p>增加了使用typedef给万能指针，函数指针重新命名的操作，目的是增加程序的可读性。而且不在头文件中定义数据结构了而是放到了实现文件中，也是封装的思想，<strong>让用户看到更少的细节</strong>，仅需要注重调用功能的实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用void*保护链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>* LList;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*FOREACH)</span><span class=\"params\">(<span class=\"keyword\">void</span>* )</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span><span class=\"params\">(*COMPARE)</span><span class=\"params\">(<span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化链表，不再返回指向链表指针类型</span></span><br><span class=\"line\">\t<span class=\"function\">LList <span class=\"title\">Init_LinkList</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//插入结点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">void</span>* data)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//遍历链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ForEach_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, FOREACH myfoeach)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//按位置删除结点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByPos_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> pos)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//按值删除结点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByValue_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, <span class=\"keyword\">void</span>* data, COMPARE compare)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//链表大小</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Size_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//清空链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Clear_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//销毁链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"单向链表实现文件\"><a href=\"#单向链表实现文件\" class=\"headerlink\" title=\"单向链表实现文件\"></a>单向链表实现文件</h3><h4 id=\"单向链表数据结构的定义\"><a href=\"#单向链表数据结构的定义\" class=\"headerlink\" title=\"单向链表数据结构的定义\"></a>单向链表数据结构的定义</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结点数据类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表数据类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> <span class=\"title\">header</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化链表，不再返回指向链表指针类型\"><a href=\"#初始化链表，不再返回指向链表指针类型\" class=\"headerlink\" title=\"初始化链表，不再返回指向链表指针类型\"></a>初始化链表，不再返回指向链表指针类型</h4><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LList Init_LinkList() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstruct LinkList* <span class=\"built_in\">list</span> = malloc(sizeof(struct LinkList));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">list</span>-&gt;<span class=\"keyword\">header</span>.next = <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">list</span>-&gt;<span class=\"keyword\">header</span>.<span class=\"built_in\">data</span> = <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">list</span>-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"插入结点-比较重要\"><a href=\"#插入结点-比较重要\" class=\"headerlink\" title=\"插入结点(比较重要)\"></a>插入结点(比较重要)</h4><p>中间有两条语句是插入结点后重新连接链表的操作，因为没画图，就脑子想了想，结果debug了一个半小时，差点崩溃了，所以数据结构画图很重要啊！！</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Insert_LinkList(LList list, int pos, void* data) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == list) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == data) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//传入的list是void*类型，需要进行强转</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span></span>* myList = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span></span>*)list;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pos &lt; <span class=\"number\">0</span> || pos &gt; myList-&gt;size) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpos = myList-&gt;size;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//查找插入位置的前一个结点(重点！)</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span></span>* pCurrent = &amp;(myList-&gt;header);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; pos; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpCurrent = pCurrent-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span></span>* newNode = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span></span>));</span><br><span class=\"line\">\tnewNode-&gt;next = NULL;</span><br><span class=\"line\">\tnewNode-&gt;data = data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 插入结点，两条语句的先后顺序很关键，画图！！！再写</span></span><br><span class=\"line\">\tnewNode-&gt;next = pCurrent-&gt;next;</span><br><span class=\"line\">\tpCurrent-&gt;next = newNode;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmyList-&gt;size++;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"遍历链表\"><a href=\"#遍历链表\" class=\"headerlink\" title=\"遍历链表\"></a>遍历链表</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ForEach_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, FOREACH myfoeach)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == myfoeach) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//传入的list是void*类型，需要进行强转</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span>* <span class=\"title\">myList</span> = (<span class=\"title\">struct</span> <span class=\"title\">Links</span>*)<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pCurrent</span> = <span class=\"title\">myList</span>-&gt;<span class=\"title\">header</span>.<span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pCurrent != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\tmyfoeach(pCurrent-&gt;data);</span><br><span class=\"line\">\t\tpCurrent = pCurrent-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按位置删除结点\"><a href=\"#按位置删除结点\" class=\"headerlink\" title=\"按位置删除结点\"></a>按位置删除结点</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByPos_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span>* <span class=\"title\">myList</span> = (<span class=\"title\">struct</span> <span class=\"title\">LinkList</span>*)<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pos &lt; <span class=\"number\">0</span> || pos &gt; myList-&gt;size) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 重点理解以下的pCurrent指针和for循环功能</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pCurrent</span> = &amp;(<span class=\"title\">myList</span>-&gt;<span class=\"title\">header</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//找到要删除的结点的前一个结点位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pos; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpCurrent = pCurrent-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将被删除结点的前驱结点和后继结点进行连接</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pDel</span> = <span class=\"title\">pCurrent</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">\tpCurrent-&gt;next = pDel-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(pDel);</span><br><span class=\"line\">\tpDel = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmyList-&gt;size--;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按值删除结点-比较重要\"><a href=\"#按值删除结点-比较重要\" class=\"headerlink\" title=\"按值删除结点(比较重要)\"></a>按值删除结点(比较重要)</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByValue_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, <span class=\"keyword\">void</span>* data, COMPARE compare)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == data) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == compare) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span>* <span class=\"title\">myList</span> = (<span class=\"title\">struct</span> <span class=\"title\">LinkList</span>*)<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//两个辅助指针变量</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pPre</span> = &amp;(<span class=\"title\">myList</span>-&gt;<span class=\"title\">header</span>);</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pCurrent</span> = <span class=\"title\">myList</span>-&gt;<span class=\"title\">header</span>.<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pCurrent != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (compare(pCurrent-&gt;data, data)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 找到要删除的结点</span></span><br><span class=\"line\">\t\t\tpPre-&gt;next = pCurrent-&gt;next;\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpPre = pCurrent;</span><br><span class=\"line\">\t\tpCurrent = pCurrent-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//释放被删除的结点</span></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(pCurrent);</span><br><span class=\"line\">\tpCurrent = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmyList-&gt;size--;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"链表大小\"><a href=\"#链表大小\" class=\"headerlink\" title=\"链表大小\"></a>链表大小</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Size_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span>* <span class=\"title\">myList</span> = (<span class=\"title\">struct</span> <span class=\"title\">LinkList</span>*)<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> myList-&gt;size;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"清空链表\"><a href=\"#清空链表\" class=\"headerlink\" title=\"清空链表\"></a>清空链表</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Clear_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span>* <span class=\"title\">myList</span> = (<span class=\"title\">struct</span> <span class=\"title\">LinkList</span>*)<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pCurrent</span> = <span class=\"title\">myList</span>-&gt;<span class=\"title\">header</span>.<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pCurrent != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//先记录下一个结点的地址</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pNext</span> = <span class=\"title\">pCurrent</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//释放当前结点的空间</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(pCurrent);</span><br><span class=\"line\">\t\tpCurrent = pNext;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmyList-&gt;header.next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将链表大小置为0</span></span><br><span class=\"line\">\tmyList-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"销毁链表\"><a href=\"#销毁链表\" class=\"headerlink\" title=\"销毁链表\"></a>销毁链表</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tClear_LinkList(<span class=\"built_in\">list</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">list</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"我认为比较重要的一个循环\"><a href=\"#我认为比较重要的一个循环\" class=\"headerlink\" title=\"我认为比较重要的一个循环\"></a>我认为比较重要的一个循环</h4><p>在插入和按位置删除结点都使用了这个循环，用途是找到<strong>需要操作的结点的前一个结点</strong>。</p>\n<figure class=\"highlight ocaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"type\">LinkNode</span>* pCurrent = &amp;(myList-&gt;header);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; pos; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    pCurrent = pCurrent-&gt;next;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单向链表测试文件\"><a href=\"#单向链表测试文件\" class=\"headerlink\" title=\"单向链表测试文件\"></a>单向链表测试文件</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于对链表遍历的数据进行转换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrint</span><span class=\"params\">(<span class=\"keyword\">void</span>* data)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>* <span class=\"title\">Data</span> = (<span class=\"title\">struct</span> <span class=\"title\">Person</span>*)<span class=\"title\">data</span>;</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"name: %s age: %d\\n\"</span>, Data-&gt;name, Data-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于对按值删除的数据进行比较</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">myCompare</span><span class=\"params\">(<span class=\"keyword\">void</span>* pre, <span class=\"keyword\">void</span>* cur)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>* <span class=\"title\">p1</span> = (<span class=\"title\">struct</span> <span class=\"title\">Person</span>*)<span class=\"title\">pre</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>* <span class=\"title\">p2</span> = (<span class=\"title\">struct</span> <span class=\"title\">Person</span>*)<span class=\"title\">cur</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"built_in\">strcmp</span>(p1-&gt;name, p2-&gt;name) == <span class=\"number\">0</span>) &amp;&amp; (p1-&gt;age == p2-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p1</span> = &#123;</span> <span class=\"string\">\"aa\"</span>,<span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p2</span> = &#123;</span> <span class=\"string\">\"bb\"</span>,<span class=\"number\">2</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p3</span> = &#123;</span> <span class=\"string\">\"cc\"</span>,<span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p4</span> = &#123;</span> <span class=\"string\">\"dd\"</span>,<span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p5</span> = &#123;</span> <span class=\"string\">\"ee\"</span>,<span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p6</span> = &#123;</span> <span class=\"string\">\"ff\"</span>,<span class=\"number\">6</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p7</span> = &#123;</span> <span class=\"string\">\"gg\"</span>,<span class=\"number\">7</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化链表</span></span><br><span class=\"line\">\tLList testList = Init_LinkList();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 插入数据</span></span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">0</span>, &amp;p1);</span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">1</span>, &amp;p2);</span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">2</span>, &amp;p3);</span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">3</span>, &amp;p4);</span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">4</span>, &amp;p5);</span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">5</span>, &amp;p6);</span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">6</span>, &amp;p7);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"链表大小初始为 %d \\n\"</span>, Size_LinkList(testList));</span><br><span class=\"line\"></span><br><span class=\"line\">\tForEach_LinkList(testList, myPrint);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"-----------------\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//按位置删除</span></span><br><span class=\"line\">\tDeleteByPos_LinkList(testList, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tForEach_LinkList(testList, myPrint);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"-----------------\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//按值删除</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">testDel</span> = &#123;</span> <span class=\"string\">\"gg\"</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">\tDeleteByValue_LinkList(testList, &amp;testDel, myCompare);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tForEach_LinkList(testList, myPrint);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"-----------------\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"链表大小为 %d \\n\"</span>, Size_LinkList(testList));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//清空链表</span></span><br><span class=\"line\">\tClear_LinkList(testList);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"清空后链表大小为 %d \\n\"</span>, Size_LinkList(testList));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//销毁链表</span></span><br><span class=\"line\">\tDestroy_LinkList(testList);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\ttest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试输出如下：<br><img src=\"https://miao.su/images/2019/07/19/6607952a5f706902e176b84c1cbcca38405c.png\" alt=\"6607952a5f706902e176b84c1cbcca38405c.png\"><br>PS:一周了，多写一篇周记吧。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-07\"><a href=\"#Holiday-Note-07\" class=\"headerlink\" title=\"Holiday Note_07\"></a>Holiday Note_07</h1><p>一周了。今天接触了<strong>动态数组</strong>，挺简单的，主要考虑的应该是每一次增加的空间大小的逻辑。又学习了另外一种结构的<strong>单向链表</strong>，也就是额外用一个链表结构去嵌套结点结构的设计。最重要的学习了<strong>封装</strong>的方式去实现对数据结构的操作，不再返回链表的指针，而是使用万能指针避免使用者进行操作数据结构时对数据进行修改；并且广泛使用<strong>回调函数</strong>增加了数据结构的复用性。随着使用回调函数的次数增多，也逐渐开始体会到了封装所带来的便利了，理解这一部分尤其重要。对于<strong>单向链表各个函数定义的参数那部分一定要读懂其设置的含义</strong>。</p>","more":"<hr>\n<h2 id=\"动态数组\"><a href=\"#动态数组\" class=\"headerlink\" title=\"动态数组\"></a>动态数组</h2><p>第一次接触动态数组，听名字DynamicArray感觉很厉害，其实实现起来，和普通的数组结构差不多，主要有三个成员，分别是<strong>数组空间首地址(二维指针)，容量大小，当前大小</strong>，唯一不同的就是判断空间不足时需要再分配一块新空间，再将原空间的数据拷贝过去。</p>\n<h3 id=\"动态数组头文件\"><a href=\"#动态数组头文件\" class=\"headerlink\" title=\"动态数组头文件\"></a>动态数组头文件</h3><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> DynamicArray &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//数组存储元素的空间的首地址</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>** addr;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//数组能够在内存中存取的最大元素的个数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//当前存储数据的内存中一共有多少个元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化数组</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> DynamicArray* Init_DynamicArray(<span class=\"keyword\">int</span> capacity);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//插入元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert_DynamicArray</span>(<span class=\"params\"><span class=\"keyword\">struct</span> DynamicArray* arr, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">void</span>* data</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按位置删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByPos_DynamicArray</span>(<span class=\"params\"><span class=\"keyword\">struct</span> DynamicArray* arr, <span class=\"keyword\">int</span> pos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按值删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByValue_DynamicArray</span>(<span class=\"params\"><span class=\"keyword\">struct</span> DynamicArray* arr, <span class=\"keyword\">void</span>* delData, <span class=\"keyword\">int</span>(*CompareCallback</span>)(<span class=\"params\"><span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*</span>))</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foreach_DynamicArray</span>(<span class=\"params\"><span class=\"keyword\">struct</span> DynamicArray* arr, <span class=\"keyword\">void</span>(*_callback</span>)(<span class=\"params\"><span class=\"keyword\">void</span>*</span>))</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//销毁数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy_DynamicArray</span>(<span class=\"params\"><span class=\"keyword\">struct</span> DynamicArray* arr</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"动态数组实现文件\"><a href=\"#动态数组实现文件\" class=\"headerlink\" title=\"动态数组实现文件\"></a>动态数组实现文件</h3><h4 id=\"初始化数组\"><a href=\"#初始化数组\" class=\"headerlink\" title=\"初始化数组\"></a>初始化数组</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DynamicArray</span></span>* Init_DynamicArray(int capacity) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (capacity &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DynamicArray</span></span>* arr = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DynamicArray</span></span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == arr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tarr-&gt;addr = malloc(<span class=\"keyword\">sizeof</span>(void*) * capacity);</span><br><span class=\"line\"></span><br><span class=\"line\">\tarr-&gt;capacity = capacity;</span><br><span class=\"line\"></span><br><span class=\"line\">\tarr-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"插入元素-重点，需要判断空间是否足够集进行分配空间，拷贝数据，释放原空间操作\"><a href=\"#插入元素-重点，需要判断空间是否足够集进行分配空间，拷贝数据，释放原空间操作\" class=\"headerlink\" title=\"插入元素(重点，需要判断空间是否足够集进行分配空间，拷贝数据，释放原空间操作)\"></a>插入元素(重点，需要判断空间是否足够集进行<strong>分配空间</strong>，<strong>拷贝数据</strong>，<strong>释放原空间</strong>操作)</h4><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Insert_DynamicArray(struct DynamicArray* arr, int pos, void* <span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == arr) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == <span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//传入的位置不管是小于0还是大于容量，都让插入的位置为最后一个，因为数组元素间不能不连续</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">if</span> (pos &lt; 0 || pos &gt;= arr-&gt;</span>capacity) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">pos</span> = arr-&gt;</span>size;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//当存储的数据个数已经等于容量时，需要增长数组空间</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">if</span> (arr-&gt;</span><span class=\"function\"><span class=\"title\">size</span> &gt;= arr-&gt;</span>capacity) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//分配更大的内存空间，暂时不考虑增长策略，默认直接翻倍</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">int</span> newCapacity = arr-&gt;</span>capacity * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tvoid** newAddr = malloc(sizeof(void*) * newCapacity);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将原空间的数据拷贝至新分配的空间中</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">memcpy</span>(newAddr, arr-&gt;</span><span class=\"function\"><span class=\"title\">addr</span>, sizeof(void*) * arr-&gt;</span>size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//释放原空间内存</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">free</span>(arr-&gt;</span>addr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//更新数组的指向以及容量</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">arr</span>-&gt;</span>addr = newAddr;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">arr</span>-&gt;</span>capacity = newCapacity;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//为要插入的元素腾出空间</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">for</span> (int i = arr-&gt;</span>size - <span class=\"number\">1</span>; i &gt;= pos; --i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">arr</span>-&gt;</span><span class=\"function\"><span class=\"title\">addr</span>[i + 1] = arr-&gt;</span>addr[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将元素插入并且更新数组存储数据个数</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">arr</span>-&gt;</span>addr[pos] = <span class=\"keyword\">data</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">arr</span>-&gt;</span>size++;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按位置删除\"><a href=\"#按位置删除\" class=\"headerlink\" title=\"按位置删除\"></a>按位置删除</h4><p>功能不够完善，当<em>删除最后一个元素时</em>，即pos == size-1的情况时，并未进入循环，而是直接size–，实际该元素仍然存在，在测试文件中，我仍可以将依旧删除的最后一个元素进行打印输出。</p>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void DeleteByPos_DynamicArray(struct DynamicArray* arr, <span class=\"keyword\">int</span> pos) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">NULL</span> == arr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pos &lt; <span class=\"number\">0</span> || pos &gt; arr-&gt;size - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//！！！！！</span></span><br><span class=\"line\">\t<span class=\"comment\">//当删除最后一个元素时，即pos == size-1的情况时，并未进入循环，而是直接size--，实际该元素仍然存在</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = pos; i &lt; arr-&gt;size - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tarr-&gt;addr[i] = arr-&gt;addr[i + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tarr-&gt;size--;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按值删除\"><a href=\"#按值删除\" class=\"headerlink\" title=\"按值删除\"></a>按值删除</h4><p>使用了回调函数对数据进行比对操作，传递数据地址和需要删除的值的指针，用户根据不同数据类型编写对应的比对函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByValue_DynamicArray</span><span class=\"params\">(struct DynamicArray* arr, <span class=\"keyword\">void</span>* delData, <span class=\"keyword\">int</span>(*CompareCallback)(<span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*))</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == arr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == delData) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == CompareCallback) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arr-&gt;size; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (CompareCallback(arr-&gt;addr[i], delData)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tDeleteByPos_DynamicArray(arr, i);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"遍历数组\"><a href=\"#遍历数组\" class=\"headerlink\" title=\"遍历数组\"></a>遍历数组</h4><p>同样使用了回调函数</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Foreach_DynamicArray(struct DynamicArray* arr, void<span class=\"comment\">(*_callback)(void*)</span>) <span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\tif (NULL == arr)</span></span><br><span class=\"line\"><span class=\"comment\">\t\treturn;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\tfor (int i = 0; i &lt; arr-&gt;size; ++i) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\t\t_callback(arr-&gt;addr[i]);</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"销毁数组\"><a href=\"#销毁数组\" class=\"headerlink\" title=\"销毁数组\"></a>销毁数组</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy_DynamicArray</span><span class=\"params\">(struct DynamicArray* arr)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == arr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (arr-&gt;addr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(arr-&gt;addr);</span><br><span class=\"line\">\t\tarr-&gt;addr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(arr);</span><br><span class=\"line\">\tarr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"动态数组测试文件\"><a href=\"#动态数组测试文件\" class=\"headerlink\" title=\"动态数组测试文件\"></a>动态数组测试文件</h3><p>定义一个结构体数组，调用动态数组进行存储并操作，测试文件需要根据定义的数据类型编写对应回调函数才能调用写好的数据结构操作数据，注意看最后的将删除元素打印步骤。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历回调函数</span></span><br><span class=\"line\">void myPrint(void* data) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>* arrayData = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)data;</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"name: %s age: %d\\n\"</span>, arrayData-&gt;name, arrayData-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//比较回调函数</span></span><br><span class=\"line\">int myCompare(void* arrData, void* delData) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == arrData) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == delData) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>* ArrData = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)arrData;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>* DelData = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)delData;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (strcmp(ArrData-&gt;name, DelData-&gt;name) == <span class=\"number\">0</span>) &amp;&amp; (ArrData-&gt;age == DelData-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> person1 = &#123; <span class=\"string\">\"aaa\"</span>,<span class=\"number\">10</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> person2 = &#123; <span class=\"string\">\"bbb\"</span>,<span class=\"number\">20</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> person3 = &#123; <span class=\"string\">\"ccc\"</span>,<span class=\"number\">30</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> person4 = &#123; <span class=\"string\">\"ddd\"</span>,<span class=\"number\">40</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> person5 = &#123; <span class=\"string\">\"eee\"</span>,<span class=\"number\">50</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> person6 = &#123; <span class=\"string\">\"fff\"</span>,<span class=\"number\">60</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 初始化一个容量只有5的动态数组</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DynamicArray</span></span> * testArray= Init_DynamicArray(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tInsert_DynamicArray(testArray, <span class=\"number\">0</span>, &amp;person1);</span><br><span class=\"line\">\tInsert_DynamicArray(testArray, <span class=\"number\">0</span>, &amp;person2);</span><br><span class=\"line\">\tInsert_DynamicArray(testArray, <span class=\"number\">0</span>, &amp;person3);</span><br><span class=\"line\">\tInsert_DynamicArray(testArray, <span class=\"number\">1</span>, &amp;person4);</span><br><span class=\"line\">\tInsert_DynamicArray(testArray, <span class=\"number\">1</span>, &amp;person5);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"当前数组的容量为 %d \\n\"</span>, testArray-&gt;capacity);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//插入六个数据检测是否实现容量增长</span></span><br><span class=\"line\">\tInsert_DynamicArray(testArray, <span class=\"number\">666</span>, &amp;person6);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"此时数组的容量为 %d \\n\"</span>, testArray-&gt;capacity);</span><br><span class=\"line\"></span><br><span class=\"line\">\tForeach_DynamicArray(testArray, myPrint);<span class=\"comment\">// 3 5 4 2 1 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tDeleteByPos_DynamicArray(testArray, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"------按位置删除-----\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tForeach_DynamicArray(testArray,myPrint);<span class=\"comment\">// 3 5 4 2 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span> pTest = &#123; <span class=\"string\">\"aaa\"</span>, <span class=\"number\">10</span> &#125;;</span><br><span class=\"line\">\tDeleteByValue_DynamicArray(testArray, &amp;pTest, myCompare);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"-------按值删除------\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tForeach_DynamicArray(testArray, myPrint);<span class=\"comment\">//3 5 4 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"----\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//按值删除的内部由于调用了按位置删除的函数，因此，对数组当前最后一个元素进行删除时依旧存在没有真正删除的问题</span></span><br><span class=\"line\">\t<span class=\"comment\">//因为按位置删除对最后一个元素的删除时，并未采取清除或替换操作，仅仅是进行了size--操作，因此可以通过直接访问该元素地址进行输出</span></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"第五个元素并未删除 name: %s age: %d\\n\"</span>, ((<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)testArray-&gt;addr[<span class=\"number\">4</span>])-&gt;name, ((<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)testArray-&gt;addr[<span class=\"number\">4</span>])-&gt;age);</span><br><span class=\"line\">\tprintf(<span class=\"string\">\"第六个元素并未删除 name: %s age: %d\\n\"</span>, ((<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)testArray-&gt;addr[<span class=\"number\">5</span>])-&gt;name, ((<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)testArray-&gt;addr[<span class=\"number\">5</span>])-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">\tDestroy_DynamicArray(testArray);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\ttest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试输入如下：<br><img src=\"https://miao.su/images/2019/07/19/699829f16d3528ced1cf85eeff57238906a5.png\" alt=\"699829f16d3528ced1cf85eeff57238906a5.png\"></p>\n<h2 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h2><p>与之前写的链表不同的是，这次定义了<strong>两个结构体</strong>，一个是<em>结点结构</em>，一个是<em>链表结构</em>，其中链表结构嵌套了结点结构，存放了<strong>链表的头结点</strong>，<strong>结点个数</strong>。后期可以根据需要加入类似<strong>尾指针</strong>，让尾插法更加高效的操作链表的一系列成员。</p>\n<p>还有一点就是，<strong>封装的思想</strong>。之前写的链表，初始化传递回去的直接就是一个<em>指向数据结构首地址的数据结构类型指针</em>，虽然这样可以更加方便操作数据结构，但不加以约束的会带来许多<strong>弊端</strong>：拿到指针后可以随意修改数据，还可以对数据进行清空。</p>\n<p>因此这次在实现单向链表时，<strong>初始化数据结构</strong>后传递回去的是一个<strong>万能指针类型</strong>，这样用户在得到该指针后，只能使用这个指针调用我们数据结构已经写好的功能，比如获取结点个数等之前可以直接通过指针操作获取的数据。</p>\n<p>在写数据结构的过程中，由于传递的是万能指针类型，所以实现各个功能都需要进行强转万能指针对数据结构进行操作，因为是自己实现数据结构，知道数据结构的类型因此可以通过强转进行操作，而用户则不能进行这种操作。</p>\n<p>而且封装的思想还体现在了<strong>插入数据</strong>时接收数据的形参也是万能指针，即我们写数据结构时无需考虑用户传递的数据类型，当实现遍历打印，按值删除这些需要<strong>明确清楚数据类型的功能</strong>时，在函数的形参中使用<strong>函数指针</strong>，这些<strong>回调函数</strong>均由用户去实现，我们的函数指针指向用户写好的回调函数后，根据返回值便可以对数据进行上述功能的实现了。</p>\n<h3 id=\"单向链表头文件\"><a href=\"#单向链表头文件\" class=\"headerlink\" title=\"单向链表头文件\"></a>单向链表头文件</h3><p><strong>这部分是重点！！！</strong></p>\n<p>增加了使用typedef给万能指针，函数指针重新命名的操作，目的是增加程序的可读性。而且不在头文件中定义数据结构了而是放到了实现文件中，也是封装的思想，<strong>让用户看到更少的细节</strong>，仅需要注重调用功能的实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用void*保护链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>* LList;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*FOREACH)</span><span class=\"params\">(<span class=\"keyword\">void</span>* )</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span><span class=\"params\">(*COMPARE)</span><span class=\"params\">(<span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化链表，不再返回指向链表指针类型</span></span><br><span class=\"line\">\t<span class=\"function\">LList <span class=\"title\">Init_LinkList</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//插入结点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">void</span>* data)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//遍历链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ForEach_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, FOREACH myfoeach)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//按位置删除结点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByPos_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> pos)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//按值删除结点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByValue_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, <span class=\"keyword\">void</span>* data, COMPARE compare)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//链表大小</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Size_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//清空链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Clear_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//销毁链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"单向链表实现文件\"><a href=\"#单向链表实现文件\" class=\"headerlink\" title=\"单向链表实现文件\"></a>单向链表实现文件</h3><h4 id=\"单向链表数据结构的定义\"><a href=\"#单向链表数据结构的定义\" class=\"headerlink\" title=\"单向链表数据结构的定义\"></a>单向链表数据结构的定义</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结点数据类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表数据类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> <span class=\"title\">header</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化链表，不再返回指向链表指针类型\"><a href=\"#初始化链表，不再返回指向链表指针类型\" class=\"headerlink\" title=\"初始化链表，不再返回指向链表指针类型\"></a>初始化链表，不再返回指向链表指针类型</h4><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LList Init_LinkList() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstruct LinkList* <span class=\"built_in\">list</span> = malloc(sizeof(struct LinkList));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">list</span>-&gt;<span class=\"keyword\">header</span>.next = <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">list</span>-&gt;<span class=\"keyword\">header</span>.<span class=\"built_in\">data</span> = <span class=\"built_in\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">list</span>-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"插入结点-比较重要\"><a href=\"#插入结点-比较重要\" class=\"headerlink\" title=\"插入结点(比较重要)\"></a>插入结点(比较重要)</h4><p>中间有两条语句是插入结点后重新连接链表的操作，因为没画图，就脑子想了想，结果debug了一个半小时，差点崩溃了，所以数据结构画图很重要啊！！</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Insert_LinkList(LList list, int pos, void* data) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == list) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == data) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//传入的list是void*类型，需要进行强转</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span></span>* myList = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span></span>*)list;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pos &lt; <span class=\"number\">0</span> || pos &gt; myList-&gt;size) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpos = myList-&gt;size;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//查找插入位置的前一个结点(重点！)</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span></span>* pCurrent = &amp;(myList-&gt;header);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; pos; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpCurrent = pCurrent-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span></span>* newNode = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span></span>));</span><br><span class=\"line\">\tnewNode-&gt;next = NULL;</span><br><span class=\"line\">\tnewNode-&gt;data = data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 插入结点，两条语句的先后顺序很关键，画图！！！再写</span></span><br><span class=\"line\">\tnewNode-&gt;next = pCurrent-&gt;next;</span><br><span class=\"line\">\tpCurrent-&gt;next = newNode;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmyList-&gt;size++;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"遍历链表\"><a href=\"#遍历链表\" class=\"headerlink\" title=\"遍历链表\"></a>遍历链表</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ForEach_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, FOREACH myfoeach)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == myfoeach) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//传入的list是void*类型，需要进行强转</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span>* <span class=\"title\">myList</span> = (<span class=\"title\">struct</span> <span class=\"title\">Links</span>*)<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pCurrent</span> = <span class=\"title\">myList</span>-&gt;<span class=\"title\">header</span>.<span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pCurrent != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\tmyfoeach(pCurrent-&gt;data);</span><br><span class=\"line\">\t\tpCurrent = pCurrent-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按位置删除结点\"><a href=\"#按位置删除结点\" class=\"headerlink\" title=\"按位置删除结点\"></a>按位置删除结点</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByPos_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> pos)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span>* <span class=\"title\">myList</span> = (<span class=\"title\">struct</span> <span class=\"title\">LinkList</span>*)<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pos &lt; <span class=\"number\">0</span> || pos &gt; myList-&gt;size) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 重点理解以下的pCurrent指针和for循环功能</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pCurrent</span> = &amp;(<span class=\"title\">myList</span>-&gt;<span class=\"title\">header</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//找到要删除的结点的前一个结点位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pos; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpCurrent = pCurrent-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将被删除结点的前驱结点和后继结点进行连接</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pDel</span> = <span class=\"title\">pCurrent</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">\tpCurrent-&gt;next = pDel-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(pDel);</span><br><span class=\"line\">\tpDel = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmyList-&gt;size--;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按值删除结点-比较重要\"><a href=\"#按值删除结点-比较重要\" class=\"headerlink\" title=\"按值删除结点(比较重要)\"></a>按值删除结点(比较重要)</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteByValue_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, <span class=\"keyword\">void</span>* data, COMPARE compare)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == data) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == compare) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span>* <span class=\"title\">myList</span> = (<span class=\"title\">struct</span> <span class=\"title\">LinkList</span>*)<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//两个辅助指针变量</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pPre</span> = &amp;(<span class=\"title\">myList</span>-&gt;<span class=\"title\">header</span>);</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pCurrent</span> = <span class=\"title\">myList</span>-&gt;<span class=\"title\">header</span>.<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pCurrent != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (compare(pCurrent-&gt;data, data)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 找到要删除的结点</span></span><br><span class=\"line\">\t\t\tpPre-&gt;next = pCurrent-&gt;next;\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpPre = pCurrent;</span><br><span class=\"line\">\t\tpCurrent = pCurrent-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//释放被删除的结点</span></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(pCurrent);</span><br><span class=\"line\">\tpCurrent = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmyList-&gt;size--;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"链表大小\"><a href=\"#链表大小\" class=\"headerlink\" title=\"链表大小\"></a>链表大小</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Size_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span>* <span class=\"title\">myList</span> = (<span class=\"title\">struct</span> <span class=\"title\">LinkList</span>*)<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> myList-&gt;size;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"清空链表\"><a href=\"#清空链表\" class=\"headerlink\" title=\"清空链表\"></a>清空链表</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Clear_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span>* <span class=\"title\">myList</span> = (<span class=\"title\">struct</span> <span class=\"title\">LinkList</span>*)<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pCurrent</span> = <span class=\"title\">myList</span>-&gt;<span class=\"title\">header</span>.<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pCurrent != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//先记录下一个结点的地址</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">pNext</span> = <span class=\"title\">pCurrent</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//释放当前结点的空间</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(pCurrent);</span><br><span class=\"line\">\t\tpCurrent = pNext;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmyList-&gt;header.next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将链表大小置为0</span></span><br><span class=\"line\">\tmyList-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"销毁链表\"><a href=\"#销毁链表\" class=\"headerlink\" title=\"销毁链表\"></a>销毁链表</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tClear_LinkList(<span class=\"built_in\">list</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">list</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"我认为比较重要的一个循环\"><a href=\"#我认为比较重要的一个循环\" class=\"headerlink\" title=\"我认为比较重要的一个循环\"></a>我认为比较重要的一个循环</h4><p>在插入和按位置删除结点都使用了这个循环，用途是找到<strong>需要操作的结点的前一个结点</strong>。</p>\n<figure class=\"highlight ocaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"type\">LinkNode</span>* pCurrent = &amp;(myList-&gt;header);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; pos; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    pCurrent = pCurrent-&gt;next;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单向链表测试文件\"><a href=\"#单向链表测试文件\" class=\"headerlink\" title=\"单向链表测试文件\"></a>单向链表测试文件</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于对链表遍历的数据进行转换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrint</span><span class=\"params\">(<span class=\"keyword\">void</span>* data)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>* <span class=\"title\">Data</span> = (<span class=\"title\">struct</span> <span class=\"title\">Person</span>*)<span class=\"title\">data</span>;</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"name: %s age: %d\\n\"</span>, Data-&gt;name, Data-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于对按值删除的数据进行比较</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">myCompare</span><span class=\"params\">(<span class=\"keyword\">void</span>* pre, <span class=\"keyword\">void</span>* cur)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>* <span class=\"title\">p1</span> = (<span class=\"title\">struct</span> <span class=\"title\">Person</span>*)<span class=\"title\">pre</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>* <span class=\"title\">p2</span> = (<span class=\"title\">struct</span> <span class=\"title\">Person</span>*)<span class=\"title\">cur</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"built_in\">strcmp</span>(p1-&gt;name, p2-&gt;name) == <span class=\"number\">0</span>) &amp;&amp; (p1-&gt;age == p2-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p1</span> = &#123;</span> <span class=\"string\">\"aa\"</span>,<span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p2</span> = &#123;</span> <span class=\"string\">\"bb\"</span>,<span class=\"number\">2</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p3</span> = &#123;</span> <span class=\"string\">\"cc\"</span>,<span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p4</span> = &#123;</span> <span class=\"string\">\"dd\"</span>,<span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p5</span> = &#123;</span> <span class=\"string\">\"ee\"</span>,<span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p6</span> = &#123;</span> <span class=\"string\">\"ff\"</span>,<span class=\"number\">6</span> &#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">p7</span> = &#123;</span> <span class=\"string\">\"gg\"</span>,<span class=\"number\">7</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化链表</span></span><br><span class=\"line\">\tLList testList = Init_LinkList();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 插入数据</span></span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">0</span>, &amp;p1);</span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">1</span>, &amp;p2);</span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">2</span>, &amp;p3);</span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">3</span>, &amp;p4);</span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">4</span>, &amp;p5);</span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">5</span>, &amp;p6);</span><br><span class=\"line\">\tInsert_LinkList(testList, <span class=\"number\">6</span>, &amp;p7);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"链表大小初始为 %d \\n\"</span>, Size_LinkList(testList));</span><br><span class=\"line\"></span><br><span class=\"line\">\tForEach_LinkList(testList, myPrint);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"-----------------\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//按位置删除</span></span><br><span class=\"line\">\tDeleteByPos_LinkList(testList, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tForEach_LinkList(testList, myPrint);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"-----------------\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//按值删除</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">testDel</span> = &#123;</span> <span class=\"string\">\"gg\"</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">\tDeleteByValue_LinkList(testList, &amp;testDel, myCompare);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tForEach_LinkList(testList, myPrint);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"-----------------\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"链表大小为 %d \\n\"</span>, Size_LinkList(testList));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//清空链表</span></span><br><span class=\"line\">\tClear_LinkList(testList);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"清空后链表大小为 %d \\n\"</span>, Size_LinkList(testList));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//销毁链表</span></span><br><span class=\"line\">\tDestroy_LinkList(testList);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\ttest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试输出如下：<br><img src=\"https://miao.su/images/2019/07/19/6607952a5f706902e176b84c1cbcca38405c.png\" alt=\"6607952a5f706902e176b84c1cbcca38405c.png\"><br>PS:一周了，多写一篇周记吧。</p>"},{"title":"Holiday Note_08","date":"2019-07-20T12:53:34.000Z","_content":"\n# Holiday Note_08\n\n又学了一种**单向链表**的写法，链表不再存储数据的地址，而是在定义数据类型时，预留一个存放结点的空间。即可以通过数据头部的结点指向将数据连接起来存储为链表结构，以这种方式实现链表的各种方法减少了代码量(不再需要每次分配，释放结点空间)。还学习了**链式栈**和**顺序栈**，链式栈和链表很像，就是插入删除结点的逻辑变成了先进后出，且插入删除结点在头结点方向进行，头结点始终指向栈顶元素。顺序栈的话和数组差不多，都挺简单的。\n\n<!-- more -->\n\n---\n\n## 单向链表\n\n该链表**结点不再将数据存储在链表结点中**，而是在定义数据时预留4字节空间存放链表结点，通过这种方法定义的链表结构操作会更加方便。其实也不一定说一定是4字节，这只是单向链表的写法，因此具体预留多少字节根据定义的结点类型而定。\n\n以下为此单向链表的结构定义\n~~~\ntypedef void(*FOREACH)(void*);\ntypedef void* LList;\n\n// 链表结点\nstruct LinkNode {\n\tstruct LinkNode* next;\n};\n\n// 链表结构\nstruct LinkList {\n\tstruct LinkNode header;//头结点\n\tint size;\n};\n~~~\n\n对比一下昨天实现的另外一种单向链表的结构定义\n~~~\n// 结点数据类型\nstruct LinkNode {\n\tvoid* data;\n\tstruct LinkNode* next;\n};\n\n// 链表数据类型\nstruct LinkList {\n\tstruct LinkNode header;\n\tint size;\n};\n~~~\n\n因此在使用前者的链表结构时，数据定义也有所变化\n~~~\n//用户定义的数据类型需要预留空间\nstruct Person {\n\t//关键理解预留空间起到的作用，切记这个结点不能使用指针类型\n\t//若使用指针类型则为4字节空间，而如果结点数据结构中有两个指针则写法错误\n\tstruct LinkNode node;\n\t//以下才为用户的数据\n\tchar name[64];\n\tint age;\n};\n~~~\n\n下面说一下这种链表在**插入**和**删除**结点的优势\n\n这种链表的插入方式与之前实现的链表相比简化了不少，无需再进行对新结点内存空间的分配，因为插入一个新结点，通过改变插入位置的前驱和后继结点数据预留空间中指针的指向即可。\n\n还有一点，使用void* 接收数据和使用struct LinkNode* 接收数据的结果是一样的，都是将数据的前四个预留字节指针进行重新指向但是若选用struct LinkNode* 做参数，用户传递数据时需要额外多一步强转，导致步骤繁琐增加了操作的细节。\n~~~\nvoid Insert_LinkList(LList list, int pos, void* data) {\n\n//不同的步骤，将数据转换为结点类型，这样只操作数据首地址后边预留的空间并不会涉及到对数据进行修改\nstruct LinkNode* newNode = (struct LinkNode*)data;\n\n}\n~~~\n\n---\n\n## 顺序栈\n\n顺序栈的定义如下，和数组很相似了。\n\n同样，使用万能指针去存储数据时很方便，不管用户传入什么类型的数据都可以进行指向\n~~~\n#define MAX 1024\ntypedef void* SeqStack;\t\n// 栈的顺序存储结构\nstruct SequenceStack {\n\tvoid* data[MAX];\n\tint size;\n};\n\n// 将数组下标高的一端当作栈顶一端，因为这样插入和删除元素不需要移动数组元素\n~~~\n\n\n对栈进行操作中，入栈，出栈，栈顶元素是十分常用的。\n~~~\n//初始化栈\nSeqStack Init_SequenceStack();\n\n//入栈\nvoid Push_SequenceStack(SeqStack stack, void* data);\n\n//出栈 \nvoid Pop_SequenceStack(SeqStack stack);\n\n//获得栈顶元素\nvoid* Top_SequenceStack(SeqStack stack);\n\n//获得栈的大小\nint Size_SequenceStack(SeqStack stack);\n\n//销毁栈\nvoid Destroy_SequenceStack(SeqStack stack);\n~~~\n\n入栈操作时，存入数据的代码，存入前需要判断是否空间已满，这不是链表，数据结构的空间大小需要提前定义。\n~~~\nmyStack->data[myStack->size++] = data;\n~~~\n\n获得栈顶元素时，注意下标为size-1\n~~~\nreturn myStack->data[myStack->size -1 ];\n~~~\n\n销毁栈时，free掉的stack虽然是万能指针类型而不是实际栈的数据类型，但是实际上，分配给栈数据结构的空间实际已经被释放，这部分比较深奥，涉及到了编译器的深层次知识，暂时不考虑实现细节。\n~~~\nfree(stack);\nstack = NULL;\n~~~\n\n**栈没有遍历的操作，因为要想遍历就需要弹出**，因此测试打印栈的所有元素时，需要使用循环，当栈内的元素大于0时执行以下操作：1、获得栈顶元素，并将其强转为自己定义的数据类型结构进行打印其存储的数据；2、**进行出栈操作**\n~~~\nwhile (Size_SequenceStack(testStack) > 0) {\n\n\tstruct Person* person = (struct Person*)Top_SequenceStack(testStack);\n\n\tprintf(\"Name: %s Age: %d\\n\", person->name, person->age);\n\n\tPop_SequenceStack(testStack);\n}\n~~~\n\n---\n\n## 链式栈\n\n实现的方式为今天学习的新的单向链表方式，不过是在此单向链表的基础上制定了先进后出的规定。\n\n定义与链表一致\n~~~\ntypedef void* LStack;\n\nstruct LinkNode {\n\tstruct LinkNode* next;\n};\n\nstruct LinkStack {\n\tstruct LinkNode head;\n\tint size;\n};\t\n~~~\n\n定义的函数功能与上方的顺序栈一致，都是那几个功能。\n\n我认为比较重点的是入栈的操作，因为这是链表，需要理清楚**新插入结点后如何让栈顶是链表的第一个结点，且链表头结点始终指向的是栈顶结点这一逻辑**，最好画个图就明白了，有一点点绕，因为之前没有接触过链式栈。\n\n以下为入栈的一些重要步骤\n~~~\nvoid Push_LinkStack(LStack stack, void* data) {\n\nstruct LinkStack* myStack = (struct LinkStack*)stack;\n\n//重点是以下三条语句，让新插入的每一个结点都在栈顶，且head永远指向栈顶从而达到链式栈的特点。\nstruct LinkNode* newNode = (struct LinkNode*)data;\nnewNode->next = myStack->head.next;\nmyStack->head.next = newNode;\n\nmyStack->size++;\n\n}\n~~~\n\n理解了入栈，其实出栈逻辑就很清楚了，核心语句如下\n~~~\nmyStack->head.next = myStack->head.next->next;\n~~~\n\nPS:眼睛痛死了，眼药水没起作用，怎样才能看一整天电脑眼睛很舒服，我明明一直开着显示器的comfort view模式的。。。不是蓝光的原因么？\n\n\n\n","source":"_posts/2019-Holiday-Note-08.md","raw":"---\ntitle: Holiday Note_08\ndate: 2019-07-20 20:53:34\ncategories: C\ntags: [Note,C,DataStructure]\n---\n\n# Holiday Note_08\n\n又学了一种**单向链表**的写法，链表不再存储数据的地址，而是在定义数据类型时，预留一个存放结点的空间。即可以通过数据头部的结点指向将数据连接起来存储为链表结构，以这种方式实现链表的各种方法减少了代码量(不再需要每次分配，释放结点空间)。还学习了**链式栈**和**顺序栈**，链式栈和链表很像，就是插入删除结点的逻辑变成了先进后出，且插入删除结点在头结点方向进行，头结点始终指向栈顶元素。顺序栈的话和数组差不多，都挺简单的。\n\n<!-- more -->\n\n---\n\n## 单向链表\n\n该链表**结点不再将数据存储在链表结点中**，而是在定义数据时预留4字节空间存放链表结点，通过这种方法定义的链表结构操作会更加方便。其实也不一定说一定是4字节，这只是单向链表的写法，因此具体预留多少字节根据定义的结点类型而定。\n\n以下为此单向链表的结构定义\n~~~\ntypedef void(*FOREACH)(void*);\ntypedef void* LList;\n\n// 链表结点\nstruct LinkNode {\n\tstruct LinkNode* next;\n};\n\n// 链表结构\nstruct LinkList {\n\tstruct LinkNode header;//头结点\n\tint size;\n};\n~~~\n\n对比一下昨天实现的另外一种单向链表的结构定义\n~~~\n// 结点数据类型\nstruct LinkNode {\n\tvoid* data;\n\tstruct LinkNode* next;\n};\n\n// 链表数据类型\nstruct LinkList {\n\tstruct LinkNode header;\n\tint size;\n};\n~~~\n\n因此在使用前者的链表结构时，数据定义也有所变化\n~~~\n//用户定义的数据类型需要预留空间\nstruct Person {\n\t//关键理解预留空间起到的作用，切记这个结点不能使用指针类型\n\t//若使用指针类型则为4字节空间，而如果结点数据结构中有两个指针则写法错误\n\tstruct LinkNode node;\n\t//以下才为用户的数据\n\tchar name[64];\n\tint age;\n};\n~~~\n\n下面说一下这种链表在**插入**和**删除**结点的优势\n\n这种链表的插入方式与之前实现的链表相比简化了不少，无需再进行对新结点内存空间的分配，因为插入一个新结点，通过改变插入位置的前驱和后继结点数据预留空间中指针的指向即可。\n\n还有一点，使用void* 接收数据和使用struct LinkNode* 接收数据的结果是一样的，都是将数据的前四个预留字节指针进行重新指向但是若选用struct LinkNode* 做参数，用户传递数据时需要额外多一步强转，导致步骤繁琐增加了操作的细节。\n~~~\nvoid Insert_LinkList(LList list, int pos, void* data) {\n\n//不同的步骤，将数据转换为结点类型，这样只操作数据首地址后边预留的空间并不会涉及到对数据进行修改\nstruct LinkNode* newNode = (struct LinkNode*)data;\n\n}\n~~~\n\n---\n\n## 顺序栈\n\n顺序栈的定义如下，和数组很相似了。\n\n同样，使用万能指针去存储数据时很方便，不管用户传入什么类型的数据都可以进行指向\n~~~\n#define MAX 1024\ntypedef void* SeqStack;\t\n// 栈的顺序存储结构\nstruct SequenceStack {\n\tvoid* data[MAX];\n\tint size;\n};\n\n// 将数组下标高的一端当作栈顶一端，因为这样插入和删除元素不需要移动数组元素\n~~~\n\n\n对栈进行操作中，入栈，出栈，栈顶元素是十分常用的。\n~~~\n//初始化栈\nSeqStack Init_SequenceStack();\n\n//入栈\nvoid Push_SequenceStack(SeqStack stack, void* data);\n\n//出栈 \nvoid Pop_SequenceStack(SeqStack stack);\n\n//获得栈顶元素\nvoid* Top_SequenceStack(SeqStack stack);\n\n//获得栈的大小\nint Size_SequenceStack(SeqStack stack);\n\n//销毁栈\nvoid Destroy_SequenceStack(SeqStack stack);\n~~~\n\n入栈操作时，存入数据的代码，存入前需要判断是否空间已满，这不是链表，数据结构的空间大小需要提前定义。\n~~~\nmyStack->data[myStack->size++] = data;\n~~~\n\n获得栈顶元素时，注意下标为size-1\n~~~\nreturn myStack->data[myStack->size -1 ];\n~~~\n\n销毁栈时，free掉的stack虽然是万能指针类型而不是实际栈的数据类型，但是实际上，分配给栈数据结构的空间实际已经被释放，这部分比较深奥，涉及到了编译器的深层次知识，暂时不考虑实现细节。\n~~~\nfree(stack);\nstack = NULL;\n~~~\n\n**栈没有遍历的操作，因为要想遍历就需要弹出**，因此测试打印栈的所有元素时，需要使用循环，当栈内的元素大于0时执行以下操作：1、获得栈顶元素，并将其强转为自己定义的数据类型结构进行打印其存储的数据；2、**进行出栈操作**\n~~~\nwhile (Size_SequenceStack(testStack) > 0) {\n\n\tstruct Person* person = (struct Person*)Top_SequenceStack(testStack);\n\n\tprintf(\"Name: %s Age: %d\\n\", person->name, person->age);\n\n\tPop_SequenceStack(testStack);\n}\n~~~\n\n---\n\n## 链式栈\n\n实现的方式为今天学习的新的单向链表方式，不过是在此单向链表的基础上制定了先进后出的规定。\n\n定义与链表一致\n~~~\ntypedef void* LStack;\n\nstruct LinkNode {\n\tstruct LinkNode* next;\n};\n\nstruct LinkStack {\n\tstruct LinkNode head;\n\tint size;\n};\t\n~~~\n\n定义的函数功能与上方的顺序栈一致，都是那几个功能。\n\n我认为比较重点的是入栈的操作，因为这是链表，需要理清楚**新插入结点后如何让栈顶是链表的第一个结点，且链表头结点始终指向的是栈顶结点这一逻辑**，最好画个图就明白了，有一点点绕，因为之前没有接触过链式栈。\n\n以下为入栈的一些重要步骤\n~~~\nvoid Push_LinkStack(LStack stack, void* data) {\n\nstruct LinkStack* myStack = (struct LinkStack*)stack;\n\n//重点是以下三条语句，让新插入的每一个结点都在栈顶，且head永远指向栈顶从而达到链式栈的特点。\nstruct LinkNode* newNode = (struct LinkNode*)data;\nnewNode->next = myStack->head.next;\nmyStack->head.next = newNode;\n\nmyStack->size++;\n\n}\n~~~\n\n理解了入栈，其实出栈逻辑就很清楚了，核心语句如下\n~~~\nmyStack->head.next = myStack->head.next->next;\n~~~\n\nPS:眼睛痛死了，眼药水没起作用，怎样才能看一整天电脑眼睛很舒服，我明明一直开着显示器的comfort view模式的。。。不是蓝光的原因么？\n\n\n\n","slug":"2019-Holiday-Note-08","published":1,"updated":"2019-07-20T13:45:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihj000ksmjb45lu6g5b","content":"<h1 id=\"Holiday-Note-08\"><a href=\"#Holiday-Note-08\" class=\"headerlink\" title=\"Holiday Note_08\"></a>Holiday Note_08</h1><p>又学了一种<strong>单向链表</strong>的写法，链表不再存储数据的地址，而是在定义数据类型时，预留一个存放结点的空间。即可以通过数据头部的结点指向将数据连接起来存储为链表结构，以这种方式实现链表的各种方法减少了代码量(不再需要每次分配，释放结点空间)。还学习了<strong>链式栈</strong>和<strong>顺序栈</strong>，链式栈和链表很像，就是插入删除结点的逻辑变成了先进后出，且插入删除结点在头结点方向进行，头结点始终指向栈顶元素。顺序栈的话和数组差不多，都挺简单的。</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h2><p>该链表<strong>结点不再将数据存储在链表结点中</strong>，而是在定义数据时预留4字节空间存放链表结点，通过这种方法定义的链表结构操作会更加方便。其实也不一定说一定是4字节，这只是单向链表的写法，因此具体预留多少字节根据定义的结点类型而定。</p>\n<p>以下为此单向链表的结构定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*FOREACH)</span><span class=\"params\">(<span class=\"keyword\">void</span>*)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>* LList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表结点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> <span class=\"title\">header</span>;</span><span class=\"comment\">//头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>对比一下昨天实现的另外一种单向链表的结构定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结点数据类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表数据类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> <span class=\"title\">header</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>因此在使用前者的链表结构时，数据定义也有所变化</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用户定义的数据类型需要预留空间</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//关键理解预留空间起到的作用，切记这个结点不能使用指针类型</span></span><br><span class=\"line\">\t<span class=\"comment\">//若使用指针类型则为4字节空间，而如果结点数据结构中有两个指针则写法错误</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> <span class=\"title\">node</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">//以下才为用户的数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>下面说一下这种链表在<strong>插入</strong>和<strong>删除</strong>结点的优势</p>\n<p>这种链表的插入方式与之前实现的链表相比简化了不少，无需再进行对新结点内存空间的分配，因为插入一个新结点，通过改变插入位置的前驱和后继结点数据预留空间中指针的指向即可。</p>\n<p>还有一点，使用void* 接收数据和使用struct LinkNode* 接收数据的结果是一样的，都是将数据的前四个预留字节指针进行重新指向但是若选用struct LinkNode* 做参数，用户传递数据时需要额外多一步强转，导致步骤繁琐增加了操作的细节。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">void</span>* data)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不同的步骤，将数据转换为结点类型，这样只操作数据首地址后边预留的空间并不会涉及到对数据进行修改</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">newNode</span> = (<span class=\"title\">struct</span> <span class=\"title\">LinkNode</span>*)<span class=\"title\">data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"顺序栈\"><a href=\"#顺序栈\" class=\"headerlink\" title=\"顺序栈\"></a>顺序栈</h2><p>顺序栈的定义如下，和数组很相似了。</p>\n<p>同样，使用万能指针去存储数据时很方便，不管用户传入什么类型的数据都可以进行指向</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 1024</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>* SeqStack;\t</span><br><span class=\"line\"><span class=\"comment\">// 栈的顺序存储结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SequenceStack</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* data[MAX];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将数组下标高的一端当作栈顶一端，因为这样插入和删除元素不需要移动数组元素</span></span><br></pre></td></tr></table></figure>\n\n<p>对栈进行操作中，入栈，出栈，栈顶元素是十分常用的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化栈</span></span><br><span class=\"line\"><span class=\"function\">SeqStack <span class=\"title\">Init_SequenceStack</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//入栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Push_SequenceStack</span><span class=\"params\">(SeqStack <span class=\"built_in\">stack</span>, <span class=\"keyword\">void</span>* data)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//出栈 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pop_SequenceStack</span><span class=\"params\">(SeqStack <span class=\"built_in\">stack</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获得栈顶元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">Top_SequenceStack</span><span class=\"params\">(SeqStack <span class=\"built_in\">stack</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获得栈的大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Size_SequenceStack</span><span class=\"params\">(SeqStack <span class=\"built_in\">stack</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//销毁栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy_SequenceStack</span><span class=\"params\">(SeqStack <span class=\"built_in\">stack</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>入栈操作时，存入数据的代码，存入前需要判断是否空间已满，这不是链表，数据结构的空间大小需要提前定义。</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">myStack</span>-&gt;</span><span class=\"function\"><span class=\"title\">data</span>[myStack-&gt;</span>size++] = <span class=\"keyword\">data</span>;</span><br></pre></td></tr></table></figure>\n\n<p>获得栈顶元素时，注意下标为size-1</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">return</span> myStack-&gt;</span><span class=\"function\"><span class=\"title\">data</span>[myStack-&gt;</span>size -<span class=\"number\">1</span> ];</span><br></pre></td></tr></table></figure>\n\n<p>销毁栈时，free掉的stack虽然是万能指针类型而不是实际栈的数据类型，但是实际上，分配给栈数据结构的空间实际已经被释放，这部分比较深奥，涉及到了编译器的深层次知识，暂时不考虑实现细节。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">free</span>(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\"><span class=\"built_in\">stack</span> = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>栈没有遍历的操作，因为要想遍历就需要弹出</strong>，因此测试打印栈的所有元素时，需要使用循环，当栈内的元素大于0时执行以下操作：1、获得栈顶元素，并将其强转为自己定义的数据类型结构进行打印其存储的数据；2、<strong>进行出栈操作</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (Size_SequenceStack(testStack) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>* person = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)Top_SequenceStack(testStack);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"Name: %s Age: %d\\n\"</span>, person-&gt;name, person-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">\tPop_SequenceStack(testStack);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"链式栈\"><a href=\"#链式栈\" class=\"headerlink\" title=\"链式栈\"></a>链式栈</h2><p>实现的方式为今天学习的新的单向链表方式，不过是在此单向链表的基础上制定了先进后出的规定。</p>\n<p>定义与链表一致</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>* LStack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkStack</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> <span class=\"title\">head</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>定义的函数功能与上方的顺序栈一致，都是那几个功能。</p>\n<p>我认为比较重点的是入栈的操作，因为这是链表，需要理清楚<strong>新插入结点后如何让栈顶是链表的第一个结点，且链表头结点始终指向的是栈顶结点这一逻辑</strong>，最好画个图就明白了，有一点点绕，因为之前没有接触过链式栈。</p>\n<p>以下为入栈的一些重要步骤</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Push_LinkStack(LStack stack, void* data) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkStack</span></span>* myStack = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkStack</span></span>*)stack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//重点是以下三条语句，让新插入的每一个结点都在栈顶，且head永远指向栈顶从而达到链式栈的特点。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span></span>* newNode = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span></span>*)data;</span><br><span class=\"line\">newNode-&gt;next = myStack-&gt;head.next;</span><br><span class=\"line\">myStack-&gt;head.next = newNode;</span><br><span class=\"line\"></span><br><span class=\"line\">myStack-&gt;size++;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>理解了入栈，其实出栈逻辑就很清楚了，核心语句如下</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">myStack</span>-&gt;</span><span class=\"function\"><span class=\"title\">head</span>.next = myStack-&gt;</span><span class=\"function\"><span class=\"title\">head</span>.next-&gt;</span>next;</span><br></pre></td></tr></table></figure>\n\n<p>PS:眼睛痛死了，眼药水没起作用，怎样才能看一整天电脑眼睛很舒服，我明明一直开着显示器的comfort view模式的。。。不是蓝光的原因么？</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-08\"><a href=\"#Holiday-Note-08\" class=\"headerlink\" title=\"Holiday Note_08\"></a>Holiday Note_08</h1><p>又学了一种<strong>单向链表</strong>的写法，链表不再存储数据的地址，而是在定义数据类型时，预留一个存放结点的空间。即可以通过数据头部的结点指向将数据连接起来存储为链表结构，以这种方式实现链表的各种方法减少了代码量(不再需要每次分配，释放结点空间)。还学习了<strong>链式栈</strong>和<strong>顺序栈</strong>，链式栈和链表很像，就是插入删除结点的逻辑变成了先进后出，且插入删除结点在头结点方向进行，头结点始终指向栈顶元素。顺序栈的话和数组差不多，都挺简单的。</p>","more":"<hr>\n<h2 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h2><p>该链表<strong>结点不再将数据存储在链表结点中</strong>，而是在定义数据时预留4字节空间存放链表结点，通过这种方法定义的链表结构操作会更加方便。其实也不一定说一定是4字节，这只是单向链表的写法，因此具体预留多少字节根据定义的结点类型而定。</p>\n<p>以下为此单向链表的结构定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*FOREACH)</span><span class=\"params\">(<span class=\"keyword\">void</span>*)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>* LList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表结点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> <span class=\"title\">header</span>;</span><span class=\"comment\">//头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>对比一下昨天实现的另外一种单向链表的结构定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结点数据类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表数据类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> <span class=\"title\">header</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>因此在使用前者的链表结构时，数据定义也有所变化</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用户定义的数据类型需要预留空间</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//关键理解预留空间起到的作用，切记这个结点不能使用指针类型</span></span><br><span class=\"line\">\t<span class=\"comment\">//若使用指针类型则为4字节空间，而如果结点数据结构中有两个指针则写法错误</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> <span class=\"title\">node</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">//以下才为用户的数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>下面说一下这种链表在<strong>插入</strong>和<strong>删除</strong>结点的优势</p>\n<p>这种链表的插入方式与之前实现的链表相比简化了不少，无需再进行对新结点内存空间的分配，因为插入一个新结点，通过改变插入位置的前驱和后继结点数据预留空间中指针的指向即可。</p>\n<p>还有一点，使用void* 接收数据和使用struct LinkNode* 接收数据的结果是一样的，都是将数据的前四个预留字节指针进行重新指向但是若选用struct LinkNode* 做参数，用户传递数据时需要额外多一步强转，导致步骤繁琐增加了操作的细节。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert_LinkList</span><span class=\"params\">(LList <span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">void</span>* data)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不同的步骤，将数据转换为结点类型，这样只操作数据首地址后边预留的空间并不会涉及到对数据进行修改</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">newNode</span> = (<span class=\"title\">struct</span> <span class=\"title\">LinkNode</span>*)<span class=\"title\">data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"顺序栈\"><a href=\"#顺序栈\" class=\"headerlink\" title=\"顺序栈\"></a>顺序栈</h2><p>顺序栈的定义如下，和数组很相似了。</p>\n<p>同样，使用万能指针去存储数据时很方便，不管用户传入什么类型的数据都可以进行指向</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 1024</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>* SeqStack;\t</span><br><span class=\"line\"><span class=\"comment\">// 栈的顺序存储结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SequenceStack</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* data[MAX];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将数组下标高的一端当作栈顶一端，因为这样插入和删除元素不需要移动数组元素</span></span><br></pre></td></tr></table></figure>\n\n<p>对栈进行操作中，入栈，出栈，栈顶元素是十分常用的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化栈</span></span><br><span class=\"line\"><span class=\"function\">SeqStack <span class=\"title\">Init_SequenceStack</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//入栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Push_SequenceStack</span><span class=\"params\">(SeqStack <span class=\"built_in\">stack</span>, <span class=\"keyword\">void</span>* data)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//出栈 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pop_SequenceStack</span><span class=\"params\">(SeqStack <span class=\"built_in\">stack</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获得栈顶元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">Top_SequenceStack</span><span class=\"params\">(SeqStack <span class=\"built_in\">stack</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获得栈的大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Size_SequenceStack</span><span class=\"params\">(SeqStack <span class=\"built_in\">stack</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//销毁栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy_SequenceStack</span><span class=\"params\">(SeqStack <span class=\"built_in\">stack</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>入栈操作时，存入数据的代码，存入前需要判断是否空间已满，这不是链表，数据结构的空间大小需要提前定义。</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">myStack</span>-&gt;</span><span class=\"function\"><span class=\"title\">data</span>[myStack-&gt;</span>size++] = <span class=\"keyword\">data</span>;</span><br></pre></td></tr></table></figure>\n\n<p>获得栈顶元素时，注意下标为size-1</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">return</span> myStack-&gt;</span><span class=\"function\"><span class=\"title\">data</span>[myStack-&gt;</span>size -<span class=\"number\">1</span> ];</span><br></pre></td></tr></table></figure>\n\n<p>销毁栈时，free掉的stack虽然是万能指针类型而不是实际栈的数据类型，但是实际上，分配给栈数据结构的空间实际已经被释放，这部分比较深奥，涉及到了编译器的深层次知识，暂时不考虑实现细节。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">free</span>(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\"><span class=\"built_in\">stack</span> = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>栈没有遍历的操作，因为要想遍历就需要弹出</strong>，因此测试打印栈的所有元素时，需要使用循环，当栈内的元素大于0时执行以下操作：1、获得栈顶元素，并将其强转为自己定义的数据类型结构进行打印其存储的数据；2、<strong>进行出栈操作</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (Size_SequenceStack(testStack) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>* person = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span></span>*)Top_SequenceStack(testStack);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(<span class=\"string\">\"Name: %s Age: %d\\n\"</span>, person-&gt;name, person-&gt;age);</span><br><span class=\"line\"></span><br><span class=\"line\">\tPop_SequenceStack(testStack);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"链式栈\"><a href=\"#链式栈\" class=\"headerlink\" title=\"链式栈\"></a>链式栈</h2><p>实现的方式为今天学习的新的单向链表方式，不过是在此单向链表的基础上制定了先进后出的规定。</p>\n<p>定义与链表一致</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>* LStack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkStack</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> <span class=\"title\">head</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>定义的函数功能与上方的顺序栈一致，都是那几个功能。</p>\n<p>我认为比较重点的是入栈的操作，因为这是链表，需要理清楚<strong>新插入结点后如何让栈顶是链表的第一个结点，且链表头结点始终指向的是栈顶结点这一逻辑</strong>，最好画个图就明白了，有一点点绕，因为之前没有接触过链式栈。</p>\n<p>以下为入栈的一些重要步骤</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Push_LinkStack(LStack stack, void* data) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkStack</span></span>* myStack = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkStack</span></span>*)stack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//重点是以下三条语句，让新插入的每一个结点都在栈顶，且head永远指向栈顶从而达到链式栈的特点。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span></span>* newNode = (<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span></span>*)data;</span><br><span class=\"line\">newNode-&gt;next = myStack-&gt;head.next;</span><br><span class=\"line\">myStack-&gt;head.next = newNode;</span><br><span class=\"line\"></span><br><span class=\"line\">myStack-&gt;size++;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>理解了入栈，其实出栈逻辑就很清楚了，核心语句如下</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">myStack</span>-&gt;</span><span class=\"function\"><span class=\"title\">head</span>.next = myStack-&gt;</span><span class=\"function\"><span class=\"title\">head</span>.next-&gt;</span>next;</span><br></pre></td></tr></table></figure>\n\n<p>PS:眼睛痛死了，眼药水没起作用，怎样才能看一整天电脑眼睛很舒服，我明明一直开着显示器的comfort view模式的。。。不是蓝光的原因么？</p>"},{"title":"Holiday Note_09","date":"2019-07-21T12:06:44.000Z","_content":"\n# Holiday Note_09\n\n**二叉树**，递归递归递归。纸上画了一遍递归遍历二叉树的函数调用全过程😵。值得注意的是，拷贝二叉树时，需要使用malloc给每一个结点分配内存，否则函数结束栈区内存销毁，拷贝的数据均会消失。\n\n<!-- more -->\n\n## 二叉树的结构定义\n~~~\nstruct BinaryTreeNode {\n\tchar ch;//简单定义的一个数据类型，不够规范。\n\tstruct BinaryTreeNode* left;\n\tstruct BinaryTreeNode* right;\n};\n~~~\n\n\n## 遍历\n\n以中序遍历为例，思路为：要想进行中序遍历，先要遍历根节点的左子树，再遍历右子树，最后是根。要想遍历根节点的左子树，要先遍历根结点的左子树的左子树，再遍历根结点的左子树的右子树，再是根节点的左子树。。。循环反复，结点为空返回。\n~~~\nvoid recursion(struct BinaryTreeNode* root) {\n\n\t//返回条件\n\tif (NULL == root) {\n\t\treturn;\n\t}\n\n\t//此为先序遍历打印\n\tprintf(\"%c \", root->ch);\n\trecursion(root->left);\n\trecursion(root->right);\n\n\t//此为中序遍历打印\n\trecursion(root->left);\n\tprintf(\"%c \", root->ch);\n\trecursion(root->right);\n\n\t//此为后序遍历打印\n\trecursion(root->left);\n\trecursion(root->right);\n\tprintf(\"%c \", root->ch);\n}\n~~~\n\n## 求二叉树的叶子数\n\n叶子即没有左子树和右子树的结点。和遍历整颗二叉树的思路相同，只不过多了一个判断条件对叶子数进行记录。\n~~~\nvoid getTreeLeafNumber(struct BinaryTreeNode* root, int* leafNum) {\n\n\tif (NULL == root) {\n\t\treturn;\n\t}\n\n\tif (root->left == NULL && root->right == NULL) {\n\t\t//*和++运算等级一样，因此注意加括号\n\t\t(*leafNum)++;\n\t}\n\n\tgetTreeLeafNumber(root->left, leafNum);\n\tgetTreeLeafNumber(root->right, leafNum);\n\n}\n~~~\n\n## 二叉树高度\n\n高度简单理解为一颗树向下延申的最高层数，根节点记为一层，有子节点增加一层以此类推。\n\n思路为：要想知道这颗二叉树的高度，就要知道左子树和右子树的高度分别为多少，对其比较取最大值。每一个结点都是一棵树，理解这个就明白了。\n~~~\nint getBinaryHeight(struct BinaryTreeNode* root) {\n\n\tif (NULL == root) {\n\t\treturn 0;\n\t}\n\n\tint leftHeight = getBinaryHeight(root->left);\n\tint rightHeight = getBinaryHeight(root->right);\n\n\tint height = leftHeight > rightHeight ? leftHeight + 1 : rightHeight + 1;\n\n\treturn height;\n\n}\n~~~\n\n## 二叉树的拷贝\n\n注意，需要**对每一个拷贝的结点分配空间**，因此对应分配空间必定需要**释放空间**。\n\n如果不分配空间的话，拷贝的只是一块不再是原先存放拷贝内容的地址了，这是**内存的四区模型**知识点，切记。\n~~~\nstruct BinaryTreeNode* copyTree(struct BinaryTreeNode* root) {\n\n\tif (NULL == root) {\n\t\treturn NULL;\n\t}\n\n\tstruct BinaryTreeNode* left = copyTree(root->left);\n\tstruct BinaryTreeNode* right = copyTree(root->right);\n\n\tstruct BinaryTreeNode* node = malloc(sizeof(struct BinaryTreeNode));\n\n\tnode->left = left;\n\tnode->right = right;\n\tnode->ch = root->ch;\n\n\treturn node;\n\n}\n~~~\n\nPS:准备换电脑了💻","source":"_posts/2019-Holiday-Note-09.md","raw":"---\ntitle: Holiday Note_09\ndate: 2019-07-21 20:06:44\ncategories: C\ntags: [Note,C,DataStructure]\n---\n\n# Holiday Note_09\n\n**二叉树**，递归递归递归。纸上画了一遍递归遍历二叉树的函数调用全过程😵。值得注意的是，拷贝二叉树时，需要使用malloc给每一个结点分配内存，否则函数结束栈区内存销毁，拷贝的数据均会消失。\n\n<!-- more -->\n\n## 二叉树的结构定义\n~~~\nstruct BinaryTreeNode {\n\tchar ch;//简单定义的一个数据类型，不够规范。\n\tstruct BinaryTreeNode* left;\n\tstruct BinaryTreeNode* right;\n};\n~~~\n\n\n## 遍历\n\n以中序遍历为例，思路为：要想进行中序遍历，先要遍历根节点的左子树，再遍历右子树，最后是根。要想遍历根节点的左子树，要先遍历根结点的左子树的左子树，再遍历根结点的左子树的右子树，再是根节点的左子树。。。循环反复，结点为空返回。\n~~~\nvoid recursion(struct BinaryTreeNode* root) {\n\n\t//返回条件\n\tif (NULL == root) {\n\t\treturn;\n\t}\n\n\t//此为先序遍历打印\n\tprintf(\"%c \", root->ch);\n\trecursion(root->left);\n\trecursion(root->right);\n\n\t//此为中序遍历打印\n\trecursion(root->left);\n\tprintf(\"%c \", root->ch);\n\trecursion(root->right);\n\n\t//此为后序遍历打印\n\trecursion(root->left);\n\trecursion(root->right);\n\tprintf(\"%c \", root->ch);\n}\n~~~\n\n## 求二叉树的叶子数\n\n叶子即没有左子树和右子树的结点。和遍历整颗二叉树的思路相同，只不过多了一个判断条件对叶子数进行记录。\n~~~\nvoid getTreeLeafNumber(struct BinaryTreeNode* root, int* leafNum) {\n\n\tif (NULL == root) {\n\t\treturn;\n\t}\n\n\tif (root->left == NULL && root->right == NULL) {\n\t\t//*和++运算等级一样，因此注意加括号\n\t\t(*leafNum)++;\n\t}\n\n\tgetTreeLeafNumber(root->left, leafNum);\n\tgetTreeLeafNumber(root->right, leafNum);\n\n}\n~~~\n\n## 二叉树高度\n\n高度简单理解为一颗树向下延申的最高层数，根节点记为一层，有子节点增加一层以此类推。\n\n思路为：要想知道这颗二叉树的高度，就要知道左子树和右子树的高度分别为多少，对其比较取最大值。每一个结点都是一棵树，理解这个就明白了。\n~~~\nint getBinaryHeight(struct BinaryTreeNode* root) {\n\n\tif (NULL == root) {\n\t\treturn 0;\n\t}\n\n\tint leftHeight = getBinaryHeight(root->left);\n\tint rightHeight = getBinaryHeight(root->right);\n\n\tint height = leftHeight > rightHeight ? leftHeight + 1 : rightHeight + 1;\n\n\treturn height;\n\n}\n~~~\n\n## 二叉树的拷贝\n\n注意，需要**对每一个拷贝的结点分配空间**，因此对应分配空间必定需要**释放空间**。\n\n如果不分配空间的话，拷贝的只是一块不再是原先存放拷贝内容的地址了，这是**内存的四区模型**知识点，切记。\n~~~\nstruct BinaryTreeNode* copyTree(struct BinaryTreeNode* root) {\n\n\tif (NULL == root) {\n\t\treturn NULL;\n\t}\n\n\tstruct BinaryTreeNode* left = copyTree(root->left);\n\tstruct BinaryTreeNode* right = copyTree(root->right);\n\n\tstruct BinaryTreeNode* node = malloc(sizeof(struct BinaryTreeNode));\n\n\tnode->left = left;\n\tnode->right = right;\n\tnode->ch = root->ch;\n\n\treturn node;\n\n}\n~~~\n\nPS:准备换电脑了💻","slug":"2019-Holiday-Note-09","published":1,"updated":"2019-07-21T12:36:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihk000nsmjbbe6g226y","content":"<h1 id=\"Holiday-Note-09\"><a href=\"#Holiday-Note-09\" class=\"headerlink\" title=\"Holiday Note_09\"></a>Holiday Note_09</h1><p><strong>二叉树</strong>，递归递归递归。纸上画了一遍递归遍历二叉树的函数调用全过程😵。值得注意的是，拷贝二叉树时，需要使用malloc给每一个结点分配内存，否则函数结束栈区内存销毁，拷贝的数据均会消失。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"二叉树的结构定义\"><a href=\"#二叉树的结构定义\" class=\"headerlink\" title=\"二叉树的结构定义\"></a>二叉树的结构定义</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;<span class=\"comment\">//简单定义的一个数据类型，不够规范。</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span>* <span class=\"title\">left</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span>* <span class=\"title\">right</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><p>以中序遍历为例，思路为：要想进行中序遍历，先要遍历根节点的左子树，再遍历右子树，最后是根。要想遍历根节点的左子树，要先遍历根结点的左子树的左子树，再遍历根结点的左子树的右子树，再是根节点的左子树。。。循环反复，结点为空返回。</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void recursion(struct BinaryTreeNode* root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//返回条件</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == root) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//此为先序遍历打印</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">printf</span>(\"%c \", root-&gt;</span>ch);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">recursion</span>(root-&gt;</span>left);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">recursion</span>(root-&gt;</span>right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//此为中序遍历打印</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">recursion</span>(root-&gt;</span>left);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">printf</span>(\"%c \", root-&gt;</span>ch);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">recursion</span>(root-&gt;</span>right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//此为后序遍历打印</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">recursion</span>(root-&gt;</span>left);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">recursion</span>(root-&gt;</span>right);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">printf</span>(\"%c \", root-&gt;</span>ch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树的叶子数\"><a href=\"#求二叉树的叶子数\" class=\"headerlink\" title=\"求二叉树的叶子数\"></a>求二叉树的叶子数</h2><p>叶子即没有左子树和右子树的结点。和遍历整颗二叉树的思路相同，只不过多了一个判断条件对叶子数进行记录。</p>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void getTreeLeafNumber(struct BinaryTreeNode* root, <span class=\"keyword\">int</span>* leafNum) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">NULL</span> == root) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root-&gt;left == <span class=\"keyword\">NULL</span> &amp;&amp; root-&gt;right == <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//*和++运算等级一样，因此注意加括号</span></span><br><span class=\"line\">\t\t(*leafNum)++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgetTreeLeafNumber(root-&gt;left, leafNum);</span><br><span class=\"line\">\tgetTreeLeafNumber(root-&gt;right, leafNum);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二叉树高度\"><a href=\"#二叉树高度\" class=\"headerlink\" title=\"二叉树高度\"></a>二叉树高度</h2><p>高度简单理解为一颗树向下延申的最高层数，根节点记为一层，有子节点增加一层以此类推。</p>\n<p>思路为：要想知道这颗二叉树的高度，就要知道左子树和右子树的高度分别为多少，对其比较取最大值。每一个结点都是一棵树，理解这个就明白了。</p>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> getBinaryHeight(struct BinaryTreeNode* root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">NULL</span> == root) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftHeight = getBinaryHeight(root-&gt;left);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> rightHeight = getBinaryHeight(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> height = leftHeight &gt; rightHeight ? leftHeight + <span class=\"number\">1</span> : rightHeight + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> height;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二叉树的拷贝\"><a href=\"#二叉树的拷贝\" class=\"headerlink\" title=\"二叉树的拷贝\"></a>二叉树的拷贝</h2><p>注意，需要<strong>对每一个拷贝的结点分配空间</strong>，因此对应分配空间必定需要<strong>释放空间</strong>。</p>\n<p>如果不分配空间的话，拷贝的只是一块不再是原先存放拷贝内容的地址了，这是<strong>内存的四区模型</strong>知识点，切记。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span></span>* copyTree(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span></span>* root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == root) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span></span>* left = copyTree(root-&gt;left);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span></span>* right = copyTree(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span></span>* node = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span></span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode-&gt;left = left;</span><br><span class=\"line\">\tnode-&gt;right = right;</span><br><span class=\"line\">\tnode-&gt;ch = root-&gt;ch;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> node;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS:准备换电脑了💻</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-09\"><a href=\"#Holiday-Note-09\" class=\"headerlink\" title=\"Holiday Note_09\"></a>Holiday Note_09</h1><p><strong>二叉树</strong>，递归递归递归。纸上画了一遍递归遍历二叉树的函数调用全过程😵。值得注意的是，拷贝二叉树时，需要使用malloc给每一个结点分配内存，否则函数结束栈区内存销毁，拷贝的数据均会消失。</p>","more":"<h2 id=\"二叉树的结构定义\"><a href=\"#二叉树的结构定义\" class=\"headerlink\" title=\"二叉树的结构定义\"></a>二叉树的结构定义</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;<span class=\"comment\">//简单定义的一个数据类型，不够规范。</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span>* <span class=\"title\">left</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span>* <span class=\"title\">right</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><p>以中序遍历为例，思路为：要想进行中序遍历，先要遍历根节点的左子树，再遍历右子树，最后是根。要想遍历根节点的左子树，要先遍历根结点的左子树的左子树，再遍历根结点的左子树的右子树，再是根节点的左子树。。。循环反复，结点为空返回。</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void recursion(struct BinaryTreeNode* root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//返回条件</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == root) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//此为先序遍历打印</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">printf</span>(\"%c \", root-&gt;</span>ch);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">recursion</span>(root-&gt;</span>left);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">recursion</span>(root-&gt;</span>right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//此为中序遍历打印</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">recursion</span>(root-&gt;</span>left);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">printf</span>(\"%c \", root-&gt;</span>ch);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">recursion</span>(root-&gt;</span>right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//此为后序遍历打印</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">recursion</span>(root-&gt;</span>left);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">recursion</span>(root-&gt;</span>right);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">printf</span>(\"%c \", root-&gt;</span>ch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求二叉树的叶子数\"><a href=\"#求二叉树的叶子数\" class=\"headerlink\" title=\"求二叉树的叶子数\"></a>求二叉树的叶子数</h2><p>叶子即没有左子树和右子树的结点。和遍历整颗二叉树的思路相同，只不过多了一个判断条件对叶子数进行记录。</p>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void getTreeLeafNumber(struct BinaryTreeNode* root, <span class=\"keyword\">int</span>* leafNum) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">NULL</span> == root) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root-&gt;left == <span class=\"keyword\">NULL</span> &amp;&amp; root-&gt;right == <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//*和++运算等级一样，因此注意加括号</span></span><br><span class=\"line\">\t\t(*leafNum)++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgetTreeLeafNumber(root-&gt;left, leafNum);</span><br><span class=\"line\">\tgetTreeLeafNumber(root-&gt;right, leafNum);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二叉树高度\"><a href=\"#二叉树高度\" class=\"headerlink\" title=\"二叉树高度\"></a>二叉树高度</h2><p>高度简单理解为一颗树向下延申的最高层数，根节点记为一层，有子节点增加一层以此类推。</p>\n<p>思路为：要想知道这颗二叉树的高度，就要知道左子树和右子树的高度分别为多少，对其比较取最大值。每一个结点都是一棵树，理解这个就明白了。</p>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> getBinaryHeight(struct BinaryTreeNode* root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">NULL</span> == root) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftHeight = getBinaryHeight(root-&gt;left);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> rightHeight = getBinaryHeight(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> height = leftHeight &gt; rightHeight ? leftHeight + <span class=\"number\">1</span> : rightHeight + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> height;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二叉树的拷贝\"><a href=\"#二叉树的拷贝\" class=\"headerlink\" title=\"二叉树的拷贝\"></a>二叉树的拷贝</h2><p>注意，需要<strong>对每一个拷贝的结点分配空间</strong>，因此对应分配空间必定需要<strong>释放空间</strong>。</p>\n<p>如果不分配空间的话，拷贝的只是一块不再是原先存放拷贝内容的地址了，这是<strong>内存的四区模型</strong>知识点，切记。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span></span>* copyTree(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span></span>* root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (NULL == root) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span></span>* left = copyTree(root-&gt;left);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span></span>* right = copyTree(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span></span>* node = malloc(<span class=\"keyword\">sizeof</span>(<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTreeNode</span></span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode-&gt;left = left;</span><br><span class=\"line\">\tnode-&gt;right = right;</span><br><span class=\"line\">\tnode-&gt;ch = root-&gt;ch;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> node;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS:准备换电脑了💻</p>"},{"title":"Holiday Note_10","date":"2019-07-22T12:22:51.000Z","_content":"\n# Holiday Note_10\n\n开始学C++了。第一天，学的特别杂，主要是C++对于C的一些增强，如**全局变量检测**，**函数检测**，**类型转换检查**，**struct**，**bool**，**三目运算符**，**const**。然后学了C++中的**namespace**，**using**和**引用**的使用方法。其中 *引用(reference)* 是其中的重点，它是C++对C的重要扩充。相较于C的地址，指针传递，引用更加清晰，语法更加简单不容易出错。\n\n<!-- more -->\n\n## C++对C的增强\n> C++之父-本贾尼·斯特劳斯特卢普(Bjarne Stroustrup)是这么说的：C++主要是为了我的朋友和我不必再使 用汇编语言、C语言或者其他现代高级语言来编程而设计的。它的主要功能是可以更方便得编写出好程序，**让每个程序员更加快乐**”。\n\n[![CPP573f4.md.png](https://miao.su/images/2019/07/22/CPP573f4.md.png)](https://miao.su/image/TINaJ)\n\n看得出来他很快乐👴\n\nC++是面向对象的， 面向对象三大特性：**继承**；**封装**；**多态**；\n\n### 全局变量检测增强\n此代码在C++下编译失败,在C下编译通过\n~~~\nint a = 10; //赋值，当做定义\nint a; //没有赋值，当做声明\n~~~\n\n### 函数检测增强\n\nC++中所有的变量和函数都必须有类型，因此，在C中写函数可以不写返回值类型，不写参数类型，不写参数，有返回值却不写return都可以编译成功，但是C++编译均会失败。\n\n1. 参数类型检测\n2. 返回值检测\n3. 传参个数检测\n\n### 类型转换检测增强\nmalloc返回void* ，C中可以不用强转用想使用的指针类型接收即可，C++必须强转成接收指针类型才能编译成功；\n\n### struct增强\n- c中定义结构体变量需要加上struct关键字，C++不需要。\n- c中的结构体只能定义成员变量，不能定义成员函数。C++即可以定义成员变量，也可以定义成员函数。\n\n以下为C++可以实现的结构体定义以及使用。\n~~~\nstruct Person {\n\tchar name[64];\n\tint age;\n\tvoid ageAdd() {\n\t\tage++;\n\t}\n};\n\nPerson p1;\np1.ageAdd();\n~~~\n\n### bool数据类型增强\nC++中有bool类型，C没有。true/false。sizeof结果为1。\n~~~\nbool flag = true;\n~~~\n\n\n### 三目运算符增强\n- C语言三目运算表达式**返回值为数据值**，为右值，不能赋值。\n- C++语言三目运算表达式**返回值为变量本身(引用)**，为左值，可以赋值。\n~~~\nint a = 10, b = 20;\n//下面这条语句在C中无法成功编译。C++执行完后b的值变成了100\n(a > b ? a : b) = 100;\n~~~\n\n### const增强\n1. **在C++中，一个const不必创建内存空间，而在C中，一个const总是需要一块内存空间。**\n\n- C语言中const是伪常量，局部const存储在堆栈区，只是不能通过变量直接修改const只读变量的值，但是可以跳过编译器的检查，通过指针间接修改const值。\n\n- C++中const会放入到**符号表**中，不会分配内存，而是**Key-Value**的形式，const修饰的变量为key值，变量值为value。当对其取地址时，才会分配内存，但是这个新分配出的内存只是拷贝的const修饰变量的value值，指针操作的只是这块空间，因此无法进行修改。\n\t\n\n2. C语言中const默认是外部链接，C++中const默认是内部链接\n\t\n3. const分配内存情况\n\t\n- 对变量取地址，会分配**临时内存**\n~~~\nvoid test() {\n\tconst int m_A = 10;//不分配内存，KEY-VALUE\n\tint* p = (int *)&(m_A);//分配的是临时内存\n\t*p = 100;\n\n\tcout << \"*p = \" << *p << endl;//100\n\tcout << \"m_A = \" << m_A << endl;//10\n}\n~~~\n\t\n- extern关键字下的const会分配内存\n\t\n- 用**普通变量初始化const变量**会分配内存\n~~~\nvoid test06() {\n\tint b = 10;\n\tconst int m_A = b;//会分配内存\n\tint* p = (int*) & (m_A);\n\n\t*p = 100;\n\n\tcout << \"*p = \" << *p << endl;//100\n\tcout << \"m_A = \" << m_A << endl;//100\n}\n~~~\n\n- **自定义数据类型**会分配内存\n~~~\nstruct Person {\n\tstring name = \"AAA\";\n\tint age = 10;\n};\n\nconst Person p1;\n//p1.name = \"BBB\";//虽然不能简单修改，但是通过指针取地址可以修改了\n\t\nPerson* p = (Person*) & (p1);\t\np->name = \"BBB\";\ncout << \"name = \" << p->name << endl;//name = BBB\n~~~\n\n4. 尽量用const代替define\n\n- const有类型，**可进行编译器类型安全检查**。#define无类型，不可进行类型检查.\n- const有**作用域**，而#define不重视作用域，默认定义处到文件结尾.如果定义在指定作用域下有效的常量，那么#define就不能用。\n\n\n---\n\n## C++中namespace和using的使用\nC++的Hello World写法\n~~~\n//标准输入流\n#include <iostream>\n//使用命名空间\nusing namespace std;\n\nint main01() {\n\n\t//cout：标准输出；<< 符号重载，字符拼接；endl标准结束换行\n\tcout << \"Hello World\" << endl;\n\n\t//返回正常退出\n\treturn EXIT_SUCCESS;\n\n\tsystem(\"pause\");//阻塞功能\n\n }\n~~~\n### namespace用途以及使用方法\nnamespace就像一个一个的房子，里边有这个房子特定的数据。使用**命名空间**是为了**更好地控制标识符的作用域**\n\n- 解决名称冲突问题\n\n- **必须在全局作用域下声明**\n\n- 命名空间下可以放入 函数、变量、结构体、类…\n~~~\nnamespace veryLongName{\t\n\tint a = 10;\n\tvoid func(){ cout << \"hello namespace\" << endl; }\n}\n~~~\n\n- 命名空间可以嵌套命名空间\n~~~\nnamespace A {\n\tint m_A = 10;\n\n\tnamespace B {\n\t\tint m_C = 30;\n\t}\n\n}\n~~~\n\n\n- 命名空间是开放的，可以随时加入新的成员\n~~~\nnamespace A {\n\tint m_B = 20;\n}\n~~~\n\n\n- 匿名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接。\n\n- 可以起别名\n~~~\nnamespace S = A;\n~~~\n\n### namespace用途以及使用方法\n\n1. using声明:\nusing声明可使得指定的标识符可用。\n2. using编译指令:\nusing编译指令使整个命名空间标识符可用.\n\n\n参照上方的命名空间A和B进行使用表示using的使用注意事项。\n~~~\nvoid test() {\n\n\tint m_A = 100;\n\n\t//声明，注意二义性问题\n\t//using A::m_A;//编译会失败\n\n\t//编译指令，打开房间，并不一定用。\n\tusing namespace A;\n\t//using namespace B;//连续打开两个房间，一会产生二义性。\n\n\tcout << m_A << endl; //此时输出结果为100，虽然此时打开了A的房间，但是并未使用。\n\n}\n~~~\n\n\n## 引用（reference）\n\n引用是C++对C的重要扩充。在C/C++中指针的作用基本都是一样的，但是C++增加了另外一种给函数传递地址的途径，这就是**按引用传递**(pass-by-reference)\n\n-\t变量名实质上是一段连续内存空间的别名，是一个标号(门牌号)\n-\t程序中通过变量来申请并命名内存空间\n-\t通过变量的名字可以使用存储空间\n\n**定义方式：Type& ref = val;**\n\n注意事项：\n-\t&在此不是求地址运算，而是起标识作用。\n-\t类型标识符是指目标变量的类型\n-\t**必须在声明引用变量时进行初始化**。\n-\t**引用初始化之后不能改变**。\n-\t不能有NULL引用。必须确保引用是和一块**合法的存储单元**关联。即不要返回局部变量的引用\n-\t可以建立对数组的引用。\n\n定义数组的两种方式\n~~~\ntypedef int(ARRAY)[10];\nvoid test09() {\n\tint arr[10];\n\n\tint(&reArr)[10] = arr;\n\n\tARRAY& r = arr;\n\n}\n~~~\n\n做函数参数，例如交换函数，C中调用时需要传入地址，参数需要指针类型，C++大大简化了这些操作\n~~~\nvoid swap(int& a, int& b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\nvoid test10() {\n\tint a = 10;\n\tint b = 20;\n\tswap(a, b);\n}\n~~~\n\n做函数返回值时\n~~~\nint& test01() {\n\tstatic int a = 10;\n\treturn a;\n}\n\nvoid test(){\n\ttest01() = 100;\n}\n~~~\n\n### 引用的本质\n**引用的本质在c++内部实现是一个指针常量**\n\n**自动转换为val的地址或值。**\n~~~\nType& ref = val; // Type* const ref = &val;\n~~~\n\n###  指针引用\n在C中如果想改变一个指针的指向而不是它所指向的内容，需要用到二级指针，使用指针引用会让函数清晰明了很多。\n~~~\nType* pointer = NULL;  \nType*& = pointer;\n~~~\n\n两者的具体参考以下的代码\n~~~\nstruct Teacher{\n\tint mAge;\n};\n\n//指针间接修改teacher的年龄\nvoid AllocateAndInitByPointer(Teacher** teacher){\n\t*teacher = (Teacher*)malloc(sizeof(Teacher));\n\t(*teacher)->mAge = 200;  \n}\n\n//引用修改teacher年龄\nvoid AllocateAndInitByReference(Teacher*& teacher){\n\tteacher->mAge = 300;\n}\n\nvoid test(){\n\t//创建Teacher\n\tTeacher* teacher = NULL;\n\t//指针间接赋值\n\tAllocateAndInitByPointer(&teacher);\n\tcout << \"AllocateAndInitByPointer:\" << teacher->mAge << endl;\n\t//引用赋值,将teacher本身传到ChangeAgeByReference函数中\n\tAllocateAndInitByReference(teacher);\n\tcout << \"AllocateAndInitByReference:\" << teacher->mAge << endl;\n\tfree(teacher);\n}\n~~~\n\n**常量引用**主要用在函数的形参，尤其是类的拷贝/复制构造函数。\n\n将函数的形参定义为常量引用的好处:\n- 引用不产生新的变量，减少形参与实参传递时的开销。\n- 由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用。\n- 如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常量引用。\n\nPS:起床后不是立马学习，而是选电脑选了半天。。。","source":"_posts/2019-Holiday-Note-10.md","raw":"---\ntitle: Holiday Note_10\ndate: 2019-07-22 20:22:51\ncategories: C++\ntags: [Note,C++]\n---\n\n# Holiday Note_10\n\n开始学C++了。第一天，学的特别杂，主要是C++对于C的一些增强，如**全局变量检测**，**函数检测**，**类型转换检查**，**struct**，**bool**，**三目运算符**，**const**。然后学了C++中的**namespace**，**using**和**引用**的使用方法。其中 *引用(reference)* 是其中的重点，它是C++对C的重要扩充。相较于C的地址，指针传递，引用更加清晰，语法更加简单不容易出错。\n\n<!-- more -->\n\n## C++对C的增强\n> C++之父-本贾尼·斯特劳斯特卢普(Bjarne Stroustrup)是这么说的：C++主要是为了我的朋友和我不必再使 用汇编语言、C语言或者其他现代高级语言来编程而设计的。它的主要功能是可以更方便得编写出好程序，**让每个程序员更加快乐**”。\n\n[![CPP573f4.md.png](https://miao.su/images/2019/07/22/CPP573f4.md.png)](https://miao.su/image/TINaJ)\n\n看得出来他很快乐👴\n\nC++是面向对象的， 面向对象三大特性：**继承**；**封装**；**多态**；\n\n### 全局变量检测增强\n此代码在C++下编译失败,在C下编译通过\n~~~\nint a = 10; //赋值，当做定义\nint a; //没有赋值，当做声明\n~~~\n\n### 函数检测增强\n\nC++中所有的变量和函数都必须有类型，因此，在C中写函数可以不写返回值类型，不写参数类型，不写参数，有返回值却不写return都可以编译成功，但是C++编译均会失败。\n\n1. 参数类型检测\n2. 返回值检测\n3. 传参个数检测\n\n### 类型转换检测增强\nmalloc返回void* ，C中可以不用强转用想使用的指针类型接收即可，C++必须强转成接收指针类型才能编译成功；\n\n### struct增强\n- c中定义结构体变量需要加上struct关键字，C++不需要。\n- c中的结构体只能定义成员变量，不能定义成员函数。C++即可以定义成员变量，也可以定义成员函数。\n\n以下为C++可以实现的结构体定义以及使用。\n~~~\nstruct Person {\n\tchar name[64];\n\tint age;\n\tvoid ageAdd() {\n\t\tage++;\n\t}\n};\n\nPerson p1;\np1.ageAdd();\n~~~\n\n### bool数据类型增强\nC++中有bool类型，C没有。true/false。sizeof结果为1。\n~~~\nbool flag = true;\n~~~\n\n\n### 三目运算符增强\n- C语言三目运算表达式**返回值为数据值**，为右值，不能赋值。\n- C++语言三目运算表达式**返回值为变量本身(引用)**，为左值，可以赋值。\n~~~\nint a = 10, b = 20;\n//下面这条语句在C中无法成功编译。C++执行完后b的值变成了100\n(a > b ? a : b) = 100;\n~~~\n\n### const增强\n1. **在C++中，一个const不必创建内存空间，而在C中，一个const总是需要一块内存空间。**\n\n- C语言中const是伪常量，局部const存储在堆栈区，只是不能通过变量直接修改const只读变量的值，但是可以跳过编译器的检查，通过指针间接修改const值。\n\n- C++中const会放入到**符号表**中，不会分配内存，而是**Key-Value**的形式，const修饰的变量为key值，变量值为value。当对其取地址时，才会分配内存，但是这个新分配出的内存只是拷贝的const修饰变量的value值，指针操作的只是这块空间，因此无法进行修改。\n\t\n\n2. C语言中const默认是外部链接，C++中const默认是内部链接\n\t\n3. const分配内存情况\n\t\n- 对变量取地址，会分配**临时内存**\n~~~\nvoid test() {\n\tconst int m_A = 10;//不分配内存，KEY-VALUE\n\tint* p = (int *)&(m_A);//分配的是临时内存\n\t*p = 100;\n\n\tcout << \"*p = \" << *p << endl;//100\n\tcout << \"m_A = \" << m_A << endl;//10\n}\n~~~\n\t\n- extern关键字下的const会分配内存\n\t\n- 用**普通变量初始化const变量**会分配内存\n~~~\nvoid test06() {\n\tint b = 10;\n\tconst int m_A = b;//会分配内存\n\tint* p = (int*) & (m_A);\n\n\t*p = 100;\n\n\tcout << \"*p = \" << *p << endl;//100\n\tcout << \"m_A = \" << m_A << endl;//100\n}\n~~~\n\n- **自定义数据类型**会分配内存\n~~~\nstruct Person {\n\tstring name = \"AAA\";\n\tint age = 10;\n};\n\nconst Person p1;\n//p1.name = \"BBB\";//虽然不能简单修改，但是通过指针取地址可以修改了\n\t\nPerson* p = (Person*) & (p1);\t\np->name = \"BBB\";\ncout << \"name = \" << p->name << endl;//name = BBB\n~~~\n\n4. 尽量用const代替define\n\n- const有类型，**可进行编译器类型安全检查**。#define无类型，不可进行类型检查.\n- const有**作用域**，而#define不重视作用域，默认定义处到文件结尾.如果定义在指定作用域下有效的常量，那么#define就不能用。\n\n\n---\n\n## C++中namespace和using的使用\nC++的Hello World写法\n~~~\n//标准输入流\n#include <iostream>\n//使用命名空间\nusing namespace std;\n\nint main01() {\n\n\t//cout：标准输出；<< 符号重载，字符拼接；endl标准结束换行\n\tcout << \"Hello World\" << endl;\n\n\t//返回正常退出\n\treturn EXIT_SUCCESS;\n\n\tsystem(\"pause\");//阻塞功能\n\n }\n~~~\n### namespace用途以及使用方法\nnamespace就像一个一个的房子，里边有这个房子特定的数据。使用**命名空间**是为了**更好地控制标识符的作用域**\n\n- 解决名称冲突问题\n\n- **必须在全局作用域下声明**\n\n- 命名空间下可以放入 函数、变量、结构体、类…\n~~~\nnamespace veryLongName{\t\n\tint a = 10;\n\tvoid func(){ cout << \"hello namespace\" << endl; }\n}\n~~~\n\n- 命名空间可以嵌套命名空间\n~~~\nnamespace A {\n\tint m_A = 10;\n\n\tnamespace B {\n\t\tint m_C = 30;\n\t}\n\n}\n~~~\n\n\n- 命名空间是开放的，可以随时加入新的成员\n~~~\nnamespace A {\n\tint m_B = 20;\n}\n~~~\n\n\n- 匿名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接。\n\n- 可以起别名\n~~~\nnamespace S = A;\n~~~\n\n### namespace用途以及使用方法\n\n1. using声明:\nusing声明可使得指定的标识符可用。\n2. using编译指令:\nusing编译指令使整个命名空间标识符可用.\n\n\n参照上方的命名空间A和B进行使用表示using的使用注意事项。\n~~~\nvoid test() {\n\n\tint m_A = 100;\n\n\t//声明，注意二义性问题\n\t//using A::m_A;//编译会失败\n\n\t//编译指令，打开房间，并不一定用。\n\tusing namespace A;\n\t//using namespace B;//连续打开两个房间，一会产生二义性。\n\n\tcout << m_A << endl; //此时输出结果为100，虽然此时打开了A的房间，但是并未使用。\n\n}\n~~~\n\n\n## 引用（reference）\n\n引用是C++对C的重要扩充。在C/C++中指针的作用基本都是一样的，但是C++增加了另外一种给函数传递地址的途径，这就是**按引用传递**(pass-by-reference)\n\n-\t变量名实质上是一段连续内存空间的别名，是一个标号(门牌号)\n-\t程序中通过变量来申请并命名内存空间\n-\t通过变量的名字可以使用存储空间\n\n**定义方式：Type& ref = val;**\n\n注意事项：\n-\t&在此不是求地址运算，而是起标识作用。\n-\t类型标识符是指目标变量的类型\n-\t**必须在声明引用变量时进行初始化**。\n-\t**引用初始化之后不能改变**。\n-\t不能有NULL引用。必须确保引用是和一块**合法的存储单元**关联。即不要返回局部变量的引用\n-\t可以建立对数组的引用。\n\n定义数组的两种方式\n~~~\ntypedef int(ARRAY)[10];\nvoid test09() {\n\tint arr[10];\n\n\tint(&reArr)[10] = arr;\n\n\tARRAY& r = arr;\n\n}\n~~~\n\n做函数参数，例如交换函数，C中调用时需要传入地址，参数需要指针类型，C++大大简化了这些操作\n~~~\nvoid swap(int& a, int& b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\nvoid test10() {\n\tint a = 10;\n\tint b = 20;\n\tswap(a, b);\n}\n~~~\n\n做函数返回值时\n~~~\nint& test01() {\n\tstatic int a = 10;\n\treturn a;\n}\n\nvoid test(){\n\ttest01() = 100;\n}\n~~~\n\n### 引用的本质\n**引用的本质在c++内部实现是一个指针常量**\n\n**自动转换为val的地址或值。**\n~~~\nType& ref = val; // Type* const ref = &val;\n~~~\n\n###  指针引用\n在C中如果想改变一个指针的指向而不是它所指向的内容，需要用到二级指针，使用指针引用会让函数清晰明了很多。\n~~~\nType* pointer = NULL;  \nType*& = pointer;\n~~~\n\n两者的具体参考以下的代码\n~~~\nstruct Teacher{\n\tint mAge;\n};\n\n//指针间接修改teacher的年龄\nvoid AllocateAndInitByPointer(Teacher** teacher){\n\t*teacher = (Teacher*)malloc(sizeof(Teacher));\n\t(*teacher)->mAge = 200;  \n}\n\n//引用修改teacher年龄\nvoid AllocateAndInitByReference(Teacher*& teacher){\n\tteacher->mAge = 300;\n}\n\nvoid test(){\n\t//创建Teacher\n\tTeacher* teacher = NULL;\n\t//指针间接赋值\n\tAllocateAndInitByPointer(&teacher);\n\tcout << \"AllocateAndInitByPointer:\" << teacher->mAge << endl;\n\t//引用赋值,将teacher本身传到ChangeAgeByReference函数中\n\tAllocateAndInitByReference(teacher);\n\tcout << \"AllocateAndInitByReference:\" << teacher->mAge << endl;\n\tfree(teacher);\n}\n~~~\n\n**常量引用**主要用在函数的形参，尤其是类的拷贝/复制构造函数。\n\n将函数的形参定义为常量引用的好处:\n- 引用不产生新的变量，减少形参与实参传递时的开销。\n- 由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用。\n- 如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常量引用。\n\nPS:起床后不是立马学习，而是选电脑选了半天。。。","slug":"2019-Holiday-Note-10","published":1,"updated":"2019-07-24T15:13:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihl000rsmjbxart2uxt","content":"<h1 id=\"Holiday-Note-10\"><a href=\"#Holiday-Note-10\" class=\"headerlink\" title=\"Holiday Note_10\"></a>Holiday Note_10</h1><p>开始学C++了。第一天，学的特别杂，主要是C++对于C的一些增强，如<strong>全局变量检测</strong>，<strong>函数检测</strong>，<strong>类型转换检查</strong>，<strong>struct</strong>，<strong>bool</strong>，<strong>三目运算符</strong>，<strong>const</strong>。然后学了C++中的<strong>namespace</strong>，<strong>using</strong>和<strong>引用</strong>的使用方法。其中 <em>引用(reference)</em> 是其中的重点，它是C++对C的重要扩充。相较于C的地址，指针传递，引用更加清晰，语法更加简单不容易出错。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"C-对C的增强\"><a href=\"#C-对C的增强\" class=\"headerlink\" title=\"C++对C的增强\"></a>C++对C的增强</h2><blockquote>\n<p>C++之父-本贾尼·斯特劳斯特卢普(Bjarne Stroustrup)是这么说的：C++主要是为了我的朋友和我不必再使 用汇编语言、C语言或者其他现代高级语言来编程而设计的。它的主要功能是可以更方便得编写出好程序，<strong>让每个程序员更加快乐</strong>”。</p>\n</blockquote>\n<p><a href=\"https://miao.su/image/TINaJ\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/22/CPP573f4.md.png\" alt=\"CPP573f4.md.png\"></a></p>\n<p>看得出来他很快乐👴</p>\n<p>C++是面向对象的， 面向对象三大特性：<strong>继承</strong>；<strong>封装</strong>；<strong>多态</strong>；</p>\n<h3 id=\"全局变量检测增强\"><a href=\"#全局变量检测增强\" class=\"headerlink\" title=\"全局变量检测增强\"></a>全局变量检测增强</h3><p>此代码在C++下编译失败,在C下编译通过</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>; <span class=\"comment\">//赋值，当做定义</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a; <span class=\"comment\">//没有赋值，当做声明</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数检测增强\"><a href=\"#函数检测增强\" class=\"headerlink\" title=\"函数检测增强\"></a>函数检测增强</h3><p>C++中所有的变量和函数都必须有类型，因此，在C中写函数可以不写返回值类型，不写参数类型，不写参数，有返回值却不写return都可以编译成功，但是C++编译均会失败。</p>\n<ol>\n<li>参数类型检测</li>\n<li>返回值检测</li>\n<li>传参个数检测</li>\n</ol>\n<h3 id=\"类型转换检测增强\"><a href=\"#类型转换检测增强\" class=\"headerlink\" title=\"类型转换检测增强\"></a>类型转换检测增强</h3><p>malloc返回void* ，C中可以不用强转用想使用的指针类型接收即可，C++必须强转成接收指针类型才能编译成功；</p>\n<h3 id=\"struct增强\"><a href=\"#struct增强\" class=\"headerlink\" title=\"struct增强\"></a>struct增强</h3><ul>\n<li>c中定义结构体变量需要加上struct关键字，C++不需要。</li>\n<li>c中的结构体只能定义成员变量，不能定义成员函数。C++即可以定义成员变量，也可以定义成员函数。</li>\n</ul>\n<p>以下为C++可以实现的结构体定义以及使用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ageAdd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tage++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person p1;</span><br><span class=\"line\">p1.ageAdd();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bool数据类型增强\"><a href=\"#bool数据类型增强\" class=\"headerlink\" title=\"bool数据类型增强\"></a>bool数据类型增强</h3><p>C++中有bool类型，C没有。true/false。sizeof结果为1。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三目运算符增强\"><a href=\"#三目运算符增强\" class=\"headerlink\" title=\"三目运算符增强\"></a>三目运算符增强</h3><ul>\n<li>C语言三目运算表达式<strong>返回值为数据值</strong>，为右值，不能赋值。</li>\n<li>C++语言三目运算表达式<strong>返回值为变量本身(引用)</strong>，为左值，可以赋值。<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">int</span> a = <span class=\"number\">10</span>, <span class=\"keyword\">b </span>= <span class=\"number\">20</span><span class=\"comment\">;</span></span><br><span class=\"line\">//下面这条语句在C中无法成功编译。C++执行完后<span class=\"keyword\">b的值变成了100</span></span><br><span class=\"line\"><span class=\"keyword\">(a </span>&gt; <span class=\"keyword\">b </span>? a : <span class=\"keyword\">b) </span>= <span class=\"number\">100</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"const增强\"><a href=\"#const增强\" class=\"headerlink\" title=\"const增强\"></a>const增强</h3><ol>\n<li><strong>在C++中，一个const不必创建内存空间，而在C中，一个const总是需要一块内存空间。</strong></li>\n</ol>\n<ul>\n<li><p>C语言中const是伪常量，局部const存储在堆栈区，只是不能通过变量直接修改const只读变量的值，但是可以跳过编译器的检查，通过指针间接修改const值。</p>\n</li>\n<li><p>C++中const会放入到<strong>符号表</strong>中，不会分配内存，而是<strong>Key-Value</strong>的形式，const修饰的变量为key值，变量值为value。当对其取地址时，才会分配内存，但是这个新分配出的内存只是拷贝的const修饰变量的value值，指针操作的只是这块空间，因此无法进行修改。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>C语言中const默认是外部链接，C++中const默认是内部链接</p>\n</li>\n<li><p>const分配内存情况</p>\n</li>\n</ol>\n<ul>\n<li>对变量取地址，会分配<strong>临时内存</strong><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m_A = <span class=\"number\">10</span>;<span class=\"comment\">//不分配内存，KEY-VALUE</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* p = (<span class=\"keyword\">int</span> *)&amp;(m_A);<span class=\"comment\">//分配的是临时内存</span></span><br><span class=\"line\">\t*p = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*p = \"</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//100</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"m_A = \"</span> &lt;&lt; m_A &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<ul>\n<li><p>extern关键字下的const会分配内存</p>\n</li>\n<li><p>用<strong>普通变量初始化const变量</strong>会分配内存</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test06</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m_A = b;<span class=\"comment\">//会分配内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* p = (<span class=\"keyword\">int</span>*) &amp; (m_A);</span><br><span class=\"line\"></span><br><span class=\"line\">\t*p = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*p = \"</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//100</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"m_A = \"</span> &lt;&lt; m_A &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//100</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>自定义数据类型</strong>会分配内存</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> name = <span class=\"string\">\"AAA\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Person p1;</span><br><span class=\"line\"><span class=\"comment\">//p1.name = \"BBB\";//虽然不能简单修改，但是通过指针取地址可以修改了</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">Person* p = (Person*) &amp; (p1);\t</span><br><span class=\"line\">p-&gt;name = <span class=\"string\">\"BBB\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"name = \"</span> &lt;&lt; p-&gt;name &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//name = BBB</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"4\">\n<li>尽量用const代替define</li>\n</ol>\n<ul>\n<li>const有类型，<strong>可进行编译器类型安全检查</strong>。#define无类型，不可进行类型检查.</li>\n<li>const有<strong>作用域</strong>，而#define不重视作用域，默认定义处到文件结尾.如果定义在指定作用域下有效的常量，那么#define就不能用。</li>\n</ul>\n<hr>\n<h2 id=\"C-中namespace和using的使用\"><a href=\"#C-中namespace和using的使用\" class=\"headerlink\" title=\"C++中namespace和using的使用\"></a>C++中namespace和using的使用</h2><p>C++的Hello World写法</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//标准输入流</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//使用命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//cout：标准输出；&lt;&lt; 符号重载，字符拼接；endl标准结束换行</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello World\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//返回正常退出</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);<span class=\"comment\">//阻塞功能</span></span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"namespace用途以及使用方法\"><a href=\"#namespace用途以及使用方法\" class=\"headerlink\" title=\"namespace用途以及使用方法\"></a>namespace用途以及使用方法</h3><p>namespace就像一个一个的房子，里边有这个房子特定的数据。使用<strong>命名空间</strong>是为了<strong>更好地控制标识符的作用域</strong></p>\n<ul>\n<li><p>解决名称冲突问题</p>\n</li>\n<li><p><strong>必须在全局作用域下声明</strong></p>\n</li>\n<li><p>命名空间下可以放入 函数、变量、结构体、类…</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> veryLongName&#123;\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"hello namespace\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命名空间可以嵌套命名空间</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">A</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_A = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">namespace</span> <span class=\"title\">B</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> m_C = <span class=\"number\">30</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命名空间是开放的，可以随时加入新的成员</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">A</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_B = <span class=\"number\">20</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>匿名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接。</p>\n</li>\n<li><p>可以起别名</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">S</span> = A;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"namespace用途以及使用方法-1\"><a href=\"#namespace用途以及使用方法-1\" class=\"headerlink\" title=\"namespace用途以及使用方法\"></a>namespace用途以及使用方法</h3><ol>\n<li>using声明:<br>using声明可使得指定的标识符可用。</li>\n<li>using编译指令:<br>using编译指令使整个命名空间标识符可用.</li>\n</ol>\n<p>参照上方的命名空间A和B进行使用表示using的使用注意事项。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_A = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//声明，注意二义性问题</span></span><br><span class=\"line\">\t<span class=\"comment\">//using A::m_A;//编译会失败</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//编译指令，打开房间，并不一定用。</span></span><br><span class=\"line\">\t<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> A;</span><br><span class=\"line\">\t<span class=\"comment\">//using namespace B;//连续打开两个房间，一会产生二义性。</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; m_A &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//此时输出结果为100，虽然此时打开了A的房间，但是并未使用。</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"引用（reference）\"><a href=\"#引用（reference）\" class=\"headerlink\" title=\"引用（reference）\"></a>引用（reference）</h2><p>引用是C++对C的重要扩充。在C/C++中指针的作用基本都是一样的，但是C++增加了另外一种给函数传递地址的途径，这就是<strong>按引用传递</strong>(pass-by-reference)</p>\n<ul>\n<li>变量名实质上是一段连续内存空间的别名，是一个标号(门牌号)</li>\n<li>程序中通过变量来申请并命名内存空间</li>\n<li>通过变量的名字可以使用存储空间</li>\n</ul>\n<p><strong>定义方式：Type&amp; ref = val;</strong></p>\n<p>注意事项：</p>\n<ul>\n<li>&amp;在此不是求地址运算，而是起标识作用。</li>\n<li>类型标识符是指目标变量的类型</li>\n<li><strong>必须在声明引用变量时进行初始化</strong>。</li>\n<li><strong>引用初始化之后不能改变</strong>。</li>\n<li>不能有NULL引用。必须确保引用是和一块<strong>合法的存储单元</strong>关联。即不要返回局部变量的引用</li>\n<li>可以建立对数组的引用。</li>\n</ul>\n<p>定义数组的两种方式</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span>(ARRAY)[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">void</span> test09() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>(&amp;reArr)[<span class=\"number\">10</span>] = arr;</span><br><span class=\"line\"></span><br><span class=\"line\">\tARRAY&amp; r = arr;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>做函数参数，例如交换函数，C中调用时需要传入地址，参数需要指针类型，C++大大简化了这些操作</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void <span class=\"keyword\">swap(int&amp; </span>a, int&amp; <span class=\"keyword\">b) </span>&#123;</span><br><span class=\"line\">\tint temp = a<span class=\"comment\">;</span></span><br><span class=\"line\">\ta = <span class=\"keyword\">b;</span></span><br><span class=\"line\"><span class=\"keyword\">\t</span><span class=\"keyword\">b </span>= temp<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void test10() &#123;</span><br><span class=\"line\">\tint a = <span class=\"number\">10</span><span class=\"comment\">;</span></span><br><span class=\"line\">\tint <span class=\"keyword\">b </span>= <span class=\"number\">20</span><span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"keyword\">swap(a, </span><span class=\"keyword\">b);</span></span><br><span class=\"line\"><span class=\"keyword\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>做函数返回值时</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>&amp; <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\ttest01() = <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"引用的本质\"><a href=\"#引用的本质\" class=\"headerlink\" title=\"引用的本质\"></a>引用的本质</h3><p><strong>引用的本质在c++内部实现是一个指针常量</strong></p>\n<p><strong>自动转换为val的地址或值。</strong></p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Type</span>&amp; <span class=\"keyword\">ref</span> = val; // <span class=\"keyword\">Type</span>* const <span class=\"keyword\">ref</span> = &amp;val;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指针引用\"><a href=\"#指针引用\" class=\"headerlink\" title=\"指针引用\"></a>指针引用</h3><p>在C中如果想改变一个指针的指向而不是它所指向的内容，需要用到二级指针，使用指针引用会让函数清晰明了很多。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Type</span>* <span class=\"keyword\">pointer</span> = NULL;  </span><br><span class=\"line\"><span class=\"keyword\">Type</span>*&amp; = <span class=\"keyword\">pointer</span>;</span><br></pre></td></tr></table></figure>\n\n<p>两者的具体参考以下的代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mAge;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指针间接修改teacher的年龄</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AllocateAndInitByPointer</span><span class=\"params\">(Teacher** teacher)</span></span>&#123;</span><br><span class=\"line\">\t*teacher = (Teacher*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Teacher));</span><br><span class=\"line\">\t(*teacher)-&gt;mAge = <span class=\"number\">200</span>;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//引用修改teacher年龄</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AllocateAndInitByReference</span><span class=\"params\">(Teacher*&amp; teacher)</span></span>&#123;</span><br><span class=\"line\">\tteacher-&gt;mAge = <span class=\"number\">300</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//创建Teacher</span></span><br><span class=\"line\">\tTeacher* teacher = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//指针间接赋值</span></span><br><span class=\"line\">\tAllocateAndInitByPointer(&amp;teacher);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"AllocateAndInitByPointer:\"</span> &lt;&lt; teacher-&gt;mAge &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//引用赋值,将teacher本身传到ChangeAgeByReference函数中</span></span><br><span class=\"line\">\tAllocateAndInitByReference(teacher);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"AllocateAndInitByReference:\"</span> &lt;&lt; teacher-&gt;mAge &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(teacher);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>常量引用</strong>主要用在函数的形参，尤其是类的拷贝/复制构造函数。</p>\n<p>将函数的形参定义为常量引用的好处:</p>\n<ul>\n<li>引用不产生新的变量，减少形参与实参传递时的开销。</li>\n<li>由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用。</li>\n<li>如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常量引用。</li>\n</ul>\n<p>PS:起床后不是立马学习，而是选电脑选了半天。。。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-10\"><a href=\"#Holiday-Note-10\" class=\"headerlink\" title=\"Holiday Note_10\"></a>Holiday Note_10</h1><p>开始学C++了。第一天，学的特别杂，主要是C++对于C的一些增强，如<strong>全局变量检测</strong>，<strong>函数检测</strong>，<strong>类型转换检查</strong>，<strong>struct</strong>，<strong>bool</strong>，<strong>三目运算符</strong>，<strong>const</strong>。然后学了C++中的<strong>namespace</strong>，<strong>using</strong>和<strong>引用</strong>的使用方法。其中 <em>引用(reference)</em> 是其中的重点，它是C++对C的重要扩充。相较于C的地址，指针传递，引用更加清晰，语法更加简单不容易出错。</p>","more":"<h2 id=\"C-对C的增强\"><a href=\"#C-对C的增强\" class=\"headerlink\" title=\"C++对C的增强\"></a>C++对C的增强</h2><blockquote>\n<p>C++之父-本贾尼·斯特劳斯特卢普(Bjarne Stroustrup)是这么说的：C++主要是为了我的朋友和我不必再使 用汇编语言、C语言或者其他现代高级语言来编程而设计的。它的主要功能是可以更方便得编写出好程序，<strong>让每个程序员更加快乐</strong>”。</p>\n</blockquote>\n<p><a href=\"https://miao.su/image/TINaJ\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/22/CPP573f4.md.png\" alt=\"CPP573f4.md.png\"></a></p>\n<p>看得出来他很快乐👴</p>\n<p>C++是面向对象的， 面向对象三大特性：<strong>继承</strong>；<strong>封装</strong>；<strong>多态</strong>；</p>\n<h3 id=\"全局变量检测增强\"><a href=\"#全局变量检测增强\" class=\"headerlink\" title=\"全局变量检测增强\"></a>全局变量检测增强</h3><p>此代码在C++下编译失败,在C下编译通过</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>; <span class=\"comment\">//赋值，当做定义</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a; <span class=\"comment\">//没有赋值，当做声明</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数检测增强\"><a href=\"#函数检测增强\" class=\"headerlink\" title=\"函数检测增强\"></a>函数检测增强</h3><p>C++中所有的变量和函数都必须有类型，因此，在C中写函数可以不写返回值类型，不写参数类型，不写参数，有返回值却不写return都可以编译成功，但是C++编译均会失败。</p>\n<ol>\n<li>参数类型检测</li>\n<li>返回值检测</li>\n<li>传参个数检测</li>\n</ol>\n<h3 id=\"类型转换检测增强\"><a href=\"#类型转换检测增强\" class=\"headerlink\" title=\"类型转换检测增强\"></a>类型转换检测增强</h3><p>malloc返回void* ，C中可以不用强转用想使用的指针类型接收即可，C++必须强转成接收指针类型才能编译成功；</p>\n<h3 id=\"struct增强\"><a href=\"#struct增强\" class=\"headerlink\" title=\"struct增强\"></a>struct增强</h3><ul>\n<li>c中定义结构体变量需要加上struct关键字，C++不需要。</li>\n<li>c中的结构体只能定义成员变量，不能定义成员函数。C++即可以定义成员变量，也可以定义成员函数。</li>\n</ul>\n<p>以下为C++可以实现的结构体定义以及使用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">64</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ageAdd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tage++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person p1;</span><br><span class=\"line\">p1.ageAdd();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bool数据类型增强\"><a href=\"#bool数据类型增强\" class=\"headerlink\" title=\"bool数据类型增强\"></a>bool数据类型增强</h3><p>C++中有bool类型，C没有。true/false。sizeof结果为1。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三目运算符增强\"><a href=\"#三目运算符增强\" class=\"headerlink\" title=\"三目运算符增强\"></a>三目运算符增强</h3><ul>\n<li>C语言三目运算表达式<strong>返回值为数据值</strong>，为右值，不能赋值。</li>\n<li>C++语言三目运算表达式<strong>返回值为变量本身(引用)</strong>，为左值，可以赋值。<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">int</span> a = <span class=\"number\">10</span>, <span class=\"keyword\">b </span>= <span class=\"number\">20</span><span class=\"comment\">;</span></span><br><span class=\"line\">//下面这条语句在C中无法成功编译。C++执行完后<span class=\"keyword\">b的值变成了100</span></span><br><span class=\"line\"><span class=\"keyword\">(a </span>&gt; <span class=\"keyword\">b </span>? a : <span class=\"keyword\">b) </span>= <span class=\"number\">100</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"const增强\"><a href=\"#const增强\" class=\"headerlink\" title=\"const增强\"></a>const增强</h3><ol>\n<li><strong>在C++中，一个const不必创建内存空间，而在C中，一个const总是需要一块内存空间。</strong></li>\n</ol>\n<ul>\n<li><p>C语言中const是伪常量，局部const存储在堆栈区，只是不能通过变量直接修改const只读变量的值，但是可以跳过编译器的检查，通过指针间接修改const值。</p>\n</li>\n<li><p>C++中const会放入到<strong>符号表</strong>中，不会分配内存，而是<strong>Key-Value</strong>的形式，const修饰的变量为key值，变量值为value。当对其取地址时，才会分配内存，但是这个新分配出的内存只是拷贝的const修饰变量的value值，指针操作的只是这块空间，因此无法进行修改。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>C语言中const默认是外部链接，C++中const默认是内部链接</p>\n</li>\n<li><p>const分配内存情况</p>\n</li>\n</ol>\n<ul>\n<li>对变量取地址，会分配<strong>临时内存</strong><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m_A = <span class=\"number\">10</span>;<span class=\"comment\">//不分配内存，KEY-VALUE</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* p = (<span class=\"keyword\">int</span> *)&amp;(m_A);<span class=\"comment\">//分配的是临时内存</span></span><br><span class=\"line\">\t*p = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*p = \"</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//100</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"m_A = \"</span> &lt;&lt; m_A &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<ul>\n<li><p>extern关键字下的const会分配内存</p>\n</li>\n<li><p>用<strong>普通变量初始化const变量</strong>会分配内存</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test06</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m_A = b;<span class=\"comment\">//会分配内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* p = (<span class=\"keyword\">int</span>*) &amp; (m_A);</span><br><span class=\"line\"></span><br><span class=\"line\">\t*p = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*p = \"</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//100</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"m_A = \"</span> &lt;&lt; m_A &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//100</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>自定义数据类型</strong>会分配内存</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> name = <span class=\"string\">\"AAA\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Person p1;</span><br><span class=\"line\"><span class=\"comment\">//p1.name = \"BBB\";//虽然不能简单修改，但是通过指针取地址可以修改了</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">Person* p = (Person*) &amp; (p1);\t</span><br><span class=\"line\">p-&gt;name = <span class=\"string\">\"BBB\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"name = \"</span> &lt;&lt; p-&gt;name &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//name = BBB</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"4\">\n<li>尽量用const代替define</li>\n</ol>\n<ul>\n<li>const有类型，<strong>可进行编译器类型安全检查</strong>。#define无类型，不可进行类型检查.</li>\n<li>const有<strong>作用域</strong>，而#define不重视作用域，默认定义处到文件结尾.如果定义在指定作用域下有效的常量，那么#define就不能用。</li>\n</ul>\n<hr>\n<h2 id=\"C-中namespace和using的使用\"><a href=\"#C-中namespace和using的使用\" class=\"headerlink\" title=\"C++中namespace和using的使用\"></a>C++中namespace和using的使用</h2><p>C++的Hello World写法</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//标准输入流</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//使用命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//cout：标准输出；&lt;&lt; 符号重载，字符拼接；endl标准结束换行</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello World\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//返回正常退出</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);<span class=\"comment\">//阻塞功能</span></span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"namespace用途以及使用方法\"><a href=\"#namespace用途以及使用方法\" class=\"headerlink\" title=\"namespace用途以及使用方法\"></a>namespace用途以及使用方法</h3><p>namespace就像一个一个的房子，里边有这个房子特定的数据。使用<strong>命名空间</strong>是为了<strong>更好地控制标识符的作用域</strong></p>\n<ul>\n<li><p>解决名称冲突问题</p>\n</li>\n<li><p><strong>必须在全局作用域下声明</strong></p>\n</li>\n<li><p>命名空间下可以放入 函数、变量、结构体、类…</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> veryLongName&#123;\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"hello namespace\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命名空间可以嵌套命名空间</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">A</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_A = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">namespace</span> <span class=\"title\">B</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> m_C = <span class=\"number\">30</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命名空间是开放的，可以随时加入新的成员</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">A</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_B = <span class=\"number\">20</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>匿名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接。</p>\n</li>\n<li><p>可以起别名</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">S</span> = A;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"namespace用途以及使用方法-1\"><a href=\"#namespace用途以及使用方法-1\" class=\"headerlink\" title=\"namespace用途以及使用方法\"></a>namespace用途以及使用方法</h3><ol>\n<li>using声明:<br>using声明可使得指定的标识符可用。</li>\n<li>using编译指令:<br>using编译指令使整个命名空间标识符可用.</li>\n</ol>\n<p>参照上方的命名空间A和B进行使用表示using的使用注意事项。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_A = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//声明，注意二义性问题</span></span><br><span class=\"line\">\t<span class=\"comment\">//using A::m_A;//编译会失败</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//编译指令，打开房间，并不一定用。</span></span><br><span class=\"line\">\t<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> A;</span><br><span class=\"line\">\t<span class=\"comment\">//using namespace B;//连续打开两个房间，一会产生二义性。</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; m_A &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//此时输出结果为100，虽然此时打开了A的房间，但是并未使用。</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"引用（reference）\"><a href=\"#引用（reference）\" class=\"headerlink\" title=\"引用（reference）\"></a>引用（reference）</h2><p>引用是C++对C的重要扩充。在C/C++中指针的作用基本都是一样的，但是C++增加了另外一种给函数传递地址的途径，这就是<strong>按引用传递</strong>(pass-by-reference)</p>\n<ul>\n<li>变量名实质上是一段连续内存空间的别名，是一个标号(门牌号)</li>\n<li>程序中通过变量来申请并命名内存空间</li>\n<li>通过变量的名字可以使用存储空间</li>\n</ul>\n<p><strong>定义方式：Type&amp; ref = val;</strong></p>\n<p>注意事项：</p>\n<ul>\n<li>&amp;在此不是求地址运算，而是起标识作用。</li>\n<li>类型标识符是指目标变量的类型</li>\n<li><strong>必须在声明引用变量时进行初始化</strong>。</li>\n<li><strong>引用初始化之后不能改变</strong>。</li>\n<li>不能有NULL引用。必须确保引用是和一块<strong>合法的存储单元</strong>关联。即不要返回局部变量的引用</li>\n<li>可以建立对数组的引用。</li>\n</ul>\n<p>定义数组的两种方式</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span>(ARRAY)[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">void</span> test09() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>(&amp;reArr)[<span class=\"number\">10</span>] = arr;</span><br><span class=\"line\"></span><br><span class=\"line\">\tARRAY&amp; r = arr;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>做函数参数，例如交换函数，C中调用时需要传入地址，参数需要指针类型，C++大大简化了这些操作</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void <span class=\"keyword\">swap(int&amp; </span>a, int&amp; <span class=\"keyword\">b) </span>&#123;</span><br><span class=\"line\">\tint temp = a<span class=\"comment\">;</span></span><br><span class=\"line\">\ta = <span class=\"keyword\">b;</span></span><br><span class=\"line\"><span class=\"keyword\">\t</span><span class=\"keyword\">b </span>= temp<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void test10() &#123;</span><br><span class=\"line\">\tint a = <span class=\"number\">10</span><span class=\"comment\">;</span></span><br><span class=\"line\">\tint <span class=\"keyword\">b </span>= <span class=\"number\">20</span><span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"keyword\">swap(a, </span><span class=\"keyword\">b);</span></span><br><span class=\"line\"><span class=\"keyword\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>做函数返回值时</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>&amp; <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\ttest01() = <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"引用的本质\"><a href=\"#引用的本质\" class=\"headerlink\" title=\"引用的本质\"></a>引用的本质</h3><p><strong>引用的本质在c++内部实现是一个指针常量</strong></p>\n<p><strong>自动转换为val的地址或值。</strong></p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Type</span>&amp; <span class=\"keyword\">ref</span> = val; // <span class=\"keyword\">Type</span>* const <span class=\"keyword\">ref</span> = &amp;val;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指针引用\"><a href=\"#指针引用\" class=\"headerlink\" title=\"指针引用\"></a>指针引用</h3><p>在C中如果想改变一个指针的指向而不是它所指向的内容，需要用到二级指针，使用指针引用会让函数清晰明了很多。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Type</span>* <span class=\"keyword\">pointer</span> = NULL;  </span><br><span class=\"line\"><span class=\"keyword\">Type</span>*&amp; = <span class=\"keyword\">pointer</span>;</span><br></pre></td></tr></table></figure>\n\n<p>两者的具体参考以下的代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mAge;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指针间接修改teacher的年龄</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AllocateAndInitByPointer</span><span class=\"params\">(Teacher** teacher)</span></span>&#123;</span><br><span class=\"line\">\t*teacher = (Teacher*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Teacher));</span><br><span class=\"line\">\t(*teacher)-&gt;mAge = <span class=\"number\">200</span>;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//引用修改teacher年龄</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AllocateAndInitByReference</span><span class=\"params\">(Teacher*&amp; teacher)</span></span>&#123;</span><br><span class=\"line\">\tteacher-&gt;mAge = <span class=\"number\">300</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//创建Teacher</span></span><br><span class=\"line\">\tTeacher* teacher = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//指针间接赋值</span></span><br><span class=\"line\">\tAllocateAndInitByPointer(&amp;teacher);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"AllocateAndInitByPointer:\"</span> &lt;&lt; teacher-&gt;mAge &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//引用赋值,将teacher本身传到ChangeAgeByReference函数中</span></span><br><span class=\"line\">\tAllocateAndInitByReference(teacher);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"AllocateAndInitByReference:\"</span> &lt;&lt; teacher-&gt;mAge &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(teacher);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>常量引用</strong>主要用在函数的形参，尤其是类的拷贝/复制构造函数。</p>\n<p>将函数的形参定义为常量引用的好处:</p>\n<ul>\n<li>引用不产生新的变量，减少形参与实参传递时的开销。</li>\n<li>由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用。</li>\n<li>如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常量引用。</li>\n</ul>\n<p>PS:起床后不是立马学习，而是选电脑选了半天。。。</p>"},{"title":"Holiday Note_11","date":"2019-07-23T04:16:02.000Z","_content":"\n# Holiday Note_11\n\n学了C++的**内联函数**，就是对C中宏的替代升级。还有**内联函数**，不怎么重要的函数的默认参数和占位参数，今天比较重要的是C++中的**重载**和**类和对象**的概念和使用，暂时觉得和跟上学期学的Java很像，写一堆其实都是get&set方法。。。\n\n<!-- more -->\n\n---\n\n## 内联函数(inline function)\n\n~~~\ninline int func(int a){return ++;}\n~~~\n\nC++引入内联函数是用于替换C中的宏。\n\n**内联函数为了继承宏函数的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为成员函数。内联函数本身也是一个真正的函数。**\n\n- 宏函数会有隐藏一些难以发现的错误。例如括号问题；((a++) < (b)) ? (a++) : (b)。\n- 预处理器不允许访问类的成员，也就是说预处理器宏不能用作类类的成员函数\n\n### 需要注意的是：\n\n1. **函数体和声明必须结合**在一起，否则编译器将它作为普通函数来对待。\n2. 内联函数是以**空间换时间**\n3. 任何**在类内部定义**的函数**自动**成为内联函数\n\n### 内联函数的一些限制\n-\t不能存在**任何形式的循环语句**\n-\t不能存在**过多的条件判断**语句\n-\t函数体不能过于庞大\n-\t不能**对函数进行取址**操作（类似宏，编译后找不到这个函数的入口）\n\n> 总的来说内联仅仅只是**给编译器一个建议**，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。\n\n---\n\n## 函数的默认参数和占位参数(很少用到的东西)\n\n### 默认参数\nC++在声明函数原型的时可为一个或者多个参数指定默认(缺省)的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。\n~~~\n\nvoid TestFunc01(int a = 10, int b = 20){\n\tcout << \"a + b  = \" << a + b << endl;\n}\n\n//注意点:\n//1. 形参b设置默认参数值，那么后面位置的形参c也需要设置默认参数\nvoid TestFunc02(int a,int b = 10,int c = 10){}\n\n//2. 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不能再设置默认参数\nvoid TestFunc03(int a = 0,int b = 0);\nvoid TestFunc03(int a, int b){}\n\nint main(){\n\t//1.如果没有传参数，那么使用默认参数\n\tTestFunc01();\n\t//2. 如果传一个参数，那么第二个参数使用默认参数\n\tTestFunc01(100);\n\t//3. 如果传入两个参数，那么两个参数都使用我们传入的参数\n\tTestFunc01(100, 200);\n\n\treturn EXIT_SUCCESS;\n}\n\n~~~\n\n### 函数的占位参数\nC++在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声明。一般情况下，在函数体内部无法使用占位参数。\n~~~\n\nvoid TestFunc01(int a,int b,int){\n\t//函数内部无法使用占位参数\n\tcout << \"a + b = \" << a + b << endl;\n}\n\n//占位参数也可以设置默认值\nvoid TestFunc02(int a, int b, int = 20){\n\t//函数内部依旧无法使用占位参数\n\tcout << \"a + b = \" << a + b << endl;\n}\n\nint main(){\n\n\t//错误调用，占位参数也是参数，必须传参数\n\t//TestFunc01(10,20); \n\t//正确调用\n\tTestFunc01(10,20,30);\n\t//正确调用\n\tTestFunc02(10,20);\n\t//正确调用\n\tTestFunc02(10, 20, 30);\n\n\treturn EXIT_SUCCESS;\n}\n\n~~~\n\n## 函数重载(overload)\n\n跟之前学习Java时差不多，就是通过函数参数设置的不同从而实现多个同名函数。\n\n### 实现函数重载的条件\n-\t同一个作用域\n-\t参数个数不同\n-\t参数类型不同\n-\t参数顺序不同\n\n要注意，**返回值不作为函数重载的条件**！\n~~~\n//1. 函数重载条件\nnamespace A{\n\tvoid MyFunc(){ cout << \"无参数!\" << endl; }\n\tvoid MyFunc(int a){ cout << \"a: \" << a << endl; }\n\tvoid MyFunc(string b){ cout << \"b: \" << b << endl; }\n\tvoid MyFunc(int a, string b){ cout << \"a: \" << a << \" b:\" << b << endl;}\n    void MyFunc(string b, int a){cout << \"a: \" << a << \" b:\" << b << endl;}\n}\n//2.返回值不作为函数重载依据\nnamespace B{\n\tvoid MyFunc(string b, int a){}\n\t//int MyFunc(string b, int a){} //无法重载仅按返回值区分的函数\n}\n~~~\n\n编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，**编译器用不同的参数类型来修饰不同的函数名**，比如void func(); 编译器可能会将函数名修饰成_func，当编译器碰到void func(int x),编译器可能将函数名修饰为_func_int,当编译器碰到void func(int x,char c),编译器可能会将函数名修饰为_func_int_char ，编译器如何修饰重载的函数名称并没有一个统一的标准，不同的编译器可能会产生不同的内部名。\n\n因此，对于引用C的文件，C++必须使用extern命令，否则，C的文件无法引用。(C++编译器支持重载的特性对函数名进行修饰，导致找不到C定义的文件)\n\n在C文件中使用这种格式可以让其中所有函数在C++中无需任何改动使用。\n~~~\n#ifdef __cplusplus\nextern \"C\"{\n#endif\n\n\tvoid func1();\n\n#ifdef __cplusplus\n}\n#endif\n~~~\n\n或者在C++中对每一个C文件中的函数前加上extern \"C\"。\n~~~\nextern \"C\" void func1();\n~~~\n\n---\n\n## 类和对象\n\n在C中，行为和属性是分开的。\n\n在C++中，把变量（属性）和函数（操作）合成一个整体，封装在一个类中；对变量和函数进行访问控制（**public**,**protected**,**private**）\n\n- 类中默认private，protected只能内部使用和子类使用，private只能内部使用。\n\n- C++中，class默认访问权限为private,struct默认访问权限为public。\n\n和Java那一套很类似，**将成员变量均设置为private**，通过get，set等成员函数进行查看和修改。看似写了很多行代码，其实全都是很简单的。。。\n\n以下为一个点类的头文件部分定义，头文件记得加#pragma once。\n~~~\nclass Point {\nprivate:\n\tint m_X;\n\tint m_Y;\n};\n~~~\n这是实现文件，注意的是，实现时需要加**Point::**进行函数定义。\n~~~\nint Point::getX() {\n\treturn m_X;\n}\n~~~\n\n类可以嵌套，如下面这个圆类，圆心定义即为点类。\n~~~\nclass Circle {\nprivate:\n\tPoint m_Center;\n\tint m_R;\n};\n~~~\n\nPS:今天点到了一家不错的外卖，难得啊。\n","source":"_posts/2019-Holiday-Note-11.md","raw":"---\ntitle: Holiday Note_11\ndate: 2019-07-23 12:16:02\ncategories: C++\ntags: [Note,C++]\n---\n\n# Holiday Note_11\n\n学了C++的**内联函数**，就是对C中宏的替代升级。还有**内联函数**，不怎么重要的函数的默认参数和占位参数，今天比较重要的是C++中的**重载**和**类和对象**的概念和使用，暂时觉得和跟上学期学的Java很像，写一堆其实都是get&set方法。。。\n\n<!-- more -->\n\n---\n\n## 内联函数(inline function)\n\n~~~\ninline int func(int a){return ++;}\n~~~\n\nC++引入内联函数是用于替换C中的宏。\n\n**内联函数为了继承宏函数的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为成员函数。内联函数本身也是一个真正的函数。**\n\n- 宏函数会有隐藏一些难以发现的错误。例如括号问题；((a++) < (b)) ? (a++) : (b)。\n- 预处理器不允许访问类的成员，也就是说预处理器宏不能用作类类的成员函数\n\n### 需要注意的是：\n\n1. **函数体和声明必须结合**在一起，否则编译器将它作为普通函数来对待。\n2. 内联函数是以**空间换时间**\n3. 任何**在类内部定义**的函数**自动**成为内联函数\n\n### 内联函数的一些限制\n-\t不能存在**任何形式的循环语句**\n-\t不能存在**过多的条件判断**语句\n-\t函数体不能过于庞大\n-\t不能**对函数进行取址**操作（类似宏，编译后找不到这个函数的入口）\n\n> 总的来说内联仅仅只是**给编译器一个建议**，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。\n\n---\n\n## 函数的默认参数和占位参数(很少用到的东西)\n\n### 默认参数\nC++在声明函数原型的时可为一个或者多个参数指定默认(缺省)的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。\n~~~\n\nvoid TestFunc01(int a = 10, int b = 20){\n\tcout << \"a + b  = \" << a + b << endl;\n}\n\n//注意点:\n//1. 形参b设置默认参数值，那么后面位置的形参c也需要设置默认参数\nvoid TestFunc02(int a,int b = 10,int c = 10){}\n\n//2. 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不能再设置默认参数\nvoid TestFunc03(int a = 0,int b = 0);\nvoid TestFunc03(int a, int b){}\n\nint main(){\n\t//1.如果没有传参数，那么使用默认参数\n\tTestFunc01();\n\t//2. 如果传一个参数，那么第二个参数使用默认参数\n\tTestFunc01(100);\n\t//3. 如果传入两个参数，那么两个参数都使用我们传入的参数\n\tTestFunc01(100, 200);\n\n\treturn EXIT_SUCCESS;\n}\n\n~~~\n\n### 函数的占位参数\nC++在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声明。一般情况下，在函数体内部无法使用占位参数。\n~~~\n\nvoid TestFunc01(int a,int b,int){\n\t//函数内部无法使用占位参数\n\tcout << \"a + b = \" << a + b << endl;\n}\n\n//占位参数也可以设置默认值\nvoid TestFunc02(int a, int b, int = 20){\n\t//函数内部依旧无法使用占位参数\n\tcout << \"a + b = \" << a + b << endl;\n}\n\nint main(){\n\n\t//错误调用，占位参数也是参数，必须传参数\n\t//TestFunc01(10,20); \n\t//正确调用\n\tTestFunc01(10,20,30);\n\t//正确调用\n\tTestFunc02(10,20);\n\t//正确调用\n\tTestFunc02(10, 20, 30);\n\n\treturn EXIT_SUCCESS;\n}\n\n~~~\n\n## 函数重载(overload)\n\n跟之前学习Java时差不多，就是通过函数参数设置的不同从而实现多个同名函数。\n\n### 实现函数重载的条件\n-\t同一个作用域\n-\t参数个数不同\n-\t参数类型不同\n-\t参数顺序不同\n\n要注意，**返回值不作为函数重载的条件**！\n~~~\n//1. 函数重载条件\nnamespace A{\n\tvoid MyFunc(){ cout << \"无参数!\" << endl; }\n\tvoid MyFunc(int a){ cout << \"a: \" << a << endl; }\n\tvoid MyFunc(string b){ cout << \"b: \" << b << endl; }\n\tvoid MyFunc(int a, string b){ cout << \"a: \" << a << \" b:\" << b << endl;}\n    void MyFunc(string b, int a){cout << \"a: \" << a << \" b:\" << b << endl;}\n}\n//2.返回值不作为函数重载依据\nnamespace B{\n\tvoid MyFunc(string b, int a){}\n\t//int MyFunc(string b, int a){} //无法重载仅按返回值区分的函数\n}\n~~~\n\n编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，**编译器用不同的参数类型来修饰不同的函数名**，比如void func(); 编译器可能会将函数名修饰成_func，当编译器碰到void func(int x),编译器可能将函数名修饰为_func_int,当编译器碰到void func(int x,char c),编译器可能会将函数名修饰为_func_int_char ，编译器如何修饰重载的函数名称并没有一个统一的标准，不同的编译器可能会产生不同的内部名。\n\n因此，对于引用C的文件，C++必须使用extern命令，否则，C的文件无法引用。(C++编译器支持重载的特性对函数名进行修饰，导致找不到C定义的文件)\n\n在C文件中使用这种格式可以让其中所有函数在C++中无需任何改动使用。\n~~~\n#ifdef __cplusplus\nextern \"C\"{\n#endif\n\n\tvoid func1();\n\n#ifdef __cplusplus\n}\n#endif\n~~~\n\n或者在C++中对每一个C文件中的函数前加上extern \"C\"。\n~~~\nextern \"C\" void func1();\n~~~\n\n---\n\n## 类和对象\n\n在C中，行为和属性是分开的。\n\n在C++中，把变量（属性）和函数（操作）合成一个整体，封装在一个类中；对变量和函数进行访问控制（**public**,**protected**,**private**）\n\n- 类中默认private，protected只能内部使用和子类使用，private只能内部使用。\n\n- C++中，class默认访问权限为private,struct默认访问权限为public。\n\n和Java那一套很类似，**将成员变量均设置为private**，通过get，set等成员函数进行查看和修改。看似写了很多行代码，其实全都是很简单的。。。\n\n以下为一个点类的头文件部分定义，头文件记得加#pragma once。\n~~~\nclass Point {\nprivate:\n\tint m_X;\n\tint m_Y;\n};\n~~~\n这是实现文件，注意的是，实现时需要加**Point::**进行函数定义。\n~~~\nint Point::getX() {\n\treturn m_X;\n}\n~~~\n\n类可以嵌套，如下面这个圆类，圆心定义即为点类。\n~~~\nclass Circle {\nprivate:\n\tPoint m_Center;\n\tint m_R;\n};\n~~~\n\nPS:今天点到了一家不错的外卖，难得啊。\n","slug":"2019-Holiday-Note-11","published":1,"updated":"2019-07-24T15:13:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihm000usmjbgnblt3yg","content":"<h1 id=\"Holiday-Note-11\"><a href=\"#Holiday-Note-11\" class=\"headerlink\" title=\"Holiday Note_11\"></a>Holiday Note_11</h1><p>学了C++的<strong>内联函数</strong>，就是对C中宏的替代升级。还有<strong>内联函数</strong>，不怎么重要的函数的默认参数和占位参数，今天比较重要的是C++中的<strong>重载</strong>和<strong>类和对象</strong>的概念和使用，暂时觉得和跟上学期学的Java很像，写一堆其实都是get&amp;set方法。。。</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"内联函数-inline-function\"><a href=\"#内联函数-inline-function\" class=\"headerlink\" title=\"内联函数(inline function)\"></a>内联函数(inline function)</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline <span class=\"keyword\">int</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;<span class=\"keyword\">return</span> ++;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>C++引入内联函数是用于替换C中的宏。</p>\n<p><strong>内联函数为了继承宏函数的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为成员函数。内联函数本身也是一个真正的函数。</strong></p>\n<ul>\n<li>宏函数会有隐藏一些难以发现的错误。例如括号问题；((a++) &lt; (b)) ? (a++) : (b)。</li>\n<li>预处理器不允许访问类的成员，也就是说预处理器宏不能用作类类的成员函数</li>\n</ul>\n<h3 id=\"需要注意的是：\"><a href=\"#需要注意的是：\" class=\"headerlink\" title=\"需要注意的是：\"></a>需要注意的是：</h3><ol>\n<li><strong>函数体和声明必须结合</strong>在一起，否则编译器将它作为普通函数来对待。</li>\n<li>内联函数是以<strong>空间换时间</strong></li>\n<li>任何<strong>在类内部定义</strong>的函数<strong>自动</strong>成为内联函数</li>\n</ol>\n<h3 id=\"内联函数的一些限制\"><a href=\"#内联函数的一些限制\" class=\"headerlink\" title=\"内联函数的一些限制\"></a>内联函数的一些限制</h3><ul>\n<li>不能存在<strong>任何形式的循环语句</strong></li>\n<li>不能存在<strong>过多的条件判断</strong>语句</li>\n<li>函数体不能过于庞大</li>\n<li>不能<strong>对函数进行取址</strong>操作（类似宏，编译后找不到这个函数的入口）</li>\n</ul>\n<blockquote>\n<p>总的来说内联仅仅只是<strong>给编译器一个建议</strong>，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。</p>\n</blockquote>\n<hr>\n<h2 id=\"函数的默认参数和占位参数-很少用到的东西\"><a href=\"#函数的默认参数和占位参数-很少用到的东西\" class=\"headerlink\" title=\"函数的默认参数和占位参数(很少用到的东西)\"></a>函数的默认参数和占位参数(很少用到的东西)</h2><h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>C++在声明函数原型的时可为一个或者多个参数指定默认(缺省)的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc01</span><span class=\"params\">(<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>, <span class=\"keyword\">int</span> b = <span class=\"number\">20</span>)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a + b  = \"</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意点:</span></span><br><span class=\"line\"><span class=\"comment\">//1. 形参b设置默认参数值，那么后面位置的形参c也需要设置默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc02</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b = <span class=\"number\">10</span>,<span class=\"keyword\">int</span> c = <span class=\"number\">10</span>)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不能再设置默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc03</span><span class=\"params\">(<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>,<span class=\"keyword\">int</span> b = <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc03</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//1.如果没有传参数，那么使用默认参数</span></span><br><span class=\"line\">\tTestFunc01();</span><br><span class=\"line\">\t<span class=\"comment\">//2. 如果传一个参数，那么第二个参数使用默认参数</span></span><br><span class=\"line\">\tTestFunc01(<span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//3. 如果传入两个参数，那么两个参数都使用我们传入的参数</span></span><br><span class=\"line\">\tTestFunc01(<span class=\"number\">100</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数的占位参数\"><a href=\"#函数的占位参数\" class=\"headerlink\" title=\"函数的占位参数\"></a>函数的占位参数</h3><p>C++在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声明。一般情况下，在函数体内部无法使用占位参数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc01</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//函数内部无法使用占位参数</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a + b = \"</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//占位参数也可以设置默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc02</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> = <span class=\"number\">20</span>)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//函数内部依旧无法使用占位参数</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a + b = \"</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//错误调用，占位参数也是参数，必须传参数</span></span><br><span class=\"line\">\t<span class=\"comment\">//TestFunc01(10,20); </span></span><br><span class=\"line\">\t<span class=\"comment\">//正确调用</span></span><br><span class=\"line\">\tTestFunc01(<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//正确调用</span></span><br><span class=\"line\">\tTestFunc02(<span class=\"number\">10</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//正确调用</span></span><br><span class=\"line\">\tTestFunc02(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数重载-overload\"><a href=\"#函数重载-overload\" class=\"headerlink\" title=\"函数重载(overload)\"></a>函数重载(overload)</h2><p>跟之前学习Java时差不多，就是通过函数参数设置的不同从而实现多个同名函数。</p>\n<h3 id=\"实现函数重载的条件\"><a href=\"#实现函数重载的条件\" class=\"headerlink\" title=\"实现函数重载的条件\"></a>实现函数重载的条件</h3><ul>\n<li>同一个作用域</li>\n<li>参数个数不同</li>\n<li>参数类型不同</li>\n<li>参数顺序不同</li>\n</ul>\n<p>要注意，<strong>返回值不作为函数重载的条件</strong>！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 函数重载条件</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> A&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFunc</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"无参数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFunc</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a: \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFunc</span><span class=\"params\">(<span class=\"built_in\">string</span> b)</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"b: \"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFunc</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"built_in\">string</span> b)</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a: \"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\" b:\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFunc</span><span class=\"params\">(<span class=\"built_in\">string</span> b, <span class=\"keyword\">int</span> a)</span></span>&#123;<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a: \"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\" b:\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2.返回值不作为函数重载依据</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> B&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFunc</span><span class=\"params\">(<span class=\"built_in\">string</span> b, <span class=\"keyword\">int</span> a)</span></span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//int MyFunc(string b, int a)&#123;&#125; //无法重载仅按返回值区分的函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，<strong>编译器用不同的参数类型来修饰不同的函数名</strong>，比如void func(); 编译器可能会将函数名修饰成_func，当编译器碰到void func(int x),编译器可能将函数名修饰为_func_int,当编译器碰到void func(int x,char c),编译器可能会将函数名修饰为_func_int_char ，编译器如何修饰重载的函数名称并没有一个统一的标准，不同的编译器可能会产生不同的内部名。</p>\n<p>因此，对于引用C的文件，C++必须使用extern命令，否则，C的文件无法引用。(C++编译器支持重载的特性对函数名进行修饰，导致找不到C定义的文件)</p>\n<p>在C文件中使用这种格式可以让其中所有函数在C++中无需任何改动使用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>或者在C++中对每一个C文件中的函数前加上extern “C”。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h2><p>在C中，行为和属性是分开的。</p>\n<p>在C++中，把变量（属性）和函数（操作）合成一个整体，封装在一个类中；对变量和函数进行访问控制（<strong>public</strong>,<strong>protected</strong>,<strong>private</strong>）</p>\n<ul>\n<li><p>类中默认private，protected只能内部使用和子类使用，private只能内部使用。</p>\n</li>\n<li><p>C++中，class默认访问权限为private,struct默认访问权限为public。</p>\n</li>\n</ul>\n<p>和Java那一套很类似，<strong>将成员变量均设置为private</strong>，通过get，set等成员函数进行查看和修改。看似写了很多行代码，其实全都是很简单的。。。</p>\n<p>以下为一个点类的头文件部分定义，头文件记得加#pragma once。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_X;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_Y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这是实现文件，注意的是，实现时需要加<strong>Point::</strong>进行函数定义。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> Point::getX() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> m_X;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类可以嵌套，如下面这个圆类，圆心定义即为点类。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tPoint m_Center;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_R;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>PS:今天点到了一家不错的外卖，难得啊。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-11\"><a href=\"#Holiday-Note-11\" class=\"headerlink\" title=\"Holiday Note_11\"></a>Holiday Note_11</h1><p>学了C++的<strong>内联函数</strong>，就是对C中宏的替代升级。还有<strong>内联函数</strong>，不怎么重要的函数的默认参数和占位参数，今天比较重要的是C++中的<strong>重载</strong>和<strong>类和对象</strong>的概念和使用，暂时觉得和跟上学期学的Java很像，写一堆其实都是get&amp;set方法。。。</p>","more":"<hr>\n<h2 id=\"内联函数-inline-function\"><a href=\"#内联函数-inline-function\" class=\"headerlink\" title=\"内联函数(inline function)\"></a>内联函数(inline function)</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline <span class=\"keyword\">int</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;<span class=\"keyword\">return</span> ++;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>C++引入内联函数是用于替换C中的宏。</p>\n<p><strong>内联函数为了继承宏函数的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为成员函数。内联函数本身也是一个真正的函数。</strong></p>\n<ul>\n<li>宏函数会有隐藏一些难以发现的错误。例如括号问题；((a++) &lt; (b)) ? (a++) : (b)。</li>\n<li>预处理器不允许访问类的成员，也就是说预处理器宏不能用作类类的成员函数</li>\n</ul>\n<h3 id=\"需要注意的是：\"><a href=\"#需要注意的是：\" class=\"headerlink\" title=\"需要注意的是：\"></a>需要注意的是：</h3><ol>\n<li><strong>函数体和声明必须结合</strong>在一起，否则编译器将它作为普通函数来对待。</li>\n<li>内联函数是以<strong>空间换时间</strong></li>\n<li>任何<strong>在类内部定义</strong>的函数<strong>自动</strong>成为内联函数</li>\n</ol>\n<h3 id=\"内联函数的一些限制\"><a href=\"#内联函数的一些限制\" class=\"headerlink\" title=\"内联函数的一些限制\"></a>内联函数的一些限制</h3><ul>\n<li>不能存在<strong>任何形式的循环语句</strong></li>\n<li>不能存在<strong>过多的条件判断</strong>语句</li>\n<li>函数体不能过于庞大</li>\n<li>不能<strong>对函数进行取址</strong>操作（类似宏，编译后找不到这个函数的入口）</li>\n</ul>\n<blockquote>\n<p>总的来说内联仅仅只是<strong>给编译器一个建议</strong>，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。</p>\n</blockquote>\n<hr>\n<h2 id=\"函数的默认参数和占位参数-很少用到的东西\"><a href=\"#函数的默认参数和占位参数-很少用到的东西\" class=\"headerlink\" title=\"函数的默认参数和占位参数(很少用到的东西)\"></a>函数的默认参数和占位参数(很少用到的东西)</h2><h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>C++在声明函数原型的时可为一个或者多个参数指定默认(缺省)的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc01</span><span class=\"params\">(<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>, <span class=\"keyword\">int</span> b = <span class=\"number\">20</span>)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a + b  = \"</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意点:</span></span><br><span class=\"line\"><span class=\"comment\">//1. 形参b设置默认参数值，那么后面位置的形参c也需要设置默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc02</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b = <span class=\"number\">10</span>,<span class=\"keyword\">int</span> c = <span class=\"number\">10</span>)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不能再设置默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc03</span><span class=\"params\">(<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>,<span class=\"keyword\">int</span> b = <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc03</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//1.如果没有传参数，那么使用默认参数</span></span><br><span class=\"line\">\tTestFunc01();</span><br><span class=\"line\">\t<span class=\"comment\">//2. 如果传一个参数，那么第二个参数使用默认参数</span></span><br><span class=\"line\">\tTestFunc01(<span class=\"number\">100</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//3. 如果传入两个参数，那么两个参数都使用我们传入的参数</span></span><br><span class=\"line\">\tTestFunc01(<span class=\"number\">100</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数的占位参数\"><a href=\"#函数的占位参数\" class=\"headerlink\" title=\"函数的占位参数\"></a>函数的占位参数</h3><p>C++在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声明。一般情况下，在函数体内部无法使用占位参数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc01</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//函数内部无法使用占位参数</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a + b = \"</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//占位参数也可以设置默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc02</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> = <span class=\"number\">20</span>)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//函数内部依旧无法使用占位参数</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a + b = \"</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//错误调用，占位参数也是参数，必须传参数</span></span><br><span class=\"line\">\t<span class=\"comment\">//TestFunc01(10,20); </span></span><br><span class=\"line\">\t<span class=\"comment\">//正确调用</span></span><br><span class=\"line\">\tTestFunc01(<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//正确调用</span></span><br><span class=\"line\">\tTestFunc02(<span class=\"number\">10</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//正确调用</span></span><br><span class=\"line\">\tTestFunc02(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数重载-overload\"><a href=\"#函数重载-overload\" class=\"headerlink\" title=\"函数重载(overload)\"></a>函数重载(overload)</h2><p>跟之前学习Java时差不多，就是通过函数参数设置的不同从而实现多个同名函数。</p>\n<h3 id=\"实现函数重载的条件\"><a href=\"#实现函数重载的条件\" class=\"headerlink\" title=\"实现函数重载的条件\"></a>实现函数重载的条件</h3><ul>\n<li>同一个作用域</li>\n<li>参数个数不同</li>\n<li>参数类型不同</li>\n<li>参数顺序不同</li>\n</ul>\n<p>要注意，<strong>返回值不作为函数重载的条件</strong>！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 函数重载条件</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> A&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFunc</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"无参数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFunc</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a: \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFunc</span><span class=\"params\">(<span class=\"built_in\">string</span> b)</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"b: \"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFunc</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"built_in\">string</span> b)</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a: \"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\" b:\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFunc</span><span class=\"params\">(<span class=\"built_in\">string</span> b, <span class=\"keyword\">int</span> a)</span></span>&#123;<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a: \"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\" b:\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2.返回值不作为函数重载依据</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> B&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFunc</span><span class=\"params\">(<span class=\"built_in\">string</span> b, <span class=\"keyword\">int</span> a)</span></span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//int MyFunc(string b, int a)&#123;&#125; //无法重载仅按返回值区分的函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，<strong>编译器用不同的参数类型来修饰不同的函数名</strong>，比如void func(); 编译器可能会将函数名修饰成_func，当编译器碰到void func(int x),编译器可能将函数名修饰为_func_int,当编译器碰到void func(int x,char c),编译器可能会将函数名修饰为_func_int_char ，编译器如何修饰重载的函数名称并没有一个统一的标准，不同的编译器可能会产生不同的内部名。</p>\n<p>因此，对于引用C的文件，C++必须使用extern命令，否则，C的文件无法引用。(C++编译器支持重载的特性对函数名进行修饰，导致找不到C定义的文件)</p>\n<p>在C文件中使用这种格式可以让其中所有函数在C++中无需任何改动使用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>或者在C++中对每一个C文件中的函数前加上extern “C”。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h2><p>在C中，行为和属性是分开的。</p>\n<p>在C++中，把变量（属性）和函数（操作）合成一个整体，封装在一个类中；对变量和函数进行访问控制（<strong>public</strong>,<strong>protected</strong>,<strong>private</strong>）</p>\n<ul>\n<li><p>类中默认private，protected只能内部使用和子类使用，private只能内部使用。</p>\n</li>\n<li><p>C++中，class默认访问权限为private,struct默认访问权限为public。</p>\n</li>\n</ul>\n<p>和Java那一套很类似，<strong>将成员变量均设置为private</strong>，通过get，set等成员函数进行查看和修改。看似写了很多行代码，其实全都是很简单的。。。</p>\n<p>以下为一个点类的头文件部分定义，头文件记得加#pragma once。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_X;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_Y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这是实现文件，注意的是，实现时需要加<strong>Point::</strong>进行函数定义。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> Point::getX() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> m_X;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类可以嵌套，如下面这个圆类，圆心定义即为点类。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tPoint m_Center;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_R;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>PS:今天点到了一家不错的外卖，难得啊。</p>"},{"title":"Holiday Note_12","date":"2019-07-24T12:37:38.000Z","_content":"\n# Holiday Note_12\n\n**对象的构造与析构**这块的知识点有点多的，不难但细节特别多。**构造函数**，**析构函数**，**拷贝函数**，**浅拷贝和深拷贝**，**new**和**delete**运算符，**explicit**，**静态成员**。看完了剑谱大佬的大学学习经历：惊为天人，膜拜。\n\n <!-- more -->\n\n---\n\n## 对象的构造和析构\n\n**对象的初始化和清理**也是两个非常重要的安全问题，一个对象或者变量没有初始时，对其使用后果是未知，同样的使用完一个变量，没有及时清理，也会造成一定的安全问题。\n\nC++提供**构造函数**和**析构函数**，这两个函数将会被编译器**自动调用**，完成对象初始化和对象清理工作。系统会默认调用构造函数和析构函数，而且只会**调用一次**。如果我们没有提供构造和析构，系统会默认提供，**空实现**。\n\n\n### 构造函数和析构函数\n\n构造函数语法：\n-\t构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数(即**可以重载**)。\n-\tClassName(){}\n\n析构函数语法：\n-\t析构函数函数名是在类名前面加' ~ '组成,没有返回值，不能有void,不能有参数，**不能重载**。\n-\t~ClassName(){}\n\n### 构造函数的分类及调用\n\n-\t按参数类型：分为无参构造函数和有参构造函数\n-\t按类型分类：普通构造函数和拷贝构造函数(复制构造函数)\n\n**注意拷贝构造函数参数类型(const Class&)**\n~~~\nclass Person{\npublic:\n\t//拷贝构造函数(复制构造函数) 使用另一个对象初始化本对象\n\tPerson(const Person& person){\t\t\n\t\tmAge = person.mAge;\n\t}\n\nprivate:\n\tint mAge;\n};\n~~~\n\n### 构造函数的调用方法注意\n\n1.\t无参构造写法和调用\n\n- Person p1 ; 注意不能写 Person p1() ，因为编译器认为这个是函数声明\n\n2.\t有参构造写法和调用\n\n- Person p2(10)  或者 Person p2 = Person(10)\n\n- Person(10) 匿名对象 ，执行当前行后就会释放即析构这个对象\n\n3.\t拷贝构造函数\n-\tPerson( const Person & p )\n-\t可以使用Perons p1( p2) 或者 Person p1 = Person(p2)\n\n-\t不能用拷贝构造函数初始化匿名对象\n-\t如果写成 Person (p1)  这种写法等价于 Person p1，写到右值可以做拷贝构造函数\n\t\t\n\n4.\tPerson P = 100 隐式类型转换（使用explicit关键字可以禁止使用隐式类型转换） 相当于调用 Person p = Person(100)\n\n\n### 拷贝构造函数的调用时机\n\n1. 对象以值传递的方式传给函数参数\n~~~\n// 传递的参数是普通对象，函数参数也是普通对象，传递将会调用拷贝构造\nvoid doBussiness(Person p){}\n\nvoid test02(){\n\tPerson p(10);\n\tdoBussiness(p);\n}\n~~~\n\n2.\t函数局部对象以值传递的方式从函数返回(vs debug模式下调用一次拷贝构造，qt不调用任何构造)\n~~~\n函数返回局部对象\nPerson MyBusiness(){\n\tPerson p(10);\n\treturn p;\n}\nvoid test03(){\n\t//vs release、qt下没有调用拷贝构造函数\n\t//vs debug下调用一次拷贝构造函数\n\tPerson p = MyBusiness();\n~~~\n\n3.\t用一个对象初始化另一个对象\n~~~\nPerson p(10);\nPerson p1(p);\n~~~\n\n\n### 构造函数调用规则\n\n默认情况下，C++编译器至少为我们写的类增加3个函数\n1. 默认构造函数(无参，函数体为空)\n2. 默认析构函数(无参，函数体为空)\n3. 默认拷贝构造函数，对类中**非静态成员属性简单值拷贝**\n-\t如果**用户定义拷贝构造函数，C++不会再提供任何默认构造函数**\n-\t如果**用户定义了普通构造(非拷贝)，C++不在提供默认无参构造，但是会提供默认拷贝构造**\n\n\n### 浅拷贝和深拷贝\n\n当**类中有指针**，并且指针指向**动态分配的内存空间**，析构函数做了动态**内存释放**的处理，会导致内存问题。(即内存重复释放导致程序出错)\n\n因为浅拷贝只是拷贝了内存的地址，而当被拷贝的类析构时完成释放内存后，拷贝的类析构时再次对该内存进行释放因而会产生错位。\n\n因此当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要**自定义拷贝构造函数**，自行给指针动态分配空间，深拷贝。\n\n### 多个对象的构造和析构\n\n传统方式初始化，即进行有参构造\n~~~\nPerson(int a,int b,int c){\n\tmA = a;\n\tmB = b;\n\tmC = c;\n}\n~~~\n**初始化列表**方式初始化方法。(:)\n~~~\nPerson(int a, int b, int c):mA(a),mB(b),mC(c){}\n~~~\n\n\n> 注意：在**类对象作为成员的情况下**：当调用构造函数时，首先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体。也就是说，**先调用对象成员的构造函数**，**再调用本身的构造函数**。**析构函数和构造函数调用顺序相反**，先构造，后析构\n\n\n### explicit关键字\n \n声明为explicit的构造函数不能在隐式转换中使用，防止构造时寓意不明。\n\n---\n\n## 动态分配内存\n\n使用C的动态内存分配函数在堆上创建类的问题(麻烦)\n-\t程序员必须确定对象的长度。\n-\tmalloc返回一个万能指针，c++不允许将万能赋值给其他任何指针，必须强转。\n-\tmalloc可能申请内存失败，所以必须判断返回值来确保内存分配成功。\n-\t用户在使用对象之前必须记住对他初始化，构造函数不能显示调用初始化(构造函数是由编译器调用)，用户有可能忘记调用初始化函数。\n\n> C的动态内存分配函数太复杂，容易令人混淆，是不可接受的。\n\n### new 运算符(operator)\n当用new创建一个对象时，它就**在堆里为对象分配内存**并**调用构造函数完成初始化**。\n~~~\nPerson* person = new Person;\n~~~\n相当于:为对象分配内存\n~~~\nPerson* person = (Person*)malloc(sizeof(Person));\n\tif(person == NULL){\n\t\treturn 0;\n\t}\n~~~\n以及对象初始化\n~~~\nperson->Init();\n~~~\n\nnew操作符能确定在调用构造函数初始化之前内存分配是成功的，所有不用显式确定调用是否成功。\n\n### delete 运算符(operator)\n\ndelete表达式**先调用析构函数**，然后**释放内存**。正如new表达式返回一个指向对象的指针一样，delete需要一个对象的**地址**。\n\n### 注意\n1. **new的对象用万能指针去接收会导致无法释放对象**\n2. 使用new和delete在堆上创建数组时，**delete的格式[]**！！！\n~~~\n//创建字符数组\nchar* pStr = new char[100];\n//创建整型数组\nint* pArr1 = new int[100]; \n//创建整型数组并初始化\nint* pArr2 = new int[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n//释放数组内存\ndelete[] pStr;\ndelete[] pArr1;\ndelete[] pArr2;\n~~~\n\n---\n\n## 静态成员\n\n### 静态成员变量\n\n在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。\n\n不管这个类创建了多少个对象，静态成员**只有一个拷贝**，这个拷贝被所有属于这个类的对象共享。\n\n注意：\n- **静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。**\n- 静态成员变量必须在**类中声明，在类外定义**。\n- 静态数据成员不属于某个对象，在**为对象分配空间中不包括静态成员所占空间**。\n- 静态数据成员可以通过**类名或者对象名来引用**。\n- 静态成员也有**访问权限**，**类外不能访问私有成员**\n\n静态成员变量的**初始化**\n~~~\nclass Person{\npublic:\n\t//类的静态成员属性\n\tstatic int sNum;\nprivate:\n\tstatic int sOther;\n};\n\n//类外初始化，初始化时不加static\nint Person::sNum = 0;\nint Person::sOther = 0;\n~~~\n**访问**静态成员变量的**两种方式**。\n~~~\n//1. 通过类名直接访问\n\tPerson::sNum = 100;\n\n//2. 通过对象访问\n\tPerson p1, p2;\n\tp1.sNum = 200;\n~~~\n\n\n### 静态成员函数 \n和静态变量一样，同样**在对象没有创建前，即可通过类名调用**。静态成员函数主要为了访问静态变量，但是，不能访问普通成员变量。\n\n静态成员函数的意义，不在于信息共享，数据沟通，而在于**管理静态数据成员，完成对静态数据成员的封装**。\n\n注意:\n-\t**静态成员函数只能访问静态变量，不能访问普通成员变量**\n-\t静态成员函数的使用和静态成员变量一样\n-\t静态成员函数也有访问权限\n-\t普通成员函数可访问静态成员变量、也可以访问非经常成员变量\n\nPS:今晚花了一个小时看完了剑谱大佬写的大学学习经历，特别是大二下加进实验室之后的学习之路，震惊了。买张床直接住里边，学到超神！\n\n\n\n","source":"_posts/2019-Holiday-Note-12.md","raw":"---\ntitle: Holiday Note_12\ndate: 2019-07-24 20:37:38\ncategories: C++\ntags: [Note,C++]\n---\n\n# Holiday Note_12\n\n**对象的构造与析构**这块的知识点有点多的，不难但细节特别多。**构造函数**，**析构函数**，**拷贝函数**，**浅拷贝和深拷贝**，**new**和**delete**运算符，**explicit**，**静态成员**。看完了剑谱大佬的大学学习经历：惊为天人，膜拜。\n\n <!-- more -->\n\n---\n\n## 对象的构造和析构\n\n**对象的初始化和清理**也是两个非常重要的安全问题，一个对象或者变量没有初始时，对其使用后果是未知，同样的使用完一个变量，没有及时清理，也会造成一定的安全问题。\n\nC++提供**构造函数**和**析构函数**，这两个函数将会被编译器**自动调用**，完成对象初始化和对象清理工作。系统会默认调用构造函数和析构函数，而且只会**调用一次**。如果我们没有提供构造和析构，系统会默认提供，**空实现**。\n\n\n### 构造函数和析构函数\n\n构造函数语法：\n-\t构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数(即**可以重载**)。\n-\tClassName(){}\n\n析构函数语法：\n-\t析构函数函数名是在类名前面加' ~ '组成,没有返回值，不能有void,不能有参数，**不能重载**。\n-\t~ClassName(){}\n\n### 构造函数的分类及调用\n\n-\t按参数类型：分为无参构造函数和有参构造函数\n-\t按类型分类：普通构造函数和拷贝构造函数(复制构造函数)\n\n**注意拷贝构造函数参数类型(const Class&)**\n~~~\nclass Person{\npublic:\n\t//拷贝构造函数(复制构造函数) 使用另一个对象初始化本对象\n\tPerson(const Person& person){\t\t\n\t\tmAge = person.mAge;\n\t}\n\nprivate:\n\tint mAge;\n};\n~~~\n\n### 构造函数的调用方法注意\n\n1.\t无参构造写法和调用\n\n- Person p1 ; 注意不能写 Person p1() ，因为编译器认为这个是函数声明\n\n2.\t有参构造写法和调用\n\n- Person p2(10)  或者 Person p2 = Person(10)\n\n- Person(10) 匿名对象 ，执行当前行后就会释放即析构这个对象\n\n3.\t拷贝构造函数\n-\tPerson( const Person & p )\n-\t可以使用Perons p1( p2) 或者 Person p1 = Person(p2)\n\n-\t不能用拷贝构造函数初始化匿名对象\n-\t如果写成 Person (p1)  这种写法等价于 Person p1，写到右值可以做拷贝构造函数\n\t\t\n\n4.\tPerson P = 100 隐式类型转换（使用explicit关键字可以禁止使用隐式类型转换） 相当于调用 Person p = Person(100)\n\n\n### 拷贝构造函数的调用时机\n\n1. 对象以值传递的方式传给函数参数\n~~~\n// 传递的参数是普通对象，函数参数也是普通对象，传递将会调用拷贝构造\nvoid doBussiness(Person p){}\n\nvoid test02(){\n\tPerson p(10);\n\tdoBussiness(p);\n}\n~~~\n\n2.\t函数局部对象以值传递的方式从函数返回(vs debug模式下调用一次拷贝构造，qt不调用任何构造)\n~~~\n函数返回局部对象\nPerson MyBusiness(){\n\tPerson p(10);\n\treturn p;\n}\nvoid test03(){\n\t//vs release、qt下没有调用拷贝构造函数\n\t//vs debug下调用一次拷贝构造函数\n\tPerson p = MyBusiness();\n~~~\n\n3.\t用一个对象初始化另一个对象\n~~~\nPerson p(10);\nPerson p1(p);\n~~~\n\n\n### 构造函数调用规则\n\n默认情况下，C++编译器至少为我们写的类增加3个函数\n1. 默认构造函数(无参，函数体为空)\n2. 默认析构函数(无参，函数体为空)\n3. 默认拷贝构造函数，对类中**非静态成员属性简单值拷贝**\n-\t如果**用户定义拷贝构造函数，C++不会再提供任何默认构造函数**\n-\t如果**用户定义了普通构造(非拷贝)，C++不在提供默认无参构造，但是会提供默认拷贝构造**\n\n\n### 浅拷贝和深拷贝\n\n当**类中有指针**，并且指针指向**动态分配的内存空间**，析构函数做了动态**内存释放**的处理，会导致内存问题。(即内存重复释放导致程序出错)\n\n因为浅拷贝只是拷贝了内存的地址，而当被拷贝的类析构时完成释放内存后，拷贝的类析构时再次对该内存进行释放因而会产生错位。\n\n因此当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要**自定义拷贝构造函数**，自行给指针动态分配空间，深拷贝。\n\n### 多个对象的构造和析构\n\n传统方式初始化，即进行有参构造\n~~~\nPerson(int a,int b,int c){\n\tmA = a;\n\tmB = b;\n\tmC = c;\n}\n~~~\n**初始化列表**方式初始化方法。(:)\n~~~\nPerson(int a, int b, int c):mA(a),mB(b),mC(c){}\n~~~\n\n\n> 注意：在**类对象作为成员的情况下**：当调用构造函数时，首先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体。也就是说，**先调用对象成员的构造函数**，**再调用本身的构造函数**。**析构函数和构造函数调用顺序相反**，先构造，后析构\n\n\n### explicit关键字\n \n声明为explicit的构造函数不能在隐式转换中使用，防止构造时寓意不明。\n\n---\n\n## 动态分配内存\n\n使用C的动态内存分配函数在堆上创建类的问题(麻烦)\n-\t程序员必须确定对象的长度。\n-\tmalloc返回一个万能指针，c++不允许将万能赋值给其他任何指针，必须强转。\n-\tmalloc可能申请内存失败，所以必须判断返回值来确保内存分配成功。\n-\t用户在使用对象之前必须记住对他初始化，构造函数不能显示调用初始化(构造函数是由编译器调用)，用户有可能忘记调用初始化函数。\n\n> C的动态内存分配函数太复杂，容易令人混淆，是不可接受的。\n\n### new 运算符(operator)\n当用new创建一个对象时，它就**在堆里为对象分配内存**并**调用构造函数完成初始化**。\n~~~\nPerson* person = new Person;\n~~~\n相当于:为对象分配内存\n~~~\nPerson* person = (Person*)malloc(sizeof(Person));\n\tif(person == NULL){\n\t\treturn 0;\n\t}\n~~~\n以及对象初始化\n~~~\nperson->Init();\n~~~\n\nnew操作符能确定在调用构造函数初始化之前内存分配是成功的，所有不用显式确定调用是否成功。\n\n### delete 运算符(operator)\n\ndelete表达式**先调用析构函数**，然后**释放内存**。正如new表达式返回一个指向对象的指针一样，delete需要一个对象的**地址**。\n\n### 注意\n1. **new的对象用万能指针去接收会导致无法释放对象**\n2. 使用new和delete在堆上创建数组时，**delete的格式[]**！！！\n~~~\n//创建字符数组\nchar* pStr = new char[100];\n//创建整型数组\nint* pArr1 = new int[100]; \n//创建整型数组并初始化\nint* pArr2 = new int[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n//释放数组内存\ndelete[] pStr;\ndelete[] pArr1;\ndelete[] pArr2;\n~~~\n\n---\n\n## 静态成员\n\n### 静态成员变量\n\n在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。\n\n不管这个类创建了多少个对象，静态成员**只有一个拷贝**，这个拷贝被所有属于这个类的对象共享。\n\n注意：\n- **静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。**\n- 静态成员变量必须在**类中声明，在类外定义**。\n- 静态数据成员不属于某个对象，在**为对象分配空间中不包括静态成员所占空间**。\n- 静态数据成员可以通过**类名或者对象名来引用**。\n- 静态成员也有**访问权限**，**类外不能访问私有成员**\n\n静态成员变量的**初始化**\n~~~\nclass Person{\npublic:\n\t//类的静态成员属性\n\tstatic int sNum;\nprivate:\n\tstatic int sOther;\n};\n\n//类外初始化，初始化时不加static\nint Person::sNum = 0;\nint Person::sOther = 0;\n~~~\n**访问**静态成员变量的**两种方式**。\n~~~\n//1. 通过类名直接访问\n\tPerson::sNum = 100;\n\n//2. 通过对象访问\n\tPerson p1, p2;\n\tp1.sNum = 200;\n~~~\n\n\n### 静态成员函数 \n和静态变量一样，同样**在对象没有创建前，即可通过类名调用**。静态成员函数主要为了访问静态变量，但是，不能访问普通成员变量。\n\n静态成员函数的意义，不在于信息共享，数据沟通，而在于**管理静态数据成员，完成对静态数据成员的封装**。\n\n注意:\n-\t**静态成员函数只能访问静态变量，不能访问普通成员变量**\n-\t静态成员函数的使用和静态成员变量一样\n-\t静态成员函数也有访问权限\n-\t普通成员函数可访问静态成员变量、也可以访问非经常成员变量\n\nPS:今晚花了一个小时看完了剑谱大佬写的大学学习经历，特别是大二下加进实验室之后的学习之路，震惊了。买张床直接住里边，学到超神！\n\n\n\n","slug":"2019-Holiday-Note-12","published":1,"updated":"2019-07-24T15:13:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihn000ysmjb9uzw9zpa","content":"<h1 id=\"Holiday-Note-12\"><a href=\"#Holiday-Note-12\" class=\"headerlink\" title=\"Holiday Note_12\"></a>Holiday Note_12</h1><p><strong>对象的构造与析构</strong>这块的知识点有点多的，不难但细节特别多。<strong>构造函数</strong>，<strong>析构函数</strong>，<strong>拷贝函数</strong>，<strong>浅拷贝和深拷贝</strong>，<strong>new</strong>和<strong>delete</strong>运算符，<strong>explicit</strong>，<strong>静态成员</strong>。看完了剑谱大佬的大学学习经历：惊为天人，膜拜。</p>\n <a id=\"more\"></a>\n\n<hr>\n<h2 id=\"对象的构造和析构\"><a href=\"#对象的构造和析构\" class=\"headerlink\" title=\"对象的构造和析构\"></a>对象的构造和析构</h2><p><strong>对象的初始化和清理</strong>也是两个非常重要的安全问题，一个对象或者变量没有初始时，对其使用后果是未知，同样的使用完一个变量，没有及时清理，也会造成一定的安全问题。</p>\n<p>C++提供<strong>构造函数</strong>和<strong>析构函数</strong>，这两个函数将会被编译器<strong>自动调用</strong>，完成对象初始化和对象清理工作。系统会默认调用构造函数和析构函数，而且只会<strong>调用一次</strong>。如果我们没有提供构造和析构，系统会默认提供，<strong>空实现</strong>。</p>\n<h3 id=\"构造函数和析构函数\"><a href=\"#构造函数和析构函数\" class=\"headerlink\" title=\"构造函数和析构函数\"></a>构造函数和析构函数</h3><p>构造函数语法：</p>\n<ul>\n<li>构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数(即<strong>可以重载</strong>)。</li>\n<li>ClassName(){}</li>\n</ul>\n<p>析构函数语法：</p>\n<ul>\n<li>析构函数函数名是在类名前面加’ ~ ‘组成,没有返回值，不能有void,不能有参数，<strong>不能重载</strong>。</li>\n<li>~ClassName(){}</li>\n</ul>\n<h3 id=\"构造函数的分类及调用\"><a href=\"#构造函数的分类及调用\" class=\"headerlink\" title=\"构造函数的分类及调用\"></a>构造函数的分类及调用</h3><ul>\n<li>按参数类型：分为无参构造函数和有参构造函数</li>\n<li>按类型分类：普通构造函数和拷贝构造函数(复制构造函数)</li>\n</ul>\n<p><strong>注意拷贝构造函数参数类型(const Class&amp;)</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//拷贝构造函数(复制构造函数) 使用另一个对象初始化本对象</span></span><br><span class=\"line\">\tPerson(<span class=\"keyword\">const</span> Person&amp; person)&#123;\t\t</span><br><span class=\"line\">\t\tmAge = person.mAge;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mAge;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造函数的调用方法注意\"><a href=\"#构造函数的调用方法注意\" class=\"headerlink\" title=\"构造函数的调用方法注意\"></a>构造函数的调用方法注意</h3><ol>\n<li>无参构造写法和调用</li>\n</ol>\n<ul>\n<li>Person p1 ; 注意不能写 Person p1() ，因为编译器认为这个是函数声明</li>\n</ul>\n<ol start=\"2\">\n<li>有参构造写法和调用</li>\n</ol>\n<ul>\n<li><p>Person p2(10)  或者 Person p2 = Person(10)</p>\n</li>\n<li><p>Person(10) 匿名对象 ，执行当前行后就会释放即析构这个对象</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>拷贝构造函数</li>\n</ol>\n<ul>\n<li><p>Person( const Person &amp; p )</p>\n</li>\n<li><p>可以使用Perons p1( p2) 或者 Person p1 = Person(p2)</p>\n</li>\n<li><p>不能用拷贝构造函数初始化匿名对象</p>\n</li>\n<li><p>如果写成 Person (p1)  这种写法等价于 Person p1，写到右值可以做拷贝构造函数</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>Person P = 100 隐式类型转换（使用explicit关键字可以禁止使用隐式类型转换） 相当于调用 Person p = Person(100)</li>\n</ol>\n<h3 id=\"拷贝构造函数的调用时机\"><a href=\"#拷贝构造函数的调用时机\" class=\"headerlink\" title=\"拷贝构造函数的调用时机\"></a>拷贝构造函数的调用时机</h3><ol>\n<li><p>对象以值传递的方式传给函数参数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传递的参数是普通对象，函数参数也是普通对象，传递将会调用拷贝构造</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doBussiness</span><span class=\"params\">(Person p)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Person <span class=\"title\">p</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">\tdoBussiness(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数局部对象以值传递的方式从函数返回(vs debug模式下调用一次拷贝构造，qt不调用任何构造)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数返回局部对象</span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">MyBusiness</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Person <span class=\"title\">p</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test03</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//vs release、qt下没有调用拷贝构造函数</span></span><br><span class=\"line\">\t<span class=\"comment\">//vs debug下调用一次拷贝构造函数</span></span><br><span class=\"line\">\tPerson p = MyBusiness();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用一个对象初始化另一个对象</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p(<span class=\"number\">10</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">Person p1(<span class=\"name\">p</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"构造函数调用规则\"><a href=\"#构造函数调用规则\" class=\"headerlink\" title=\"构造函数调用规则\"></a>构造函数调用规则</h3><p>默认情况下，C++编译器至少为我们写的类增加3个函数</p>\n<ol>\n<li>默认构造函数(无参，函数体为空)</li>\n<li>默认析构函数(无参，函数体为空)</li>\n<li>默认拷贝构造函数，对类中<strong>非静态成员属性简单值拷贝</strong></li>\n</ol>\n<ul>\n<li>如果<strong>用户定义拷贝构造函数，C++不会再提供任何默认构造函数</strong></li>\n<li>如果<strong>用户定义了普通构造(非拷贝)，C++不在提供默认无参构造，但是会提供默认拷贝构造</strong></li>\n</ul>\n<h3 id=\"浅拷贝和深拷贝\"><a href=\"#浅拷贝和深拷贝\" class=\"headerlink\" title=\"浅拷贝和深拷贝\"></a>浅拷贝和深拷贝</h3><p>当<strong>类中有指针</strong>，并且指针指向<strong>动态分配的内存空间</strong>，析构函数做了动态<strong>内存释放</strong>的处理，会导致内存问题。(即内存重复释放导致程序出错)</p>\n<p>因为浅拷贝只是拷贝了内存的地址，而当被拷贝的类析构时完成释放内存后，拷贝的类析构时再次对该内存进行释放因而会产生错位。</p>\n<p>因此当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要<strong>自定义拷贝构造函数</strong>，自行给指针动态分配空间，深拷贝。</p>\n<h3 id=\"多个对象的构造和析构\"><a href=\"#多个对象的构造和析构\" class=\"headerlink\" title=\"多个对象的构造和析构\"></a>多个对象的构造和析构</h3><p>传统方式初始化，即进行有参构造</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person(int a,int <span class=\"keyword\">b,int </span>c)&#123;</span><br><span class=\"line\">\tmA = a<span class=\"comment\">;</span></span><br><span class=\"line\">\tmB = <span class=\"keyword\">b;</span></span><br><span class=\"line\"><span class=\"keyword\">\t</span>mC = c<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>初始化列表</strong>方式初始化方法。(:)</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">Person</span>(int a, int b, int c)<span class=\"selector-pseudo\">:mA(a)</span>,<span class=\"selector-tag\">mB</span>(b),<span class=\"selector-tag\">mC</span>(c)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：在<strong>类对象作为成员的情况下</strong>：当调用构造函数时，首先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体。也就是说，<strong>先调用对象成员的构造函数</strong>，<strong>再调用本身的构造函数</strong>。<strong>析构函数和构造函数调用顺序相反</strong>，先构造，后析构</p>\n</blockquote>\n<h3 id=\"explicit关键字\"><a href=\"#explicit关键字\" class=\"headerlink\" title=\"explicit关键字\"></a>explicit关键字</h3><p>声明为explicit的构造函数不能在隐式转换中使用，防止构造时寓意不明。</p>\n<hr>\n<h2 id=\"动态分配内存\"><a href=\"#动态分配内存\" class=\"headerlink\" title=\"动态分配内存\"></a>动态分配内存</h2><p>使用C的动态内存分配函数在堆上创建类的问题(麻烦)</p>\n<ul>\n<li>程序员必须确定对象的长度。</li>\n<li>malloc返回一个万能指针，c++不允许将万能赋值给其他任何指针，必须强转。</li>\n<li>malloc可能申请内存失败，所以必须判断返回值来确保内存分配成功。</li>\n<li>用户在使用对象之前必须记住对他初始化，构造函数不能显示调用初始化(构造函数是由编译器调用)，用户有可能忘记调用初始化函数。</li>\n</ul>\n<blockquote>\n<p>C的动态内存分配函数太复杂，容易令人混淆，是不可接受的。</p>\n</blockquote>\n<h3 id=\"new-运算符-operator\"><a href=\"#new-运算符-operator\" class=\"headerlink\" title=\"new 运算符(operator)\"></a>new 运算符(operator)</h3><p>当用new创建一个对象时，它就<strong>在堆里为对象分配内存</strong>并<strong>调用构造函数完成初始化</strong>。</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Person</span>* <span class=\"keyword\">person</span> = new <span class=\"keyword\">Person</span>;</span><br></pre></td></tr></table></figure>\n\n<p>相当于:为对象分配内存</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person* person = (Person*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Person));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(person == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及对象初始化</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">person</span>-&gt;</span>Init();</span><br></pre></td></tr></table></figure>\n\n<p>new操作符能确定在调用构造函数初始化之前内存分配是成功的，所有不用显式确定调用是否成功。</p>\n<h3 id=\"delete-运算符-operator\"><a href=\"#delete-运算符-operator\" class=\"headerlink\" title=\"delete 运算符(operator)\"></a>delete 运算符(operator)</h3><p>delete表达式<strong>先调用析构函数</strong>，然后<strong>释放内存</strong>。正如new表达式返回一个指向对象的指针一样，delete需要一个对象的<strong>地址</strong>。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li><strong>new的对象用万能指针去接收会导致无法释放对象</strong></li>\n<li>使用new和delete在堆上创建数组时，<strong>delete的格式[]</strong>！！！<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建字符数组</span></span><br><span class=\"line\">char* pStr = new char[<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"comment\">//创建整型数组</span></span><br><span class=\"line\">int* pArr1 = new int[<span class=\"number\">100</span>]; </span><br><span class=\"line\"><span class=\"comment\">//创建整型数组并初始化</span></span><br><span class=\"line\">int* pArr2 = new int[<span class=\"number\">10</span>]&#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//释放数组内存</span></span><br><span class=\"line\">delete[] pStr;</span><br><span class=\"line\">delete[] pArr1;</span><br><span class=\"line\">delete[] pArr2;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<h2 id=\"静态成员\"><a href=\"#静态成员\" class=\"headerlink\" title=\"静态成员\"></a>静态成员</h2><h3 id=\"静态成员变量\"><a href=\"#静态成员变量\" class=\"headerlink\" title=\"静态成员变量\"></a>静态成员变量</h3><p>在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。</p>\n<p>不管这个类创建了多少个对象，静态成员<strong>只有一个拷贝</strong>，这个拷贝被所有属于这个类的对象共享。</p>\n<p>注意：</p>\n<ul>\n<li><strong>静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。</strong></li>\n<li>静态成员变量必须在<strong>类中声明，在类外定义</strong>。</li>\n<li>静态数据成员不属于某个对象，在<strong>为对象分配空间中不包括静态成员所占空间</strong>。</li>\n<li>静态数据成员可以通过<strong>类名或者对象名来引用</strong>。</li>\n<li>静态成员也有<strong>访问权限</strong>，<strong>类外不能访问私有成员</strong></li>\n</ul>\n<p>静态成员变量的<strong>初始化</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//类的静态成员属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sNum;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sOther;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类外初始化，初始化时不加static</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Person::sNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Person::sOther = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>访问</strong>静态成员变量的<strong>两种方式</strong>。</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 通过类名直接访问</span></span><br><span class=\"line\">\tPerson::sNum = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. 通过对象访问</span></span><br><span class=\"line\">\tPerson p1, p2;</span><br><span class=\"line\">\tp1.sNum = <span class=\"number\">200</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"静态成员函数\"><a href=\"#静态成员函数\" class=\"headerlink\" title=\"静态成员函数\"></a>静态成员函数</h3><p>和静态变量一样，同样<strong>在对象没有创建前，即可通过类名调用</strong>。静态成员函数主要为了访问静态变量，但是，不能访问普通成员变量。</p>\n<p>静态成员函数的意义，不在于信息共享，数据沟通，而在于<strong>管理静态数据成员，完成对静态数据成员的封装</strong>。</p>\n<p>注意:</p>\n<ul>\n<li><strong>静态成员函数只能访问静态变量，不能访问普通成员变量</strong></li>\n<li>静态成员函数的使用和静态成员变量一样</li>\n<li>静态成员函数也有访问权限</li>\n<li>普通成员函数可访问静态成员变量、也可以访问非经常成员变量</li>\n</ul>\n<p>PS:今晚花了一个小时看完了剑谱大佬写的大学学习经历，特别是大二下加进实验室之后的学习之路，震惊了。买张床直接住里边，学到超神！</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-12\"><a href=\"#Holiday-Note-12\" class=\"headerlink\" title=\"Holiday Note_12\"></a>Holiday Note_12</h1><p><strong>对象的构造与析构</strong>这块的知识点有点多的，不难但细节特别多。<strong>构造函数</strong>，<strong>析构函数</strong>，<strong>拷贝函数</strong>，<strong>浅拷贝和深拷贝</strong>，<strong>new</strong>和<strong>delete</strong>运算符，<strong>explicit</strong>，<strong>静态成员</strong>。看完了剑谱大佬的大学学习经历：惊为天人，膜拜。</p>","more":"<hr>\n<h2 id=\"对象的构造和析构\"><a href=\"#对象的构造和析构\" class=\"headerlink\" title=\"对象的构造和析构\"></a>对象的构造和析构</h2><p><strong>对象的初始化和清理</strong>也是两个非常重要的安全问题，一个对象或者变量没有初始时，对其使用后果是未知，同样的使用完一个变量，没有及时清理，也会造成一定的安全问题。</p>\n<p>C++提供<strong>构造函数</strong>和<strong>析构函数</strong>，这两个函数将会被编译器<strong>自动调用</strong>，完成对象初始化和对象清理工作。系统会默认调用构造函数和析构函数，而且只会<strong>调用一次</strong>。如果我们没有提供构造和析构，系统会默认提供，<strong>空实现</strong>。</p>\n<h3 id=\"构造函数和析构函数\"><a href=\"#构造函数和析构函数\" class=\"headerlink\" title=\"构造函数和析构函数\"></a>构造函数和析构函数</h3><p>构造函数语法：</p>\n<ul>\n<li>构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数(即<strong>可以重载</strong>)。</li>\n<li>ClassName(){}</li>\n</ul>\n<p>析构函数语法：</p>\n<ul>\n<li>析构函数函数名是在类名前面加’ ~ ‘组成,没有返回值，不能有void,不能有参数，<strong>不能重载</strong>。</li>\n<li>~ClassName(){}</li>\n</ul>\n<h3 id=\"构造函数的分类及调用\"><a href=\"#构造函数的分类及调用\" class=\"headerlink\" title=\"构造函数的分类及调用\"></a>构造函数的分类及调用</h3><ul>\n<li>按参数类型：分为无参构造函数和有参构造函数</li>\n<li>按类型分类：普通构造函数和拷贝构造函数(复制构造函数)</li>\n</ul>\n<p><strong>注意拷贝构造函数参数类型(const Class&amp;)</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//拷贝构造函数(复制构造函数) 使用另一个对象初始化本对象</span></span><br><span class=\"line\">\tPerson(<span class=\"keyword\">const</span> Person&amp; person)&#123;\t\t</span><br><span class=\"line\">\t\tmAge = person.mAge;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mAge;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造函数的调用方法注意\"><a href=\"#构造函数的调用方法注意\" class=\"headerlink\" title=\"构造函数的调用方法注意\"></a>构造函数的调用方法注意</h3><ol>\n<li>无参构造写法和调用</li>\n</ol>\n<ul>\n<li>Person p1 ; 注意不能写 Person p1() ，因为编译器认为这个是函数声明</li>\n</ul>\n<ol start=\"2\">\n<li>有参构造写法和调用</li>\n</ol>\n<ul>\n<li><p>Person p2(10)  或者 Person p2 = Person(10)</p>\n</li>\n<li><p>Person(10) 匿名对象 ，执行当前行后就会释放即析构这个对象</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>拷贝构造函数</li>\n</ol>\n<ul>\n<li><p>Person( const Person &amp; p )</p>\n</li>\n<li><p>可以使用Perons p1( p2) 或者 Person p1 = Person(p2)</p>\n</li>\n<li><p>不能用拷贝构造函数初始化匿名对象</p>\n</li>\n<li><p>如果写成 Person (p1)  这种写法等价于 Person p1，写到右值可以做拷贝构造函数</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>Person P = 100 隐式类型转换（使用explicit关键字可以禁止使用隐式类型转换） 相当于调用 Person p = Person(100)</li>\n</ol>\n<h3 id=\"拷贝构造函数的调用时机\"><a href=\"#拷贝构造函数的调用时机\" class=\"headerlink\" title=\"拷贝构造函数的调用时机\"></a>拷贝构造函数的调用时机</h3><ol>\n<li><p>对象以值传递的方式传给函数参数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传递的参数是普通对象，函数参数也是普通对象，传递将会调用拷贝构造</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doBussiness</span><span class=\"params\">(Person p)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Person <span class=\"title\">p</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">\tdoBussiness(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数局部对象以值传递的方式从函数返回(vs debug模式下调用一次拷贝构造，qt不调用任何构造)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数返回局部对象</span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">MyBusiness</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Person <span class=\"title\">p</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test03</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//vs release、qt下没有调用拷贝构造函数</span></span><br><span class=\"line\">\t<span class=\"comment\">//vs debug下调用一次拷贝构造函数</span></span><br><span class=\"line\">\tPerson p = MyBusiness();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用一个对象初始化另一个对象</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p(<span class=\"number\">10</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">Person p1(<span class=\"name\">p</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"构造函数调用规则\"><a href=\"#构造函数调用规则\" class=\"headerlink\" title=\"构造函数调用规则\"></a>构造函数调用规则</h3><p>默认情况下，C++编译器至少为我们写的类增加3个函数</p>\n<ol>\n<li>默认构造函数(无参，函数体为空)</li>\n<li>默认析构函数(无参，函数体为空)</li>\n<li>默认拷贝构造函数，对类中<strong>非静态成员属性简单值拷贝</strong></li>\n</ol>\n<ul>\n<li>如果<strong>用户定义拷贝构造函数，C++不会再提供任何默认构造函数</strong></li>\n<li>如果<strong>用户定义了普通构造(非拷贝)，C++不在提供默认无参构造，但是会提供默认拷贝构造</strong></li>\n</ul>\n<h3 id=\"浅拷贝和深拷贝\"><a href=\"#浅拷贝和深拷贝\" class=\"headerlink\" title=\"浅拷贝和深拷贝\"></a>浅拷贝和深拷贝</h3><p>当<strong>类中有指针</strong>，并且指针指向<strong>动态分配的内存空间</strong>，析构函数做了动态<strong>内存释放</strong>的处理，会导致内存问题。(即内存重复释放导致程序出错)</p>\n<p>因为浅拷贝只是拷贝了内存的地址，而当被拷贝的类析构时完成释放内存后，拷贝的类析构时再次对该内存进行释放因而会产生错位。</p>\n<p>因此当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要<strong>自定义拷贝构造函数</strong>，自行给指针动态分配空间，深拷贝。</p>\n<h3 id=\"多个对象的构造和析构\"><a href=\"#多个对象的构造和析构\" class=\"headerlink\" title=\"多个对象的构造和析构\"></a>多个对象的构造和析构</h3><p>传统方式初始化，即进行有参构造</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person(int a,int <span class=\"keyword\">b,int </span>c)&#123;</span><br><span class=\"line\">\tmA = a<span class=\"comment\">;</span></span><br><span class=\"line\">\tmB = <span class=\"keyword\">b;</span></span><br><span class=\"line\"><span class=\"keyword\">\t</span>mC = c<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>初始化列表</strong>方式初始化方法。(:)</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">Person</span>(int a, int b, int c)<span class=\"selector-pseudo\">:mA(a)</span>,<span class=\"selector-tag\">mB</span>(b),<span class=\"selector-tag\">mC</span>(c)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：在<strong>类对象作为成员的情况下</strong>：当调用构造函数时，首先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体。也就是说，<strong>先调用对象成员的构造函数</strong>，<strong>再调用本身的构造函数</strong>。<strong>析构函数和构造函数调用顺序相反</strong>，先构造，后析构</p>\n</blockquote>\n<h3 id=\"explicit关键字\"><a href=\"#explicit关键字\" class=\"headerlink\" title=\"explicit关键字\"></a>explicit关键字</h3><p>声明为explicit的构造函数不能在隐式转换中使用，防止构造时寓意不明。</p>\n<hr>\n<h2 id=\"动态分配内存\"><a href=\"#动态分配内存\" class=\"headerlink\" title=\"动态分配内存\"></a>动态分配内存</h2><p>使用C的动态内存分配函数在堆上创建类的问题(麻烦)</p>\n<ul>\n<li>程序员必须确定对象的长度。</li>\n<li>malloc返回一个万能指针，c++不允许将万能赋值给其他任何指针，必须强转。</li>\n<li>malloc可能申请内存失败，所以必须判断返回值来确保内存分配成功。</li>\n<li>用户在使用对象之前必须记住对他初始化，构造函数不能显示调用初始化(构造函数是由编译器调用)，用户有可能忘记调用初始化函数。</li>\n</ul>\n<blockquote>\n<p>C的动态内存分配函数太复杂，容易令人混淆，是不可接受的。</p>\n</blockquote>\n<h3 id=\"new-运算符-operator\"><a href=\"#new-运算符-operator\" class=\"headerlink\" title=\"new 运算符(operator)\"></a>new 运算符(operator)</h3><p>当用new创建一个对象时，它就<strong>在堆里为对象分配内存</strong>并<strong>调用构造函数完成初始化</strong>。</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Person</span>* <span class=\"keyword\">person</span> = new <span class=\"keyword\">Person</span>;</span><br></pre></td></tr></table></figure>\n\n<p>相当于:为对象分配内存</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person* person = (Person*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Person));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(person == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及对象初始化</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">person</span>-&gt;</span>Init();</span><br></pre></td></tr></table></figure>\n\n<p>new操作符能确定在调用构造函数初始化之前内存分配是成功的，所有不用显式确定调用是否成功。</p>\n<h3 id=\"delete-运算符-operator\"><a href=\"#delete-运算符-operator\" class=\"headerlink\" title=\"delete 运算符(operator)\"></a>delete 运算符(operator)</h3><p>delete表达式<strong>先调用析构函数</strong>，然后<strong>释放内存</strong>。正如new表达式返回一个指向对象的指针一样，delete需要一个对象的<strong>地址</strong>。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li><strong>new的对象用万能指针去接收会导致无法释放对象</strong></li>\n<li>使用new和delete在堆上创建数组时，<strong>delete的格式[]</strong>！！！<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建字符数组</span></span><br><span class=\"line\">char* pStr = new char[<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"comment\">//创建整型数组</span></span><br><span class=\"line\">int* pArr1 = new int[<span class=\"number\">100</span>]; </span><br><span class=\"line\"><span class=\"comment\">//创建整型数组并初始化</span></span><br><span class=\"line\">int* pArr2 = new int[<span class=\"number\">10</span>]&#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//释放数组内存</span></span><br><span class=\"line\">delete[] pStr;</span><br><span class=\"line\">delete[] pArr1;</span><br><span class=\"line\">delete[] pArr2;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<h2 id=\"静态成员\"><a href=\"#静态成员\" class=\"headerlink\" title=\"静态成员\"></a>静态成员</h2><h3 id=\"静态成员变量\"><a href=\"#静态成员变量\" class=\"headerlink\" title=\"静态成员变量\"></a>静态成员变量</h3><p>在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。</p>\n<p>不管这个类创建了多少个对象，静态成员<strong>只有一个拷贝</strong>，这个拷贝被所有属于这个类的对象共享。</p>\n<p>注意：</p>\n<ul>\n<li><strong>静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。</strong></li>\n<li>静态成员变量必须在<strong>类中声明，在类外定义</strong>。</li>\n<li>静态数据成员不属于某个对象，在<strong>为对象分配空间中不包括静态成员所占空间</strong>。</li>\n<li>静态数据成员可以通过<strong>类名或者对象名来引用</strong>。</li>\n<li>静态成员也有<strong>访问权限</strong>，<strong>类外不能访问私有成员</strong></li>\n</ul>\n<p>静态成员变量的<strong>初始化</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//类的静态成员属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sNum;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sOther;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类外初始化，初始化时不加static</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Person::sNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Person::sOther = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>访问</strong>静态成员变量的<strong>两种方式</strong>。</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 通过类名直接访问</span></span><br><span class=\"line\">\tPerson::sNum = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. 通过对象访问</span></span><br><span class=\"line\">\tPerson p1, p2;</span><br><span class=\"line\">\tp1.sNum = <span class=\"number\">200</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"静态成员函数\"><a href=\"#静态成员函数\" class=\"headerlink\" title=\"静态成员函数\"></a>静态成员函数</h3><p>和静态变量一样，同样<strong>在对象没有创建前，即可通过类名调用</strong>。静态成员函数主要为了访问静态变量，但是，不能访问普通成员变量。</p>\n<p>静态成员函数的意义，不在于信息共享，数据沟通，而在于<strong>管理静态数据成员，完成对静态数据成员的封装</strong>。</p>\n<p>注意:</p>\n<ul>\n<li><strong>静态成员函数只能访问静态变量，不能访问普通成员变量</strong></li>\n<li>静态成员函数的使用和静态成员变量一样</li>\n<li>静态成员函数也有访问权限</li>\n<li>普通成员函数可访问静态成员变量、也可以访问非经常成员变量</li>\n</ul>\n<p>PS:今晚花了一个小时看完了剑谱大佬写的大学学习经历，特别是大二下加进实验室之后的学习之路，震惊了。买张床直接住里边，学到超神！</p>"},{"title":"Holiday Note_13","date":"2019-07-25T13:17:40.000Z","_content":"\n# Holiday Note_13\n\n稍微接触了以下**单例(Singleton)模式**的思想，主要学习的是**类中成员函数和成员变量的关系**，**常函数和常对象**，**this指针**，**友元**。**单例模式**作为一种常见的软件设计模式，实现起来并不是很好理解，核心是通过**静态成员**实现系统中**一个类只有一个实例**而且该实例易于外界访问来达到节约系统资源的目的。\n\n> 《Thinking in C++》：如果一个类被声明为friend,意味着它不是这个类的成员函数，却可以修改这个类的私有成员，而且必须列在类的定义中，因此他是一个特权函数。C++不是完全的面向对象语言，而只是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟C++设计的目的是为了实用性，而不是追求理想的抽象。\n \n<!-- more -->\n\n---\n\n## 单例模式\n\n[![singletonpatternd5aaa.md.jpg](https://miao.su/images/2019/07/25/singletonpatternd5aaa.md.jpg)](https://miao.su/image/Tm6w3)\n\n单例模式的核心结构中只包含一个被称为单例的特殊类。**通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源**。\n\nSingleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；**为了防止在外部对其实例化，将其默认构造函数和拷贝构造函数设计为私有**；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。\n\n要点为：\n-\t将 **默认构造**  和 **拷贝构造** **私有化**\n-\t内部维护一个 **对象指针**\n-\t**私有化唯一指针**\n-\t对外提供 getInstance方法来访问这个指针\n-\t保证类中只能实例化唯一一个对象\n\n打印机\n~~~\nclass Printer{\n\npublic:\n\tstatic Printer* getInstance() { \n\t\treturn pPrinter;\n\t}\n\t\nprivate:\n\n\tPrinter(){}\n\tPrinter(const Printer&){}\n\n\tstatic Printer* pPrinter;\n\tint mTimes;\n};\n\nPrinter* Printer::pPrinter = new Printer;\n\nvoid test(){\n\n\tPrinter* printer = Printer::getInstance();\n\n}\n\n~~~\n\n---\n\n## 类中成员函数和变量的关系\n**C++类对象中的变量和函数是分开存储。**\n\n- \t每一个非内联成员函数只会诞生一份函数实例\n-\t成员变量和成员函数是分开存储的\n-\t空类的大小 1\n-\t只有**非静态数据成员**直接内含在类对象中\n\n\n\n---\n## this指针\n\nC++通过提供特殊的对象指针: this指针，解决多个同类型的对象共用一块代码(**每一个非内联函数仅会生成一份函数实例**)导致难以**区分是哪一个对象调用**的问题。\n\t\n**this指针永远指向当前对象**，是一种隐含指针，隐含于每个类的**非静态成员函数中**。This指针**无需定义**，直接使用即可。\n\n> 静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。\n\n两种使用场景：\n-\t当**形参和成员变量同名**时，可用this指针来区分\n-\t在类的非静态成员函数中**返回对象本身**，可使用👇\n~~~ \nreturn *this;（链式编程)\n//p1.m_A = p2.Add(p3).Add(p4).Add(p5);\n~~~\n\n\n---\n## 常函数和常对象\n\n### 常函数\n\n-\t用const修饰的成员函数时，const修饰this指针指向的内存区域，成员函数体内**不可以修改本类中的任何普通成员变量**，\n- 当成员变量类型符前用**mutable**修饰时例外。\n\n注意const写在函数的括号后的位置\n~~~\npublic:\n\tvoid sonmeOperate() const {\n\t\t//this->mAge = 200; //mAge不可修改\n\t\tthis->mID = 10;\n\t}\n\t\nprivate:\n\tint mAge;\n\tmutable int mID;\n};\n\n~~~\n\n### 常对象\n\n-\t常对象**只能调用const的成员函数**\n-\t常对象**可访问** const 或非 const 数据成员，**不能修改**，除非成员用**mutable**修饰\n\n创建方法\n~~~\nconst Person person;\n~~~\n\n---\n\n## 友元\n友元函数是一种特权函数，C++**允许**这个特权函数**访问私有成员**。\n\n- \t友元函数可访问对象任意成员属性，包括私有属性\n-\tfriend关键字只出现在声明处\n-\t其他类、类成员函数、全局函数都可声明为友元\n-\t友元函数不是类的成员，不带this指针\n\n语法很简单，定义友元类，友元函数都只需要在类中进行声明且声明前加friend关键字即可。\n\n注意：\n1. 友元关系**不能被继承**。\n2. 友元关系是**单向**的，类A是类B的朋友，但类B不一定是类A的朋友。\n3. 友元关系**不具有传递性**。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。\n\nPS: 买了盒速冻馄饨，就是个mini水饺啊🙃","source":"_posts/2019-Holiday-Note-13.md","raw":"---\ntitle: Holiday Note_13\ndate: 2019-07-25 21:17:40\ncategories: C++\ntags: [Note,C++]\n---\n\n# Holiday Note_13\n\n稍微接触了以下**单例(Singleton)模式**的思想，主要学习的是**类中成员函数和成员变量的关系**，**常函数和常对象**，**this指针**，**友元**。**单例模式**作为一种常见的软件设计模式，实现起来并不是很好理解，核心是通过**静态成员**实现系统中**一个类只有一个实例**而且该实例易于外界访问来达到节约系统资源的目的。\n\n> 《Thinking in C++》：如果一个类被声明为friend,意味着它不是这个类的成员函数，却可以修改这个类的私有成员，而且必须列在类的定义中，因此他是一个特权函数。C++不是完全的面向对象语言，而只是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟C++设计的目的是为了实用性，而不是追求理想的抽象。\n \n<!-- more -->\n\n---\n\n## 单例模式\n\n[![singletonpatternd5aaa.md.jpg](https://miao.su/images/2019/07/25/singletonpatternd5aaa.md.jpg)](https://miao.su/image/Tm6w3)\n\n单例模式的核心结构中只包含一个被称为单例的特殊类。**通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源**。\n\nSingleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；**为了防止在外部对其实例化，将其默认构造函数和拷贝构造函数设计为私有**；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。\n\n要点为：\n-\t将 **默认构造**  和 **拷贝构造** **私有化**\n-\t内部维护一个 **对象指针**\n-\t**私有化唯一指针**\n-\t对外提供 getInstance方法来访问这个指针\n-\t保证类中只能实例化唯一一个对象\n\n打印机\n~~~\nclass Printer{\n\npublic:\n\tstatic Printer* getInstance() { \n\t\treturn pPrinter;\n\t}\n\t\nprivate:\n\n\tPrinter(){}\n\tPrinter(const Printer&){}\n\n\tstatic Printer* pPrinter;\n\tint mTimes;\n};\n\nPrinter* Printer::pPrinter = new Printer;\n\nvoid test(){\n\n\tPrinter* printer = Printer::getInstance();\n\n}\n\n~~~\n\n---\n\n## 类中成员函数和变量的关系\n**C++类对象中的变量和函数是分开存储。**\n\n- \t每一个非内联成员函数只会诞生一份函数实例\n-\t成员变量和成员函数是分开存储的\n-\t空类的大小 1\n-\t只有**非静态数据成员**直接内含在类对象中\n\n\n\n---\n## this指针\n\nC++通过提供特殊的对象指针: this指针，解决多个同类型的对象共用一块代码(**每一个非内联函数仅会生成一份函数实例**)导致难以**区分是哪一个对象调用**的问题。\n\t\n**this指针永远指向当前对象**，是一种隐含指针，隐含于每个类的**非静态成员函数中**。This指针**无需定义**，直接使用即可。\n\n> 静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。\n\n两种使用场景：\n-\t当**形参和成员变量同名**时，可用this指针来区分\n-\t在类的非静态成员函数中**返回对象本身**，可使用👇\n~~~ \nreturn *this;（链式编程)\n//p1.m_A = p2.Add(p3).Add(p4).Add(p5);\n~~~\n\n\n---\n## 常函数和常对象\n\n### 常函数\n\n-\t用const修饰的成员函数时，const修饰this指针指向的内存区域，成员函数体内**不可以修改本类中的任何普通成员变量**，\n- 当成员变量类型符前用**mutable**修饰时例外。\n\n注意const写在函数的括号后的位置\n~~~\npublic:\n\tvoid sonmeOperate() const {\n\t\t//this->mAge = 200; //mAge不可修改\n\t\tthis->mID = 10;\n\t}\n\t\nprivate:\n\tint mAge;\n\tmutable int mID;\n};\n\n~~~\n\n### 常对象\n\n-\t常对象**只能调用const的成员函数**\n-\t常对象**可访问** const 或非 const 数据成员，**不能修改**，除非成员用**mutable**修饰\n\n创建方法\n~~~\nconst Person person;\n~~~\n\n---\n\n## 友元\n友元函数是一种特权函数，C++**允许**这个特权函数**访问私有成员**。\n\n- \t友元函数可访问对象任意成员属性，包括私有属性\n-\tfriend关键字只出现在声明处\n-\t其他类、类成员函数、全局函数都可声明为友元\n-\t友元函数不是类的成员，不带this指针\n\n语法很简单，定义友元类，友元函数都只需要在类中进行声明且声明前加friend关键字即可。\n\n注意：\n1. 友元关系**不能被继承**。\n2. 友元关系是**单向**的，类A是类B的朋友，但类B不一定是类A的朋友。\n3. 友元关系**不具有传递性**。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。\n\nPS: 买了盒速冻馄饨，就是个mini水饺啊🙃","slug":"2019-Holiday-Note-13","published":1,"updated":"2019-07-25T15:06:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbiho0011smjbs01d1lxc","content":"<h1 id=\"Holiday-Note-13\"><a href=\"#Holiday-Note-13\" class=\"headerlink\" title=\"Holiday Note_13\"></a>Holiday Note_13</h1><p>稍微接触了以下<strong>单例(Singleton)模式</strong>的思想，主要学习的是<strong>类中成员函数和成员变量的关系</strong>，<strong>常函数和常对象</strong>，<strong>this指针</strong>，<strong>友元</strong>。<strong>单例模式</strong>作为一种常见的软件设计模式，实现起来并不是很好理解，核心是通过<strong>静态成员</strong>实现系统中<strong>一个类只有一个实例</strong>而且该实例易于外界访问来达到节约系统资源的目的。</p>\n<blockquote>\n<p>《Thinking in C++》：如果一个类被声明为friend,意味着它不是这个类的成员函数，却可以修改这个类的私有成员，而且必须列在类的定义中，因此他是一个特权函数。C++不是完全的面向对象语言，而只是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟C++设计的目的是为了实用性，而不是追求理想的抽象。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><p><a href=\"https://miao.su/image/Tm6w3\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/25/singletonpatternd5aaa.md.jpg\" alt=\"singletonpatternd5aaa.md.jpg\"></a></p>\n<p>单例模式的核心结构中只包含一个被称为单例的特殊类。<strong>通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源</strong>。</p>\n<p>Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；<strong>为了防止在外部对其实例化，将其默认构造函数和拷贝构造函数设计为私有</strong>；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。</p>\n<p>要点为：</p>\n<ul>\n<li>将 <strong>默认构造</strong>  和 <strong>拷贝构造</strong> <strong>私有化</strong></li>\n<li>内部维护一个 <strong>对象指针</strong></li>\n<li><strong>私有化唯一指针</strong></li>\n<li>对外提供 getInstance方法来访问这个指针</li>\n<li>保证类中只能实例化唯一一个对象</li>\n</ul>\n<p>打印机</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Printer</span>&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> Printer* <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> pPrinter;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tPrinter()&#123;&#125;</span><br><span class=\"line\">\tPrinter(<span class=\"keyword\">const</span> Printer&amp;)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> Printer* pPrinter;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mTimes;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Printer* Printer::pPrinter = <span class=\"keyword\">new</span> Printer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPrinter* printer = Printer::getInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"类中成员函数和变量的关系\"><a href=\"#类中成员函数和变量的关系\" class=\"headerlink\" title=\"类中成员函数和变量的关系\"></a>类中成员函数和变量的关系</h2><p><strong>C++类对象中的变量和函数是分开存储。</strong></p>\n<ul>\n<li>每一个非内联成员函数只会诞生一份函数实例</li>\n<li>成员变量和成员函数是分开存储的</li>\n<li>空类的大小 1</li>\n<li>只有<strong>非静态数据成员</strong>直接内含在类对象中</li>\n</ul>\n<hr>\n<h2 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><p>C++通过提供特殊的对象指针: this指针，解决多个同类型的对象共用一块代码(<strong>每一个非内联函数仅会生成一份函数实例</strong>)导致难以<strong>区分是哪一个对象调用</strong>的问题。</p>\n<p><strong>this指针永远指向当前对象</strong>，是一种隐含指针，隐含于每个类的<strong>非静态成员函数中</strong>。This指针<strong>无需定义</strong>，直接使用即可。</p>\n<blockquote>\n<p>静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。</p>\n</blockquote>\n<p>两种使用场景：</p>\n<ul>\n<li>当<strong>形参和成员变量同名</strong>时，可用this指针来区分</li>\n<li>在类的非静态成员函数中<strong>返回对象本身</strong>，可使用👇<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;（链式编程)</span><br><span class=\"line\"><span class=\"comment\">//p1.m_A = p2.Add(p3).Add(p4).Add(p5);</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<hr>\n<h2 id=\"常函数和常对象\"><a href=\"#常函数和常对象\" class=\"headerlink\" title=\"常函数和常对象\"></a>常函数和常对象</h2><h3 id=\"常函数\"><a href=\"#常函数\" class=\"headerlink\" title=\"常函数\"></a>常函数</h3><ul>\n<li>用const修饰的成员函数时，const修饰this指针指向的内存区域，成员函数体内<strong>不可以修改本类中的任何普通成员变量</strong>，</li>\n<li>当成员变量类型符前用<strong>mutable</strong>修饰时例外。</li>\n</ul>\n<p>注意const写在函数的括号后的位置</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sonmeOperate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//this-&gt;mAge = 200; //mAge不可修改</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;mID = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mAge;</span><br><span class=\"line\">\t<span class=\"keyword\">mutable</span> <span class=\"keyword\">int</span> mID;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常对象\"><a href=\"#常对象\" class=\"headerlink\" title=\"常对象\"></a>常对象</h3><ul>\n<li>常对象<strong>只能调用const的成员函数</strong></li>\n<li>常对象<strong>可访问</strong> const 或非 const 数据成员，<strong>不能修改</strong>，除非成员用<strong>mutable</strong>修饰</li>\n</ul>\n<p>创建方法</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"keyword\">Person</span> <span class=\"keyword\">person</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h2><p>友元函数是一种特权函数，C++<strong>允许</strong>这个特权函数<strong>访问私有成员</strong>。</p>\n<ul>\n<li>友元函数可访问对象任意成员属性，包括私有属性</li>\n<li>friend关键字只出现在声明处</li>\n<li>其他类、类成员函数、全局函数都可声明为友元</li>\n<li>友元函数不是类的成员，不带this指针</li>\n</ul>\n<p>语法很简单，定义友元类，友元函数都只需要在类中进行声明且声明前加friend关键字即可。</p>\n<p>注意：</p>\n<ol>\n<li>友元关系<strong>不能被继承</strong>。</li>\n<li>友元关系是<strong>单向</strong>的，类A是类B的朋友，但类B不一定是类A的朋友。</li>\n<li>友元关系<strong>不具有传递性</strong>。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。</li>\n</ol>\n<p>PS: 买了盒速冻馄饨，就是个mini水饺啊🙃</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-13\"><a href=\"#Holiday-Note-13\" class=\"headerlink\" title=\"Holiday Note_13\"></a>Holiday Note_13</h1><p>稍微接触了以下<strong>单例(Singleton)模式</strong>的思想，主要学习的是<strong>类中成员函数和成员变量的关系</strong>，<strong>常函数和常对象</strong>，<strong>this指针</strong>，<strong>友元</strong>。<strong>单例模式</strong>作为一种常见的软件设计模式，实现起来并不是很好理解，核心是通过<strong>静态成员</strong>实现系统中<strong>一个类只有一个实例</strong>而且该实例易于外界访问来达到节约系统资源的目的。</p>\n<blockquote>\n<p>《Thinking in C++》：如果一个类被声明为friend,意味着它不是这个类的成员函数，却可以修改这个类的私有成员，而且必须列在类的定义中，因此他是一个特权函数。C++不是完全的面向对象语言，而只是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟C++设计的目的是为了实用性，而不是追求理想的抽象。</p>\n</blockquote>","more":"<hr>\n<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><p><a href=\"https://miao.su/image/Tm6w3\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/25/singletonpatternd5aaa.md.jpg\" alt=\"singletonpatternd5aaa.md.jpg\"></a></p>\n<p>单例模式的核心结构中只包含一个被称为单例的特殊类。<strong>通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源</strong>。</p>\n<p>Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；<strong>为了防止在外部对其实例化，将其默认构造函数和拷贝构造函数设计为私有</strong>；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。</p>\n<p>要点为：</p>\n<ul>\n<li>将 <strong>默认构造</strong>  和 <strong>拷贝构造</strong> <strong>私有化</strong></li>\n<li>内部维护一个 <strong>对象指针</strong></li>\n<li><strong>私有化唯一指针</strong></li>\n<li>对外提供 getInstance方法来访问这个指针</li>\n<li>保证类中只能实例化唯一一个对象</li>\n</ul>\n<p>打印机</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Printer</span>&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> Printer* <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> pPrinter;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tPrinter()&#123;&#125;</span><br><span class=\"line\">\tPrinter(<span class=\"keyword\">const</span> Printer&amp;)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> Printer* pPrinter;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mTimes;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Printer* Printer::pPrinter = <span class=\"keyword\">new</span> Printer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPrinter* printer = Printer::getInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"类中成员函数和变量的关系\"><a href=\"#类中成员函数和变量的关系\" class=\"headerlink\" title=\"类中成员函数和变量的关系\"></a>类中成员函数和变量的关系</h2><p><strong>C++类对象中的变量和函数是分开存储。</strong></p>\n<ul>\n<li>每一个非内联成员函数只会诞生一份函数实例</li>\n<li>成员变量和成员函数是分开存储的</li>\n<li>空类的大小 1</li>\n<li>只有<strong>非静态数据成员</strong>直接内含在类对象中</li>\n</ul>\n<hr>\n<h2 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><p>C++通过提供特殊的对象指针: this指针，解决多个同类型的对象共用一块代码(<strong>每一个非内联函数仅会生成一份函数实例</strong>)导致难以<strong>区分是哪一个对象调用</strong>的问题。</p>\n<p><strong>this指针永远指向当前对象</strong>，是一种隐含指针，隐含于每个类的<strong>非静态成员函数中</strong>。This指针<strong>无需定义</strong>，直接使用即可。</p>\n<blockquote>\n<p>静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。</p>\n</blockquote>\n<p>两种使用场景：</p>\n<ul>\n<li>当<strong>形参和成员变量同名</strong>时，可用this指针来区分</li>\n<li>在类的非静态成员函数中<strong>返回对象本身</strong>，可使用👇<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;（链式编程)</span><br><span class=\"line\"><span class=\"comment\">//p1.m_A = p2.Add(p3).Add(p4).Add(p5);</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<hr>\n<h2 id=\"常函数和常对象\"><a href=\"#常函数和常对象\" class=\"headerlink\" title=\"常函数和常对象\"></a>常函数和常对象</h2><h3 id=\"常函数\"><a href=\"#常函数\" class=\"headerlink\" title=\"常函数\"></a>常函数</h3><ul>\n<li>用const修饰的成员函数时，const修饰this指针指向的内存区域，成员函数体内<strong>不可以修改本类中的任何普通成员变量</strong>，</li>\n<li>当成员变量类型符前用<strong>mutable</strong>修饰时例外。</li>\n</ul>\n<p>注意const写在函数的括号后的位置</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sonmeOperate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//this-&gt;mAge = 200; //mAge不可修改</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;mID = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mAge;</span><br><span class=\"line\">\t<span class=\"keyword\">mutable</span> <span class=\"keyword\">int</span> mID;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常对象\"><a href=\"#常对象\" class=\"headerlink\" title=\"常对象\"></a>常对象</h3><ul>\n<li>常对象<strong>只能调用const的成员函数</strong></li>\n<li>常对象<strong>可访问</strong> const 或非 const 数据成员，<strong>不能修改</strong>，除非成员用<strong>mutable</strong>修饰</li>\n</ul>\n<p>创建方法</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"keyword\">Person</span> <span class=\"keyword\">person</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h2><p>友元函数是一种特权函数，C++<strong>允许</strong>这个特权函数<strong>访问私有成员</strong>。</p>\n<ul>\n<li>友元函数可访问对象任意成员属性，包括私有属性</li>\n<li>friend关键字只出现在声明处</li>\n<li>其他类、类成员函数、全局函数都可声明为友元</li>\n<li>友元函数不是类的成员，不带this指针</li>\n</ul>\n<p>语法很简单，定义友元类，友元函数都只需要在类中进行声明且声明前加friend关键字即可。</p>\n<p>注意：</p>\n<ol>\n<li>友元关系<strong>不能被继承</strong>。</li>\n<li>友元关系是<strong>单向</strong>的，类A是类B的朋友，但类B不一定是类A的朋友。</li>\n<li>友元关系<strong>不具有传递性</strong>。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。</li>\n</ol>\n<p>PS: 买了盒速冻馄饨，就是个mini水饺啊🙃</p>"},{"title":"Holiday Note_14","date":"2019-07-26T13:18:57.000Z","_content":"# Holiday Note_14\n\n学习了C++中两个重要的知识点：**运算符重载**以及**继承**。其中运算符的重载特性真的是非常的灵活，C++中几乎所有的运算符都可以被赋予新的功能。它的本质还是**函数调用**，使用得当可以让涉及类的代码更加的**易于读写**；简单继承派生还是挺好理解的，就是一个父与子的关系。不过**多继承**，**菱形继承**还有**虚继承**的实现原理这块不太好理解，明天再对这一块深入学习。\n\n<!-- more -->\n\n---\n\n## 运算符重载(operator overloading)\n\n[![operator09faf.md.png](https://miao.su/images/2019/07/26/operator09faf.md.png)](https://miao.su/image/T2Xk6)\n\n先总结一下要注意的点：\n-\t=, [], () 和 -> 操作符只能通过成员函数进行重载 \n-\t<< 和 >>只能通过全局函数配合友元函数进行重载 \n-\t不要重载 && 和 || 操作符，因为无法实现短路规则\n\n\n运算符重载，就是**对已有的运算符重新进行定义**，赋予其另一种功能，以**适应不同的数据类型**。\n\n由于C++有类的概念，因此在使用普通运算符对类进行操作时，会由于识别不了而无法达到像操作简单数据类型一样操作类了，引入运算符重载将运算符赋予对某一个类进行特定的操作达到代码的易于读写的目的。\n\n---\n\n### 介绍案例\n有这样一个类\n~~~\nclass Person{\npublic:\n\n\tPerson(int age, string name){\n\t\tm_Age = age;\n\t\tm_Name = name;\n\t}\t\n\n\tint m_Age;\n\tstring m_Name;\n}\n~~~\n实例两个对象\n~~~\nPerson p1(7, \"小明\");\nPerson p2(9, \"小红\");\n~~~\n假设在没有进行运算符重载时，判断两个类的成员是否相同要对类的单个成员进行比对判断。\n~~~\nif(p1.m_Age == p2.m_Age && p1.m_Name == p2.m_Name){\n\tcout << \"相同\" << endl;\n}\nelse cout << \"不同\" << end;;\n~~~\n若是使用操作符重载，将逻辑运算符==进行重载\n~~~\nif(p1 == p2){\n\tcout << \"相同\" << endl;\n}\nelse cout << \"不同\" << end;;\n~~~\n可见，通过操作运算符重载，可以使得原本无法对类进行判断的==运算符拥有了我们自己需要的判断功能，这便是运算符重载带来了的便利。\n\n---\n\n### +\n对+进行重载演示写法\n\n类中包含成员函数方式实现运算符重载1\n~~~\nclass S {\n\npublic:\n\n\tS() {}\n\tS(int a, int b) : m_A(a), m_B(b) {}\n\n\tint m_A;\n\tint m_B;\n\t\n\t//重载函数\n\tS operator+(S& s) {\n\t\tS temp;\n\t\ttemp.m_A = this->m_A + s.m_A;\n\t\ttemp.m_B = this->m_B + s.m_B;\n\t\treturn temp;\n\t}\n\n};\n~~~\n全局函数方式实现运算符重载2，由于参数不同，可以让+有不同的功能\n~~~\n//重载函数\nS operator+(S& s1, int val) {\n\tS temp;\n\ttemp.m_A = s1.m_A + val;\n\ttemp.m_B = s1.m_B + val;\n\treturn temp;\n}\n~~~\n实现效果\n~~~\nvoid test() {\n\n\tS s1(1, 1);\n\tS s2(2, 2);\n\n\tS s3 = s1 + s2;\n\tS s4 = s1 + 10;\n\n\tcout << s3.m_A << endl;//3\n\tcout << s3.m_B << endl;//3\n\tcout << s4.m_A << endl;//11\n\tcout << s4.m_B << endl;//11\n\n}\n~~~\n\n---\n\n### <<\n对左移运算符重载**必须使用全局函数定义方式定义而不能使用成员函数方式定义**。\n\ncout的类型为ostream\n~~~\nclass Person {\n\n\tfriend ostream& operator<<(ostream& cout, Person& p);\n\npublic:\n\n\tPerson(int a, int b) {\n\t\tthis->m_A = a;\n\t\tthis->m_B = b;\n\t}\n\nprivate:\n\tint m_A;\n\tint m_B;\n\n};\n~~~\n返回ostream&目的是可以继续实现<<链式编程\n~~~\nostream& operator<<(ostream&cout, Person& p) {\n\tcout << \"m_A = \" << p.m_A << \" m_B = \" << p.m_B;\n\treturn cout;\n}\n\n~~~\n实现效果\n~~~\nvoid test() {\n\n\tPerson p1(7, 9);\n\n\tcout << p1 << endl;//m_A = 7 m_B = 9\n\n}\n~~~\n\n---\n\n### >>\n\n与重载<<类似，对>>进行重载也只能使用全局函数方式进行实现。\n\ncin的类型为istream\n\n类的定义\n~~~\nclass Test {\npublic:\n\tTest(const char* s) {\n\t\tthis->str = new char[strlen(s) + 1];\n\t\tstrcpy(str, s);\n\t}\n\n\tchar* str;\n};\n~~~\n判断需要录入数据的变量是否有数据，有要先进行释放置空操作。\n~~~\nistream& operator>>(istream& cin, Test& s) {\n\tif (s.str != NULL) {\n\t\tdelete s.str;\n\t\ts.str = NULL;\n\t}\n\n\tchar buf[1024];\n\tcin >> buf;\n\n\ts.str = new char[strlen(buf) + 1];\n\tstrcpy(s.str, buf);\n\treturn cin;\n}\n~~~\n实现效果\n~~~\nTest t1(\"AAA\");\ncout << t1.str << endl;\ncin >> t1;\ncout << t1.str << endl;\n~~~\n\n---\n\n### =\n必须使用成员函数方法实现**=**的重载\n~~~\nclass Person {\n\npublic:\n\tPerson(const char* name) {\n\t\tthis->pName = new char[strlen(name) + 1];\n\t\tstrcpy(pName, name);\n\t}\n\n\tPerson& operator=(const Person& p) {\n\n\t\tif (this->pName != NULL) {\n\t\t\tdelete[] this->pName;\n\t\t\tpName = NULL;\n\t\t}\n\n\t\tpName = new char[strlen(p.pName) + 1];\n\t\tstrcpy(pName, p.pName);\n\n\t\treturn *this;\n\n\t}\n\n\t~Person() {\n\t\tif (this->pName != NULL) {\n\t\t\tdelete[] this->pName;\n\t\t\tpName = NULL;\n\t\t}\n\t}\n\n\tchar* pName;\n\n};\n\n~~~\n实现效果\n~~~\nPerson p1(\"AAA\");\nPerson p2(\"BBB\");\nPerson p3(\"CCC\");\n\np3 = p2 = p1;\n~~~\n\n\n---\n\n### ==\n前面的示例即为**==**的重载，实现过程无非就是把原本要写的判断放到运算符重载函数中。\n\n注意的是：对关系运算符进行重载时，不要对**&&**，**||**进行重载！\n\n因为内置版本是具备**短路特性**的，而我们进行重载时是无法实现的。\n\n---\n\n### ++\n\n前置++效率更高，后置++由于返回的是临时变量，因此无法返回引用所以效率相对前置++效率会低。\n\n~~~\nclass MyInterger {\npublic:\n\tMyInterger() {\n\t\tm_A = 0;\n\t}\n\n\t//前置++返回引用，效率高\n\tMyInterger& operator++() {\n\t\tthis->m_A++;\n\t\treturn *this;\n\t}\n\n\t//后置++返回值，因为temp为临时变量，不能返回引用\n\tMyInterger operator++(int) {\n\t\tMyInterger temp = *this;\n\t\tthis->m_A++;\n\t\treturn temp;\n\t}\n\n\tint m_A;\n};\n~~~\n实现效果\n~~~\n++(++myInt);//myInt.m_A = 2\n~~~\n\n\n---\n\n### * 和 ->\n\n这是一个智能指针思想的例子。使用一个智能指针类来维护一个需要开辟空间的类。目的是防止new完后忘记delete。（new后，只有手动delete才会释放对象开辟的空间且进行析构函数调用）\n\n智能指针对象在栈上创建，生命周期结束一定会调用析构函数，因此保证维护的类空间能保证释放。\n\n被智能指针类维护的类\n~~~\npublic:\n\n\tPerson(int a) {\n\t\tthis->m_A = a;\n\t}\n\n\tvoid show() {\n\t\tcout << this->m_A << endl;\n\t}\n\n\t~Person() {}\n\n\tint m_A;\n};\n~~~\n\n智能指针类，通过对 * 和 -> 的重载，达到SmartPoint既能保证Person类new空间的释放，还能达到指针的特性。\n~~~\nclass SmartPoint {\n\npublic:\n\n\tSmartPoint(Person* person) {\n\t\tthis->person = person;\n\t}\n\n\tPerson* operator->() {\n\n\t\treturn this->person;\n\n\t}\n\n\tPerson& operator*() {\n\n\t\treturn *this->person;\n\n\t}\n\n\t~SmartPoint() {\n\t\tif (this->person != NULL) {\n\t\t\tdelete(person);\n\t\t\tperson = NULL;\n\t\t}\n\t}\n\nprivate:\n\tPerson* person;\n\n};\n~~~\n实现效果\n~~~\nSmartPoint sp = SmartPoint(new Person(10));\n\nsp->show();//sp->->show();\n\n(*sp).show();\n~~~\n\n---\n\n### ()\n\n**仿函数**\n\n对函数调用运算符重载，只是简单的接触了用法，可以让对象像一个函数调用。\n\n简单案例\n~~~\nclass Add {\n\npublic:\n\tAdd() {\n\n\t}\n\n\tAdd(int a) {\n\t\tthis->m_A = a;\n\t}\n\n\tint operator()(int a, int b) {\n\t\treturn a + b;\n\t}\n\nprivate:\n\tint m_A;\n};\n\n~~~\n实现效果\n~~~\nAdd add1;\ncout << add1(1, 1) << endl;//2\n~~~\n\n\nPS:轮子哥写的文章是有味道的😂","source":"_posts/2019-Holiday-Note-14.md","raw":"---\ntitle: Holiday Note_14\ndate: 2019-07-26 21:18:57\ncategories: C++\ntags: [Note,C++]\n---\n# Holiday Note_14\n\n学习了C++中两个重要的知识点：**运算符重载**以及**继承**。其中运算符的重载特性真的是非常的灵活，C++中几乎所有的运算符都可以被赋予新的功能。它的本质还是**函数调用**，使用得当可以让涉及类的代码更加的**易于读写**；简单继承派生还是挺好理解的，就是一个父与子的关系。不过**多继承**，**菱形继承**还有**虚继承**的实现原理这块不太好理解，明天再对这一块深入学习。\n\n<!-- more -->\n\n---\n\n## 运算符重载(operator overloading)\n\n[![operator09faf.md.png](https://miao.su/images/2019/07/26/operator09faf.md.png)](https://miao.su/image/T2Xk6)\n\n先总结一下要注意的点：\n-\t=, [], () 和 -> 操作符只能通过成员函数进行重载 \n-\t<< 和 >>只能通过全局函数配合友元函数进行重载 \n-\t不要重载 && 和 || 操作符，因为无法实现短路规则\n\n\n运算符重载，就是**对已有的运算符重新进行定义**，赋予其另一种功能，以**适应不同的数据类型**。\n\n由于C++有类的概念，因此在使用普通运算符对类进行操作时，会由于识别不了而无法达到像操作简单数据类型一样操作类了，引入运算符重载将运算符赋予对某一个类进行特定的操作达到代码的易于读写的目的。\n\n---\n\n### 介绍案例\n有这样一个类\n~~~\nclass Person{\npublic:\n\n\tPerson(int age, string name){\n\t\tm_Age = age;\n\t\tm_Name = name;\n\t}\t\n\n\tint m_Age;\n\tstring m_Name;\n}\n~~~\n实例两个对象\n~~~\nPerson p1(7, \"小明\");\nPerson p2(9, \"小红\");\n~~~\n假设在没有进行运算符重载时，判断两个类的成员是否相同要对类的单个成员进行比对判断。\n~~~\nif(p1.m_Age == p2.m_Age && p1.m_Name == p2.m_Name){\n\tcout << \"相同\" << endl;\n}\nelse cout << \"不同\" << end;;\n~~~\n若是使用操作符重载，将逻辑运算符==进行重载\n~~~\nif(p1 == p2){\n\tcout << \"相同\" << endl;\n}\nelse cout << \"不同\" << end;;\n~~~\n可见，通过操作运算符重载，可以使得原本无法对类进行判断的==运算符拥有了我们自己需要的判断功能，这便是运算符重载带来了的便利。\n\n---\n\n### +\n对+进行重载演示写法\n\n类中包含成员函数方式实现运算符重载1\n~~~\nclass S {\n\npublic:\n\n\tS() {}\n\tS(int a, int b) : m_A(a), m_B(b) {}\n\n\tint m_A;\n\tint m_B;\n\t\n\t//重载函数\n\tS operator+(S& s) {\n\t\tS temp;\n\t\ttemp.m_A = this->m_A + s.m_A;\n\t\ttemp.m_B = this->m_B + s.m_B;\n\t\treturn temp;\n\t}\n\n};\n~~~\n全局函数方式实现运算符重载2，由于参数不同，可以让+有不同的功能\n~~~\n//重载函数\nS operator+(S& s1, int val) {\n\tS temp;\n\ttemp.m_A = s1.m_A + val;\n\ttemp.m_B = s1.m_B + val;\n\treturn temp;\n}\n~~~\n实现效果\n~~~\nvoid test() {\n\n\tS s1(1, 1);\n\tS s2(2, 2);\n\n\tS s3 = s1 + s2;\n\tS s4 = s1 + 10;\n\n\tcout << s3.m_A << endl;//3\n\tcout << s3.m_B << endl;//3\n\tcout << s4.m_A << endl;//11\n\tcout << s4.m_B << endl;//11\n\n}\n~~~\n\n---\n\n### <<\n对左移运算符重载**必须使用全局函数定义方式定义而不能使用成员函数方式定义**。\n\ncout的类型为ostream\n~~~\nclass Person {\n\n\tfriend ostream& operator<<(ostream& cout, Person& p);\n\npublic:\n\n\tPerson(int a, int b) {\n\t\tthis->m_A = a;\n\t\tthis->m_B = b;\n\t}\n\nprivate:\n\tint m_A;\n\tint m_B;\n\n};\n~~~\n返回ostream&目的是可以继续实现<<链式编程\n~~~\nostream& operator<<(ostream&cout, Person& p) {\n\tcout << \"m_A = \" << p.m_A << \" m_B = \" << p.m_B;\n\treturn cout;\n}\n\n~~~\n实现效果\n~~~\nvoid test() {\n\n\tPerson p1(7, 9);\n\n\tcout << p1 << endl;//m_A = 7 m_B = 9\n\n}\n~~~\n\n---\n\n### >>\n\n与重载<<类似，对>>进行重载也只能使用全局函数方式进行实现。\n\ncin的类型为istream\n\n类的定义\n~~~\nclass Test {\npublic:\n\tTest(const char* s) {\n\t\tthis->str = new char[strlen(s) + 1];\n\t\tstrcpy(str, s);\n\t}\n\n\tchar* str;\n};\n~~~\n判断需要录入数据的变量是否有数据，有要先进行释放置空操作。\n~~~\nistream& operator>>(istream& cin, Test& s) {\n\tif (s.str != NULL) {\n\t\tdelete s.str;\n\t\ts.str = NULL;\n\t}\n\n\tchar buf[1024];\n\tcin >> buf;\n\n\ts.str = new char[strlen(buf) + 1];\n\tstrcpy(s.str, buf);\n\treturn cin;\n}\n~~~\n实现效果\n~~~\nTest t1(\"AAA\");\ncout << t1.str << endl;\ncin >> t1;\ncout << t1.str << endl;\n~~~\n\n---\n\n### =\n必须使用成员函数方法实现**=**的重载\n~~~\nclass Person {\n\npublic:\n\tPerson(const char* name) {\n\t\tthis->pName = new char[strlen(name) + 1];\n\t\tstrcpy(pName, name);\n\t}\n\n\tPerson& operator=(const Person& p) {\n\n\t\tif (this->pName != NULL) {\n\t\t\tdelete[] this->pName;\n\t\t\tpName = NULL;\n\t\t}\n\n\t\tpName = new char[strlen(p.pName) + 1];\n\t\tstrcpy(pName, p.pName);\n\n\t\treturn *this;\n\n\t}\n\n\t~Person() {\n\t\tif (this->pName != NULL) {\n\t\t\tdelete[] this->pName;\n\t\t\tpName = NULL;\n\t\t}\n\t}\n\n\tchar* pName;\n\n};\n\n~~~\n实现效果\n~~~\nPerson p1(\"AAA\");\nPerson p2(\"BBB\");\nPerson p3(\"CCC\");\n\np3 = p2 = p1;\n~~~\n\n\n---\n\n### ==\n前面的示例即为**==**的重载，实现过程无非就是把原本要写的判断放到运算符重载函数中。\n\n注意的是：对关系运算符进行重载时，不要对**&&**，**||**进行重载！\n\n因为内置版本是具备**短路特性**的，而我们进行重载时是无法实现的。\n\n---\n\n### ++\n\n前置++效率更高，后置++由于返回的是临时变量，因此无法返回引用所以效率相对前置++效率会低。\n\n~~~\nclass MyInterger {\npublic:\n\tMyInterger() {\n\t\tm_A = 0;\n\t}\n\n\t//前置++返回引用，效率高\n\tMyInterger& operator++() {\n\t\tthis->m_A++;\n\t\treturn *this;\n\t}\n\n\t//后置++返回值，因为temp为临时变量，不能返回引用\n\tMyInterger operator++(int) {\n\t\tMyInterger temp = *this;\n\t\tthis->m_A++;\n\t\treturn temp;\n\t}\n\n\tint m_A;\n};\n~~~\n实现效果\n~~~\n++(++myInt);//myInt.m_A = 2\n~~~\n\n\n---\n\n### * 和 ->\n\n这是一个智能指针思想的例子。使用一个智能指针类来维护一个需要开辟空间的类。目的是防止new完后忘记delete。（new后，只有手动delete才会释放对象开辟的空间且进行析构函数调用）\n\n智能指针对象在栈上创建，生命周期结束一定会调用析构函数，因此保证维护的类空间能保证释放。\n\n被智能指针类维护的类\n~~~\npublic:\n\n\tPerson(int a) {\n\t\tthis->m_A = a;\n\t}\n\n\tvoid show() {\n\t\tcout << this->m_A << endl;\n\t}\n\n\t~Person() {}\n\n\tint m_A;\n};\n~~~\n\n智能指针类，通过对 * 和 -> 的重载，达到SmartPoint既能保证Person类new空间的释放，还能达到指针的特性。\n~~~\nclass SmartPoint {\n\npublic:\n\n\tSmartPoint(Person* person) {\n\t\tthis->person = person;\n\t}\n\n\tPerson* operator->() {\n\n\t\treturn this->person;\n\n\t}\n\n\tPerson& operator*() {\n\n\t\treturn *this->person;\n\n\t}\n\n\t~SmartPoint() {\n\t\tif (this->person != NULL) {\n\t\t\tdelete(person);\n\t\t\tperson = NULL;\n\t\t}\n\t}\n\nprivate:\n\tPerson* person;\n\n};\n~~~\n实现效果\n~~~\nSmartPoint sp = SmartPoint(new Person(10));\n\nsp->show();//sp->->show();\n\n(*sp).show();\n~~~\n\n---\n\n### ()\n\n**仿函数**\n\n对函数调用运算符重载，只是简单的接触了用法，可以让对象像一个函数调用。\n\n简单案例\n~~~\nclass Add {\n\npublic:\n\tAdd() {\n\n\t}\n\n\tAdd(int a) {\n\t\tthis->m_A = a;\n\t}\n\n\tint operator()(int a, int b) {\n\t\treturn a + b;\n\t}\n\nprivate:\n\tint m_A;\n};\n\n~~~\n实现效果\n~~~\nAdd add1;\ncout << add1(1, 1) << endl;//2\n~~~\n\n\nPS:轮子哥写的文章是有味道的😂","slug":"2019-Holiday-Note-14","published":1,"updated":"2019-07-26T14:37:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihp0015smjb8ey7co8j","content":"<h1 id=\"Holiday-Note-14\"><a href=\"#Holiday-Note-14\" class=\"headerlink\" title=\"Holiday Note_14\"></a>Holiday Note_14</h1><p>学习了C++中两个重要的知识点：<strong>运算符重载</strong>以及<strong>继承</strong>。其中运算符的重载特性真的是非常的灵活，C++中几乎所有的运算符都可以被赋予新的功能。它的本质还是<strong>函数调用</strong>，使用得当可以让涉及类的代码更加的<strong>易于读写</strong>；简单继承派生还是挺好理解的，就是一个父与子的关系。不过<strong>多继承</strong>，<strong>菱形继承</strong>还有<strong>虚继承</strong>的实现原理这块不太好理解，明天再对这一块深入学习。</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"运算符重载-operator-overloading\"><a href=\"#运算符重载-operator-overloading\" class=\"headerlink\" title=\"运算符重载(operator overloading)\"></a>运算符重载(operator overloading)</h2><p><a href=\"https://miao.su/image/T2Xk6\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/26/operator09faf.md.png\" alt=\"operator09faf.md.png\"></a></p>\n<p>先总结一下要注意的点：</p>\n<ul>\n<li>=, [], () 和 -&gt; 操作符只能通过成员函数进行重载 </li>\n<li>&lt;&lt; 和 &gt;&gt;只能通过全局函数配合友元函数进行重载 </li>\n<li>不要重载 &amp;&amp; 和 || 操作符，因为无法实现短路规则</li>\n</ul>\n<p>运算符重载，就是<strong>对已有的运算符重新进行定义</strong>，赋予其另一种功能，以<strong>适应不同的数据类型</strong>。</p>\n<p>由于C++有类的概念，因此在使用普通运算符对类进行操作时，会由于识别不了而无法达到像操作简单数据类型一样操作类了，引入运算符重载将运算符赋予对某一个类进行特定的操作达到代码的易于读写的目的。</p>\n<hr>\n<h3 id=\"介绍案例\"><a href=\"#介绍案例\" class=\"headerlink\" title=\"介绍案例\"></a>介绍案例</h3><p>有这样一个类</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson(<span class=\"keyword\">int</span> age, <span class=\"built_in\">string</span> name)&#123;</span><br><span class=\"line\">\t\tm_Age = age;</span><br><span class=\"line\">\t\tm_Name = name;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_Age;</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> m_Name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例两个对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">7</span>, <span class=\"string\">\"小明\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">9</span>, <span class=\"string\">\"小红\"</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>假设在没有进行运算符重载时，判断两个类的成员是否相同要对类的单个成员进行比对判断。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(p1.m_Age == p2.m_Age &amp;&amp; p1.m_Name == p2.m_Name)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"相同\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"不同\"</span> &lt;&lt; end;;</span><br></pre></td></tr></table></figure>\n\n<p>若是使用操作符重载，将逻辑运算符==进行重载</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(p1 == p2)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"相同\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"不同\"</span> &lt;&lt; end;;</span><br></pre></td></tr></table></figure>\n\n<p>可见，通过操作运算符重载，可以使得原本无法对类进行判断的==运算符拥有了我们自己需要的判断功能，这便是运算符重载带来了的便利。</p>\n<hr>\n<h3 id><a href=\"#\" class=\"headerlink\" title=\"+\"></a>+</h3><p>对+进行重载演示写法</p>\n<p>类中包含成员函数方式实现运算符重载1</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">S</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tS() &#123;&#125;</span><br><span class=\"line\">\tS(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) : m_A(a), m_B(b) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_A;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_B;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//重载函数</span></span><br><span class=\"line\">\tS <span class=\"keyword\">operator</span>+(S&amp; s) &#123;</span><br><span class=\"line\">\t\tS temp;</span><br><span class=\"line\">\t\ttemp.m_A = <span class=\"keyword\">this</span>-&gt;m_A + s.m_A;</span><br><span class=\"line\">\t\ttemp.m_B = <span class=\"keyword\">this</span>-&gt;m_B + s.m_B;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>全局函数方式实现运算符重载2，由于参数不同，可以让+有不同的功能</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重载函数</span></span><br><span class=\"line\">S <span class=\"keyword\">operator</span>+(S&amp; s1, int <span class=\"keyword\">val</span>) &#123;</span><br><span class=\"line\">\tS temp;</span><br><span class=\"line\">\ttemp.m_A = s1.m_A + <span class=\"keyword\">val</span>;</span><br><span class=\"line\">\ttemp.m_B = s1.m_B + <span class=\"keyword\">val</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tS <span class=\"built_in\">s1</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">\tS <span class=\"built_in\">s2</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tS <span class=\"built_in\">s3</span> = <span class=\"built_in\">s1</span> + <span class=\"built_in\">s2</span><span class=\"comment\">;</span></span><br><span class=\"line\">\tS <span class=\"built_in\">s4</span> = <span class=\"built_in\">s1</span> + <span class=\"number\">10</span><span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">s3</span>.m_A &lt;&lt; endl<span class=\"comment\">;//3</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">s3</span>.m_B &lt;&lt; endl<span class=\"comment\">;//3</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">s4</span>.m_A &lt;&lt; endl<span class=\"comment\">;//11</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">s4</span>.m_B &lt;&lt; endl<span class=\"comment\">;//11</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"lt-lt\"><a href=\"#lt-lt\" class=\"headerlink\" title=\"&lt;&lt;\"></a>&lt;&lt;</h3><p>对左移运算符重载<strong>必须使用全局函数定义方式定义而不能使用成员函数方式定义</strong>。</p>\n<p>cout的类型为ostream</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; <span class=\"built_in\">cout</span>, Person&amp; p);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;m_A = a;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;m_B = b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_A;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_B;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>返回ostream&amp;目的是可以继续实现&lt;&lt;链式编程</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp;<span class=\"built_in\">cout</span>, Person&amp; p) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"m_A = \"</span> &lt;&lt; p.m_A &lt;&lt; <span class=\"string\">\" m_B = \"</span> &lt;&lt; p.m_B;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">cout</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">7</span>, <span class=\"number\">9</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; p1 &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//m_A = 7 m_B = 9</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"gt-gt\"><a href=\"#gt-gt\" class=\"headerlink\" title=\"&gt;&gt;\"></a>&gt;&gt;</h3><p>与重载&lt;&lt;类似，对&gt;&gt;进行重载也只能使用全局函数方式进行实现。</p>\n<p>cin的类型为istream</p>\n<p>类的定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tTest(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;str = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(s) + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(str, s);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* str;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>判断需要录入数据的变量是否有数据，有要先进行释放置空操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">istream&amp; <span class=\"keyword\">operator</span>&gt;&gt;(istream&amp; <span class=\"built_in\">cin</span>, Test&amp; s) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (s.str != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> s.str;</span><br><span class=\"line\">\t\ts.str = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; buf;</span><br><span class=\"line\"></span><br><span class=\"line\">\ts.str = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(buf) + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(s.str, buf);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">cin</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Test </span>t1(\"AAA\");</span><br><span class=\"line\">cout &lt;&lt; t1.str &lt;&lt; endl;</span><br><span class=\"line\">cin &gt;&gt; t1;</span><br><span class=\"line\">cout &lt;&lt; t1.str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"=\"></a>=</h3><p>必须使用成员函数方法实现<strong>=</strong>的重载</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tPerson(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;pName = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(name) + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(pName, name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Person&amp; p) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;pName != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span>[] <span class=\"keyword\">this</span>-&gt;pName;</span><br><span class=\"line\">\t\t\tpName = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpName = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(p.pName) + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(pName, p.pName);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~Person() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;pName != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span>[] <span class=\"keyword\">this</span>-&gt;pName;</span><br><span class=\"line\">\t\t\tpName = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* pName;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1(<span class=\"string\">\"AAA\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">Person p2(<span class=\"string\">\"BBB\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">Person p3(<span class=\"string\">\"CCC\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">p3</span> = p2 = p1<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"==\"></a>==</h3><p>前面的示例即为<strong>==</strong>的重载，实现过程无非就是把原本要写的判断放到运算符重载函数中。</p>\n<p>注意的是：对关系运算符进行重载时，不要对<strong>&amp;&amp;</strong>，<strong>||</strong>进行重载！</p>\n<p>因为内置版本是具备<strong>短路特性</strong>的，而我们进行重载时是无法实现的。</p>\n<hr>\n<h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"++\"></a>++</h3><p>前置++效率更高，后置++由于返回的是临时变量，因此无法返回引用所以效率相对前置++效率会低。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterger</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tMyInterger() &#123;</span><br><span class=\"line\">\t\tm_A = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//前置++返回引用，效率高</span></span><br><span class=\"line\">\tMyInterger&amp; <span class=\"keyword\">operator</span>++() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;m_A++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//后置++返回值，因为temp为临时变量，不能返回引用</span></span><br><span class=\"line\">\tMyInterger <span class=\"keyword\">operator</span>++(int) &#123;</span><br><span class=\"line\">\t\tMyInterger temp = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;m_A++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint m_A;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"comment\">(</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"comment\">myInt);//myInt</span><span class=\"string\">.</span><span class=\"comment\">m_A</span> <span class=\"comment\">=</span> <span class=\"comment\">2</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"和-gt\"><a href=\"#和-gt\" class=\"headerlink\" title=\"* 和 -&gt;\"></a>* 和 -&gt;</h3><p>这是一个智能指针思想的例子。使用一个智能指针类来维护一个需要开辟空间的类。目的是防止new完后忘记delete。（new后，只有手动delete才会释放对象开辟的空间且进行析构函数调用）</p>\n<p>智能指针对象在栈上创建，生命周期结束一定会调用析构函数，因此保证维护的类空间能保证释放。</p>\n<p>被智能指针类维护的类</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson(<span class=\"keyword\">int</span> a) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;m_A = a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">this</span>-&gt;m_A &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~Person() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_A;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>智能指针类，通过对 * 和 -&gt; 的重载，达到SmartPoint既能保证Person类new空间的释放，还能达到指针的特性。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartPoint</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tSmartPoint(Person* person) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;person = person;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson* <span class=\"keyword\">operator</span>-&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;person;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson&amp; <span class=\"keyword\">operator</span>*() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>-&gt;person;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~SmartPoint() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;person != NULL) &#123;</span><br><span class=\"line\">\t\t\tdelete(person);</span><br><span class=\"line\">\t\t\tperson = NULL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tPerson* person;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SmartPoint sp = <span class=\"built_in\">SmartPoint</span>(new <span class=\"built_in\">Person</span>(<span class=\"number\">10</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">sp-&gt;<span class=\"keyword\">show</span>();<span class=\"comment\">//sp-&gt;-&gt;show();</span></span><br><span class=\"line\"></span><br><span class=\"line\">(*sp).<span class=\"keyword\">show</span>();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"()\"></a>()</h3><p><strong>仿函数</strong></p>\n<p>对函数调用运算符重载，只是简单的接触了用法，可以让对象像一个函数调用。</p>\n<p>简单案例</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Add</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tAdd() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tAdd(<span class=\"keyword\">int</span> a) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;m_A = a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_A;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Add </span><span class=\"keyword\">add1;</span></span><br><span class=\"line\"><span class=\"keyword\">cout </span>&lt;&lt; <span class=\"keyword\">add1(1, </span><span class=\"number\">1</span>) &lt;&lt; endl<span class=\"comment\">;//2</span></span><br></pre></td></tr></table></figure>\n\n<p>PS:轮子哥写的文章是有味道的😂</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-14\"><a href=\"#Holiday-Note-14\" class=\"headerlink\" title=\"Holiday Note_14\"></a>Holiday Note_14</h1><p>学习了C++中两个重要的知识点：<strong>运算符重载</strong>以及<strong>继承</strong>。其中运算符的重载特性真的是非常的灵活，C++中几乎所有的运算符都可以被赋予新的功能。它的本质还是<strong>函数调用</strong>，使用得当可以让涉及类的代码更加的<strong>易于读写</strong>；简单继承派生还是挺好理解的，就是一个父与子的关系。不过<strong>多继承</strong>，<strong>菱形继承</strong>还有<strong>虚继承</strong>的实现原理这块不太好理解，明天再对这一块深入学习。</p>","more":"<hr>\n<h2 id=\"运算符重载-operator-overloading\"><a href=\"#运算符重载-operator-overloading\" class=\"headerlink\" title=\"运算符重载(operator overloading)\"></a>运算符重载(operator overloading)</h2><p><a href=\"https://miao.su/image/T2Xk6\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/26/operator09faf.md.png\" alt=\"operator09faf.md.png\"></a></p>\n<p>先总结一下要注意的点：</p>\n<ul>\n<li>=, [], () 和 -&gt; 操作符只能通过成员函数进行重载 </li>\n<li>&lt;&lt; 和 &gt;&gt;只能通过全局函数配合友元函数进行重载 </li>\n<li>不要重载 &amp;&amp; 和 || 操作符，因为无法实现短路规则</li>\n</ul>\n<p>运算符重载，就是<strong>对已有的运算符重新进行定义</strong>，赋予其另一种功能，以<strong>适应不同的数据类型</strong>。</p>\n<p>由于C++有类的概念，因此在使用普通运算符对类进行操作时，会由于识别不了而无法达到像操作简单数据类型一样操作类了，引入运算符重载将运算符赋予对某一个类进行特定的操作达到代码的易于读写的目的。</p>\n<hr>\n<h3 id=\"介绍案例\"><a href=\"#介绍案例\" class=\"headerlink\" title=\"介绍案例\"></a>介绍案例</h3><p>有这样一个类</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson(<span class=\"keyword\">int</span> age, <span class=\"built_in\">string</span> name)&#123;</span><br><span class=\"line\">\t\tm_Age = age;</span><br><span class=\"line\">\t\tm_Name = name;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_Age;</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> m_Name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例两个对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">7</span>, <span class=\"string\">\"小明\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">9</span>, <span class=\"string\">\"小红\"</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>假设在没有进行运算符重载时，判断两个类的成员是否相同要对类的单个成员进行比对判断。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(p1.m_Age == p2.m_Age &amp;&amp; p1.m_Name == p2.m_Name)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"相同\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"不同\"</span> &lt;&lt; end;;</span><br></pre></td></tr></table></figure>\n\n<p>若是使用操作符重载，将逻辑运算符==进行重载</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(p1 == p2)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"相同\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"不同\"</span> &lt;&lt; end;;</span><br></pre></td></tr></table></figure>\n\n<p>可见，通过操作运算符重载，可以使得原本无法对类进行判断的==运算符拥有了我们自己需要的判断功能，这便是运算符重载带来了的便利。</p>\n<hr>\n<h3 id><a href=\"#\" class=\"headerlink\" title=\"+\"></a>+</h3><p>对+进行重载演示写法</p>\n<p>类中包含成员函数方式实现运算符重载1</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">S</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tS() &#123;&#125;</span><br><span class=\"line\">\tS(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) : m_A(a), m_B(b) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_A;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_B;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//重载函数</span></span><br><span class=\"line\">\tS <span class=\"keyword\">operator</span>+(S&amp; s) &#123;</span><br><span class=\"line\">\t\tS temp;</span><br><span class=\"line\">\t\ttemp.m_A = <span class=\"keyword\">this</span>-&gt;m_A + s.m_A;</span><br><span class=\"line\">\t\ttemp.m_B = <span class=\"keyword\">this</span>-&gt;m_B + s.m_B;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>全局函数方式实现运算符重载2，由于参数不同，可以让+有不同的功能</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重载函数</span></span><br><span class=\"line\">S <span class=\"keyword\">operator</span>+(S&amp; s1, int <span class=\"keyword\">val</span>) &#123;</span><br><span class=\"line\">\tS temp;</span><br><span class=\"line\">\ttemp.m_A = s1.m_A + <span class=\"keyword\">val</span>;</span><br><span class=\"line\">\ttemp.m_B = s1.m_B + <span class=\"keyword\">val</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tS <span class=\"built_in\">s1</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">\tS <span class=\"built_in\">s2</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tS <span class=\"built_in\">s3</span> = <span class=\"built_in\">s1</span> + <span class=\"built_in\">s2</span><span class=\"comment\">;</span></span><br><span class=\"line\">\tS <span class=\"built_in\">s4</span> = <span class=\"built_in\">s1</span> + <span class=\"number\">10</span><span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">s3</span>.m_A &lt;&lt; endl<span class=\"comment\">;//3</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">s3</span>.m_B &lt;&lt; endl<span class=\"comment\">;//3</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">s4</span>.m_A &lt;&lt; endl<span class=\"comment\">;//11</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">s4</span>.m_B &lt;&lt; endl<span class=\"comment\">;//11</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"lt-lt\"><a href=\"#lt-lt\" class=\"headerlink\" title=\"&lt;&lt;\"></a>&lt;&lt;</h3><p>对左移运算符重载<strong>必须使用全局函数定义方式定义而不能使用成员函数方式定义</strong>。</p>\n<p>cout的类型为ostream</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; <span class=\"built_in\">cout</span>, Person&amp; p);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;m_A = a;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;m_B = b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_A;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_B;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>返回ostream&amp;目的是可以继续实现&lt;&lt;链式编程</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp;<span class=\"built_in\">cout</span>, Person&amp; p) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"m_A = \"</span> &lt;&lt; p.m_A &lt;&lt; <span class=\"string\">\" m_B = \"</span> &lt;&lt; p.m_B;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">cout</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">7</span>, <span class=\"number\">9</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; p1 &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//m_A = 7 m_B = 9</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"gt-gt\"><a href=\"#gt-gt\" class=\"headerlink\" title=\"&gt;&gt;\"></a>&gt;&gt;</h3><p>与重载&lt;&lt;类似，对&gt;&gt;进行重载也只能使用全局函数方式进行实现。</p>\n<p>cin的类型为istream</p>\n<p>类的定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tTest(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;str = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(s) + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(str, s);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* str;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>判断需要录入数据的变量是否有数据，有要先进行释放置空操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">istream&amp; <span class=\"keyword\">operator</span>&gt;&gt;(istream&amp; <span class=\"built_in\">cin</span>, Test&amp; s) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (s.str != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> s.str;</span><br><span class=\"line\">\t\ts.str = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; buf;</span><br><span class=\"line\"></span><br><span class=\"line\">\ts.str = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(buf) + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(s.str, buf);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">cin</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Test </span>t1(\"AAA\");</span><br><span class=\"line\">cout &lt;&lt; t1.str &lt;&lt; endl;</span><br><span class=\"line\">cin &gt;&gt; t1;</span><br><span class=\"line\">cout &lt;&lt; t1.str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"=\"></a>=</h3><p>必须使用成员函数方法实现<strong>=</strong>的重载</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tPerson(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;pName = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(name) + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(pName, name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Person&amp; p) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;pName != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span>[] <span class=\"keyword\">this</span>-&gt;pName;</span><br><span class=\"line\">\t\t\tpName = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpName = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(p.pName) + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(pName, p.pName);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~Person() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;pName != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span>[] <span class=\"keyword\">this</span>-&gt;pName;</span><br><span class=\"line\">\t\t\tpName = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* pName;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1(<span class=\"string\">\"AAA\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">Person p2(<span class=\"string\">\"BBB\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">Person p3(<span class=\"string\">\"CCC\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">p3</span> = p2 = p1<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"==\"></a>==</h3><p>前面的示例即为<strong>==</strong>的重载，实现过程无非就是把原本要写的判断放到运算符重载函数中。</p>\n<p>注意的是：对关系运算符进行重载时，不要对<strong>&amp;&amp;</strong>，<strong>||</strong>进行重载！</p>\n<p>因为内置版本是具备<strong>短路特性</strong>的，而我们进行重载时是无法实现的。</p>\n<hr>\n<h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"++\"></a>++</h3><p>前置++效率更高，后置++由于返回的是临时变量，因此无法返回引用所以效率相对前置++效率会低。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterger</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tMyInterger() &#123;</span><br><span class=\"line\">\t\tm_A = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//前置++返回引用，效率高</span></span><br><span class=\"line\">\tMyInterger&amp; <span class=\"keyword\">operator</span>++() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;m_A++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//后置++返回值，因为temp为临时变量，不能返回引用</span></span><br><span class=\"line\">\tMyInterger <span class=\"keyword\">operator</span>++(int) &#123;</span><br><span class=\"line\">\t\tMyInterger temp = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;m_A++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint m_A;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"comment\">(</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"comment\">myInt);//myInt</span><span class=\"string\">.</span><span class=\"comment\">m_A</span> <span class=\"comment\">=</span> <span class=\"comment\">2</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"和-gt\"><a href=\"#和-gt\" class=\"headerlink\" title=\"* 和 -&gt;\"></a>* 和 -&gt;</h3><p>这是一个智能指针思想的例子。使用一个智能指针类来维护一个需要开辟空间的类。目的是防止new完后忘记delete。（new后，只有手动delete才会释放对象开辟的空间且进行析构函数调用）</p>\n<p>智能指针对象在栈上创建，生命周期结束一定会调用析构函数，因此保证维护的类空间能保证释放。</p>\n<p>被智能指针类维护的类</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson(<span class=\"keyword\">int</span> a) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;m_A = a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">this</span>-&gt;m_A &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~Person() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_A;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>智能指针类，通过对 * 和 -&gt; 的重载，达到SmartPoint既能保证Person类new空间的释放，还能达到指针的特性。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartPoint</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tSmartPoint(Person* person) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;person = person;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson* <span class=\"keyword\">operator</span>-&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;person;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson&amp; <span class=\"keyword\">operator</span>*() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>-&gt;person;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~SmartPoint() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;person != NULL) &#123;</span><br><span class=\"line\">\t\t\tdelete(person);</span><br><span class=\"line\">\t\t\tperson = NULL;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tPerson* person;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SmartPoint sp = <span class=\"built_in\">SmartPoint</span>(new <span class=\"built_in\">Person</span>(<span class=\"number\">10</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">sp-&gt;<span class=\"keyword\">show</span>();<span class=\"comment\">//sp-&gt;-&gt;show();</span></span><br><span class=\"line\"></span><br><span class=\"line\">(*sp).<span class=\"keyword\">show</span>();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"()\"></a>()</h3><p><strong>仿函数</strong></p>\n<p>对函数调用运算符重载，只是简单的接触了用法，可以让对象像一个函数调用。</p>\n<p>简单案例</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Add</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tAdd() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tAdd(<span class=\"keyword\">int</span> a) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;m_A = a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_A;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Add </span><span class=\"keyword\">add1;</span></span><br><span class=\"line\"><span class=\"keyword\">cout </span>&lt;&lt; <span class=\"keyword\">add1(1, </span><span class=\"number\">1</span>) &lt;&lt; endl<span class=\"comment\">;//2</span></span><br></pre></td></tr></table></figure>\n\n<p>PS:轮子哥写的文章是有味道的😂</p>"},{"title":"Holiday Note_15","date":"2019-07-27T12:58:58.000Z","_content":"\n# Holiday Note_15\n\n**继承**，**多态**，**虚基类**，**虚函数**，**纯虚析构函数**，**虚函数指针**，**虚析构函数**，**纯虚析构函数**，还有最搞笑的羊驼(草泥马)——**菱形继承(钻石继承)**🤣。不得不说C++的这些名词取得真有意思。\n\n要自个直接去取虚函数指针找虚函数表里边的函数地址来调用的话，不用Developer Commond prompt看下类的结构真的不好下手。。。\n~~~\n((void(*)())(*((int*)*(int*)(&dog) + 1)))();\n~~~\n\n<!-- more -->\n\n## 继承\n\n使用VS的Developer Commond prompt进入当前工程的目录下，输入命令\n~~~\t\ncl /d1 reportSingleClassLayout类名 文件名\n~~~\n可以查看类的模型，继承关系，sizeof的大小，虚函数表等。\n\n-\t子类会继承父类中所有的内容 ，包括了 私有属性\n-\t只是我们访问不到，编译器给隐藏了\n\n\n### 派生类访问控制\n[![36deebef62d3c08613e64.md.png](https://miao.su/images/2019/07/27/36deebef62d3c08613e64.md.png)](https://miao.su/image/T7vXU)\n\n### 继承中的构造和析构顺序\n-\t子类对象在创建时会首先调用父类的构造函数\n-\t父类构造函数执行完毕后，才会调用子类的构造函数\n-\t当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数\n-\t析构函数调用顺序和构造函数相反\n- 如果**父类中没有合适默认构造**，那么子类可以利用**初始化列表**的方式显示的调用父类的其他构造\n\n### 继承中同名成员和函数的处理方法\n-\t当子类成员和父类成员同名时，子类依然从父类继承同名成员\n-\t如果子类有成员和父类同名，子类访问其成员默认访问子类的成员(本作用域，就近原则)\n-\t在子类通过作用域::进行同名成员区分(在派生类中使用基类的同名成员，显示使用类名限定符)\n\n- 静态成员和函数的处理方法类似\t\n\n### 多继承&&菱形继承\n写法\n~~~\nclass A : public B1, public B2,\n~~~\n\n避免二义性问题，使用作用域::进行成员和函数的使用。\n\n\n### 菱形继承\n[![cnm88b84.jpg](https://miao.su/images/2019/07/27/cnm88b84.jpg)](https://miao.su/image/T7zO8)\n\n譬如羊驼这种继承羊类和驼类，而羊类和驼类又继承于动物类。以上所有类均有m_Age，则羊驼内部实质有两份m_Age的数据。要**避免数据重复**需要使用到**虚基类**。\n\n在定义羊类和驼类使用**虚基类**的方法。\n\n~~~\nclass BigBase{\npublic:\n\tBigBase(){ mParam = 0; }\n\tvoid func(){ cout << \"BigBase::func\" << endl; }\npublic:\n\tint mParam;\n};\n\nclass Base1 : virtual public BigBase{};\nclass Base2 : virtual public BigBase{};\nclass Derived : public Base1, public Base2{}\n\n~~~\n\n\n[![vbptrbc5e0.png](https://miao.su/images/2019/07/27/vbptrbc5e0.png)](https://miao.su/image/T7oKM)\n\n-\tBase1和Base2通过虚继承的方式派生自BigBase,这两个对象的布局图中可以看出编译器为我们的对象中增加了一个vbptr (virtual base pointer),vbptr指向了一张表，这张表保存了当前的虚指针相对于虚基类的首地址的偏移量。\n-\tDerived派生于Base1和Base2,继承了两个基类的vbptr指针，并调整了vbptr与虚基类的首地址的偏移量找到共有的数据。\n\n\n## 多态\n**父类的引用或指针指向子类对象**\n\n###\t静态联编和动态联编\n多态分类\n-\t静态多态  函数重载\n-\t动态多态 虚函数 继承关系\n-\t\n静态联编\n-\t地址早绑定 编译阶段绑定好地址\n\n动态联编 \n-\t地址晚绑定 ，运行时候绑定好地址\n\n\n### 多态原理解析\n-\t当父类中有了虚函数后，内部结构就发生了改变\n-\t内部多了一个 vfprt(virtual  function pointer)**虚函数表指针**指向 vftable  虚函数表\n\t\n-\t父类中结构  vfptr     &Animal::speak\n-\t子类中 进行继承 会继承 vfptr  vftable\n-\t构造函数中 会将虚函数表指针 指向自己的虚函数表\n-\t如果**发生了重写**，会**替换掉虚函数表**中的原有的speak，改为 &Cat::speak\n\n### 抽象类和纯虚函数\n-\t纯虚函数写法  virtual void func() = 0;\n-\t抽象类型\n-\t**抽象类** **不可以实例化对象**\n-\t如果类 继承了抽象类， **必须重写抽象类中的纯虚函数**\n\n###\t虚析构和纯虚析构\n-\t虚析构: virtual ~类名() {}\n-\t解决问题： 通过父类指针指向子类对象释放时候不干净导致的问题(即子类不会执行析构函数)\n-\t纯虚析构函数写法  virtual ~类名() = 0 \t\n-\t类内声明  类外实现\n-\t如果出现了纯虚析构函数，这个类也算抽象类，**不可以实例化对象**\n\n###\t向上类型转换和向下类型转换\n-\t基类转派生类即**向下类型转换**：不安全的\t\n-\t派生类转 基类即向上类型转换：安全\t\n-\t如果发生多态总是安全的\n\n以下为一个虚函数表指针的使用例子\n\n定义父类Animal和子类Dog，使用虚函数。\n~~~\nclass Animal {\npublic:\n\t//动态联编，讲speak方法写为虚函数\n\tvirtual void speak() {\n\t\tcout << \"Animal speak!!!\" << endl;\n\t}\n\tvirtual void eat() {\n\t\tcout << \"Animal eat!!!\" << endl;\n\t}\n};\n\nclass Dog :public Animal {\npublic:\n\tvoid speak() {\n\t\tcout << \"Dog speak!!!\" << endl;\n\t}\n\tvoid eat() {\n\t\tcout << \"Dog eat!!!\" << endl;\n\t}\n};\n~~~\n创建一个Dog类的对象\n~~~\nDog dog;\n//doSpeak(dog);\n~~~\n主要操作\n~~~\n\t// 这是函数指针(void(*)())\t\n\t//通过dog对象地址找到虚函数表内的函数地址执行等同doSpeak(dog)的操作\n\t((void(*)()) * (int*) * (int*)(&dog))();\n\n\t// 进阶，虚函数表中有两个函数地址，现在通过编译器方式找到第二个函数的地址并且执行\n\t((void(*)())(*((int*) * (int*)(&dog) + 1)))();\n\n}\n~~~\n若父类还有其他变量，则获得虚函数指针时要多进行一次偏移操作。\n[![0a74dbfa5e2bed1596b9d9d96b14703548ce.png](https://miao.su/images/2019/07/27/0a74dbfa5e2bed1596b9d9d96b14703548ce.png)](https://miao.su/image/T7RU5)\n\nPS:轮子哥nb","source":"_posts/2019-Holiday-Note-15.md","raw":"---\ntitle: Holiday Note_15\ndate: 2019-07-27 20:58:58\ncategories: C++\ntags: [Note,C++]\n---\n\n# Holiday Note_15\n\n**继承**，**多态**，**虚基类**，**虚函数**，**纯虚析构函数**，**虚函数指针**，**虚析构函数**，**纯虚析构函数**，还有最搞笑的羊驼(草泥马)——**菱形继承(钻石继承)**🤣。不得不说C++的这些名词取得真有意思。\n\n要自个直接去取虚函数指针找虚函数表里边的函数地址来调用的话，不用Developer Commond prompt看下类的结构真的不好下手。。。\n~~~\n((void(*)())(*((int*)*(int*)(&dog) + 1)))();\n~~~\n\n<!-- more -->\n\n## 继承\n\n使用VS的Developer Commond prompt进入当前工程的目录下，输入命令\n~~~\t\ncl /d1 reportSingleClassLayout类名 文件名\n~~~\n可以查看类的模型，继承关系，sizeof的大小，虚函数表等。\n\n-\t子类会继承父类中所有的内容 ，包括了 私有属性\n-\t只是我们访问不到，编译器给隐藏了\n\n\n### 派生类访问控制\n[![36deebef62d3c08613e64.md.png](https://miao.su/images/2019/07/27/36deebef62d3c08613e64.md.png)](https://miao.su/image/T7vXU)\n\n### 继承中的构造和析构顺序\n-\t子类对象在创建时会首先调用父类的构造函数\n-\t父类构造函数执行完毕后，才会调用子类的构造函数\n-\t当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数\n-\t析构函数调用顺序和构造函数相反\n- 如果**父类中没有合适默认构造**，那么子类可以利用**初始化列表**的方式显示的调用父类的其他构造\n\n### 继承中同名成员和函数的处理方法\n-\t当子类成员和父类成员同名时，子类依然从父类继承同名成员\n-\t如果子类有成员和父类同名，子类访问其成员默认访问子类的成员(本作用域，就近原则)\n-\t在子类通过作用域::进行同名成员区分(在派生类中使用基类的同名成员，显示使用类名限定符)\n\n- 静态成员和函数的处理方法类似\t\n\n### 多继承&&菱形继承\n写法\n~~~\nclass A : public B1, public B2,\n~~~\n\n避免二义性问题，使用作用域::进行成员和函数的使用。\n\n\n### 菱形继承\n[![cnm88b84.jpg](https://miao.su/images/2019/07/27/cnm88b84.jpg)](https://miao.su/image/T7zO8)\n\n譬如羊驼这种继承羊类和驼类，而羊类和驼类又继承于动物类。以上所有类均有m_Age，则羊驼内部实质有两份m_Age的数据。要**避免数据重复**需要使用到**虚基类**。\n\n在定义羊类和驼类使用**虚基类**的方法。\n\n~~~\nclass BigBase{\npublic:\n\tBigBase(){ mParam = 0; }\n\tvoid func(){ cout << \"BigBase::func\" << endl; }\npublic:\n\tint mParam;\n};\n\nclass Base1 : virtual public BigBase{};\nclass Base2 : virtual public BigBase{};\nclass Derived : public Base1, public Base2{}\n\n~~~\n\n\n[![vbptrbc5e0.png](https://miao.su/images/2019/07/27/vbptrbc5e0.png)](https://miao.su/image/T7oKM)\n\n-\tBase1和Base2通过虚继承的方式派生自BigBase,这两个对象的布局图中可以看出编译器为我们的对象中增加了一个vbptr (virtual base pointer),vbptr指向了一张表，这张表保存了当前的虚指针相对于虚基类的首地址的偏移量。\n-\tDerived派生于Base1和Base2,继承了两个基类的vbptr指针，并调整了vbptr与虚基类的首地址的偏移量找到共有的数据。\n\n\n## 多态\n**父类的引用或指针指向子类对象**\n\n###\t静态联编和动态联编\n多态分类\n-\t静态多态  函数重载\n-\t动态多态 虚函数 继承关系\n-\t\n静态联编\n-\t地址早绑定 编译阶段绑定好地址\n\n动态联编 \n-\t地址晚绑定 ，运行时候绑定好地址\n\n\n### 多态原理解析\n-\t当父类中有了虚函数后，内部结构就发生了改变\n-\t内部多了一个 vfprt(virtual  function pointer)**虚函数表指针**指向 vftable  虚函数表\n\t\n-\t父类中结构  vfptr     &Animal::speak\n-\t子类中 进行继承 会继承 vfptr  vftable\n-\t构造函数中 会将虚函数表指针 指向自己的虚函数表\n-\t如果**发生了重写**，会**替换掉虚函数表**中的原有的speak，改为 &Cat::speak\n\n### 抽象类和纯虚函数\n-\t纯虚函数写法  virtual void func() = 0;\n-\t抽象类型\n-\t**抽象类** **不可以实例化对象**\n-\t如果类 继承了抽象类， **必须重写抽象类中的纯虚函数**\n\n###\t虚析构和纯虚析构\n-\t虚析构: virtual ~类名() {}\n-\t解决问题： 通过父类指针指向子类对象释放时候不干净导致的问题(即子类不会执行析构函数)\n-\t纯虚析构函数写法  virtual ~类名() = 0 \t\n-\t类内声明  类外实现\n-\t如果出现了纯虚析构函数，这个类也算抽象类，**不可以实例化对象**\n\n###\t向上类型转换和向下类型转换\n-\t基类转派生类即**向下类型转换**：不安全的\t\n-\t派生类转 基类即向上类型转换：安全\t\n-\t如果发生多态总是安全的\n\n以下为一个虚函数表指针的使用例子\n\n定义父类Animal和子类Dog，使用虚函数。\n~~~\nclass Animal {\npublic:\n\t//动态联编，讲speak方法写为虚函数\n\tvirtual void speak() {\n\t\tcout << \"Animal speak!!!\" << endl;\n\t}\n\tvirtual void eat() {\n\t\tcout << \"Animal eat!!!\" << endl;\n\t}\n};\n\nclass Dog :public Animal {\npublic:\n\tvoid speak() {\n\t\tcout << \"Dog speak!!!\" << endl;\n\t}\n\tvoid eat() {\n\t\tcout << \"Dog eat!!!\" << endl;\n\t}\n};\n~~~\n创建一个Dog类的对象\n~~~\nDog dog;\n//doSpeak(dog);\n~~~\n主要操作\n~~~\n\t// 这是函数指针(void(*)())\t\n\t//通过dog对象地址找到虚函数表内的函数地址执行等同doSpeak(dog)的操作\n\t((void(*)()) * (int*) * (int*)(&dog))();\n\n\t// 进阶，虚函数表中有两个函数地址，现在通过编译器方式找到第二个函数的地址并且执行\n\t((void(*)())(*((int*) * (int*)(&dog) + 1)))();\n\n}\n~~~\n若父类还有其他变量，则获得虚函数指针时要多进行一次偏移操作。\n[![0a74dbfa5e2bed1596b9d9d96b14703548ce.png](https://miao.su/images/2019/07/27/0a74dbfa5e2bed1596b9d9d96b14703548ce.png)](https://miao.su/image/T7RU5)\n\nPS:轮子哥nb","slug":"2019-Holiday-Note-15","published":1,"updated":"2019-07-27T14:00:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihq0018smjbwuz1cbpe","content":"<h1 id=\"Holiday-Note-15\"><a href=\"#Holiday-Note-15\" class=\"headerlink\" title=\"Holiday Note_15\"></a>Holiday Note_15</h1><p><strong>继承</strong>，<strong>多态</strong>，<strong>虚基类</strong>，<strong>虚函数</strong>，<strong>纯虚析构函数</strong>，<strong>虚函数指针</strong>，<strong>虚析构函数</strong>，<strong>纯虚析构函数</strong>，还有最搞笑的羊驼(草泥马)——<strong>菱形继承(钻石继承)</strong>🤣。不得不说C++的这些名词取得真有意思。</p>\n<p>要自个直接去取虚函数指针找虚函数表里边的函数地址来调用的话，不用Developer Commond prompt看下类的结构真的不好下手。。。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((<span class=\"name\">void</span>(<span class=\"name\"><span class=\"builtin-name\">*</span></span>)())(<span class=\"name\"><span class=\"builtin-name\">*</span></span>((<span class=\"name\">int*</span>)*(<span class=\"name\">int*</span>)(<span class=\"name\">&amp;dog</span>) + <span class=\"number\">1</span>)))()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>使用VS的Developer Commond prompt进入当前工程的目录下，输入命令</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">cl</span> /<span class=\"built_in\">d1</span> reportSingleClassLayout类名 文件名</span><br></pre></td></tr></table></figure>\n\n<p>可以查看类的模型，继承关系，sizeof的大小，虚函数表等。</p>\n<ul>\n<li>子类会继承父类中所有的内容 ，包括了 私有属性</li>\n<li>只是我们访问不到，编译器给隐藏了</li>\n</ul>\n<h3 id=\"派生类访问控制\"><a href=\"#派生类访问控制\" class=\"headerlink\" title=\"派生类访问控制\"></a>派生类访问控制</h3><p><a href=\"https://miao.su/image/T7vXU\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/27/36deebef62d3c08613e64.md.png\" alt=\"36deebef62d3c08613e64.md.png\"></a></p>\n<h3 id=\"继承中的构造和析构顺序\"><a href=\"#继承中的构造和析构顺序\" class=\"headerlink\" title=\"继承中的构造和析构顺序\"></a>继承中的构造和析构顺序</h3><ul>\n<li>子类对象在创建时会首先调用父类的构造函数</li>\n<li>父类构造函数执行完毕后，才会调用子类的构造函数</li>\n<li>当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数</li>\n<li>析构函数调用顺序和构造函数相反</li>\n<li>如果<strong>父类中没有合适默认构造</strong>，那么子类可以利用<strong>初始化列表</strong>的方式显示的调用父类的其他构造</li>\n</ul>\n<h3 id=\"继承中同名成员和函数的处理方法\"><a href=\"#继承中同名成员和函数的处理方法\" class=\"headerlink\" title=\"继承中同名成员和函数的处理方法\"></a>继承中同名成员和函数的处理方法</h3><ul>\n<li><p>当子类成员和父类成员同名时，子类依然从父类继承同名成员</p>\n</li>\n<li><p>如果子类有成员和父类同名，子类访问其成员默认访问子类的成员(本作用域，就近原则)</p>\n</li>\n<li><p>在子类通过作用域::进行同名成员区分(在派生类中使用基类的同名成员，显示使用类名限定符)</p>\n</li>\n<li><p>静态成员和函数的处理方法类似    </p>\n</li>\n</ul>\n<h3 id=\"多继承-amp-amp-菱形继承\"><a href=\"#多继承-amp-amp-菱形继承\" class=\"headerlink\" title=\"多继承&amp;&amp;菱形继承\"></a>多继承&amp;&amp;菱形继承</h3><p>写法</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> : <span class=\"type\">public B1</span>, <span class=\"type\">public B2</span>,<span class=\"type\"></span></span></span><br></pre></td></tr></table></figure>\n\n<p>避免二义性问题，使用作用域::进行成员和函数的使用。</p>\n<h3 id=\"菱形继承\"><a href=\"#菱形继承\" class=\"headerlink\" title=\"菱形继承\"></a>菱形继承</h3><p><a href=\"https://miao.su/image/T7zO8\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/27/cnm88b84.jpg\" alt=\"cnm88b84.jpg\"></a></p>\n<p>譬如羊驼这种继承羊类和驼类，而羊类和驼类又继承于动物类。以上所有类均有m_Age，则羊驼内部实质有两份m_Age的数据。要<strong>避免数据重复</strong>需要使用到<strong>虚基类</strong>。</p>\n<p>在定义羊类和驼类使用<strong>虚基类</strong>的方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BigBase</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tBigBase()&#123; mParam = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"BigBase::func\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mParam;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base1</span> :</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> BigBase&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base2</span> :</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> BigBase&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span> :</span> <span class=\"keyword\">public</span> Base1, <span class=\"keyword\">public</span> Base2&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://miao.su/image/T7oKM\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/27/vbptrbc5e0.png\" alt=\"vbptrbc5e0.png\"></a></p>\n<ul>\n<li>Base1和Base2通过虚继承的方式派生自BigBase,这两个对象的布局图中可以看出编译器为我们的对象中增加了一个vbptr (virtual base pointer),vbptr指向了一张表，这张表保存了当前的虚指针相对于虚基类的首地址的偏移量。</li>\n<li>Derived派生于Base1和Base2,继承了两个基类的vbptr指针，并调整了vbptr与虚基类的首地址的偏移量找到共有的数据。</li>\n</ul>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p><strong>父类的引用或指针指向子类对象</strong></p>\n<h3 id=\"静态联编和动态联编\"><a href=\"#静态联编和动态联编\" class=\"headerlink\" title=\"静态联编和动态联编\"></a>静态联编和动态联编</h3><p>多态分类</p>\n<ul>\n<li>静态多态  函数重载</li>\n<li>动态多态 虚函数 继承关系</li>\n<li>静态联编</li>\n<li>地址早绑定 编译阶段绑定好地址</li>\n</ul>\n<p>动态联编 </p>\n<ul>\n<li>地址晚绑定 ，运行时候绑定好地址</li>\n</ul>\n<h3 id=\"多态原理解析\"><a href=\"#多态原理解析\" class=\"headerlink\" title=\"多态原理解析\"></a>多态原理解析</h3><ul>\n<li><p>当父类中有了虚函数后，内部结构就发生了改变</p>\n</li>\n<li><p>内部多了一个 vfprt(virtual  function pointer)<strong>虚函数表指针</strong>指向 vftable  虚函数表</p>\n</li>\n<li><p>父类中结构  vfptr     &amp;Animal::speak</p>\n</li>\n<li><p>子类中 进行继承 会继承 vfptr  vftable</p>\n</li>\n<li><p>构造函数中 会将虚函数表指针 指向自己的虚函数表</p>\n</li>\n<li><p>如果<strong>发生了重写</strong>，会<strong>替换掉虚函数表</strong>中的原有的speak，改为 &amp;Cat::speak</p>\n</li>\n</ul>\n<h3 id=\"抽象类和纯虚函数\"><a href=\"#抽象类和纯虚函数\" class=\"headerlink\" title=\"抽象类和纯虚函数\"></a>抽象类和纯虚函数</h3><ul>\n<li>纯虚函数写法  virtual void func() = 0;</li>\n<li>抽象类型</li>\n<li><strong>抽象类</strong> <strong>不可以实例化对象</strong></li>\n<li>如果类 继承了抽象类， <strong>必须重写抽象类中的纯虚函数</strong></li>\n</ul>\n<h3 id=\"虚析构和纯虚析构\"><a href=\"#虚析构和纯虚析构\" class=\"headerlink\" title=\"虚析构和纯虚析构\"></a>虚析构和纯虚析构</h3><ul>\n<li>虚析构: virtual ~类名() {}</li>\n<li>解决问题： 通过父类指针指向子类对象释放时候不干净导致的问题(即子类不会执行析构函数)</li>\n<li>纯虚析构函数写法  virtual ~类名() = 0     </li>\n<li>类内声明  类外实现</li>\n<li>如果出现了纯虚析构函数，这个类也算抽象类，<strong>不可以实例化对象</strong></li>\n</ul>\n<h3 id=\"向上类型转换和向下类型转换\"><a href=\"#向上类型转换和向下类型转换\" class=\"headerlink\" title=\"向上类型转换和向下类型转换\"></a>向上类型转换和向下类型转换</h3><ul>\n<li>基类转派生类即<strong>向下类型转换</strong>：不安全的    </li>\n<li>派生类转 基类即向上类型转换：安全    </li>\n<li>如果发生多态总是安全的</li>\n</ul>\n<p>以下为一个虚函数表指针的使用例子</p>\n<p>定义父类Animal和子类Dog，使用虚函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//动态联编，讲speak方法写为虚函数</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Animal speak!!!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Animal eat!!!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> :</span><span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Dog speak!!!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Dog eat!!!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个Dog类的对象</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog dog<span class=\"comment\">;</span></span><br><span class=\"line\">//doSpeak(dog)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>主要操作</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">// 这是函数指针(void(*)())\t</span></span><br><span class=\"line\">\t<span class=\"comment\">//通过dog对象地址找到虚函数表内的函数地址执行等同doSpeak(dog)的操作</span></span><br><span class=\"line\">\t((void<span class=\"comment\">(*)()) * (int*)</span> * (int*)(&amp;dog))();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 进阶，虚函数表中有两个函数地址，现在通过编译器方式找到第二个函数的地址并且执行</span></span><br><span class=\"line\">\t((void<span class=\"comment\">(*)())(*((int*)</span> * (int*)(&amp;dog) + <span class=\"number\">1</span>)))();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>若父类还有其他变量，则获得虚函数指针时要多进行一次偏移操作。<br><a href=\"https://miao.su/image/T7RU5\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/27/0a74dbfa5e2bed1596b9d9d96b14703548ce.png\" alt=\"0a74dbfa5e2bed1596b9d9d96b14703548ce.png\"></a></p>\n<p>PS:轮子哥nb</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-15\"><a href=\"#Holiday-Note-15\" class=\"headerlink\" title=\"Holiday Note_15\"></a>Holiday Note_15</h1><p><strong>继承</strong>，<strong>多态</strong>，<strong>虚基类</strong>，<strong>虚函数</strong>，<strong>纯虚析构函数</strong>，<strong>虚函数指针</strong>，<strong>虚析构函数</strong>，<strong>纯虚析构函数</strong>，还有最搞笑的羊驼(草泥马)——<strong>菱形继承(钻石继承)</strong>🤣。不得不说C++的这些名词取得真有意思。</p>\n<p>要自个直接去取虚函数指针找虚函数表里边的函数地址来调用的话，不用Developer Commond prompt看下类的结构真的不好下手。。。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((<span class=\"name\">void</span>(<span class=\"name\"><span class=\"builtin-name\">*</span></span>)())(<span class=\"name\"><span class=\"builtin-name\">*</span></span>((<span class=\"name\">int*</span>)*(<span class=\"name\">int*</span>)(<span class=\"name\">&amp;dog</span>) + <span class=\"number\">1</span>)))()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>","more":"<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>使用VS的Developer Commond prompt进入当前工程的目录下，输入命令</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">cl</span> /<span class=\"built_in\">d1</span> reportSingleClassLayout类名 文件名</span><br></pre></td></tr></table></figure>\n\n<p>可以查看类的模型，继承关系，sizeof的大小，虚函数表等。</p>\n<ul>\n<li>子类会继承父类中所有的内容 ，包括了 私有属性</li>\n<li>只是我们访问不到，编译器给隐藏了</li>\n</ul>\n<h3 id=\"派生类访问控制\"><a href=\"#派生类访问控制\" class=\"headerlink\" title=\"派生类访问控制\"></a>派生类访问控制</h3><p><a href=\"https://miao.su/image/T7vXU\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/27/36deebef62d3c08613e64.md.png\" alt=\"36deebef62d3c08613e64.md.png\"></a></p>\n<h3 id=\"继承中的构造和析构顺序\"><a href=\"#继承中的构造和析构顺序\" class=\"headerlink\" title=\"继承中的构造和析构顺序\"></a>继承中的构造和析构顺序</h3><ul>\n<li>子类对象在创建时会首先调用父类的构造函数</li>\n<li>父类构造函数执行完毕后，才会调用子类的构造函数</li>\n<li>当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数</li>\n<li>析构函数调用顺序和构造函数相反</li>\n<li>如果<strong>父类中没有合适默认构造</strong>，那么子类可以利用<strong>初始化列表</strong>的方式显示的调用父类的其他构造</li>\n</ul>\n<h3 id=\"继承中同名成员和函数的处理方法\"><a href=\"#继承中同名成员和函数的处理方法\" class=\"headerlink\" title=\"继承中同名成员和函数的处理方法\"></a>继承中同名成员和函数的处理方法</h3><ul>\n<li><p>当子类成员和父类成员同名时，子类依然从父类继承同名成员</p>\n</li>\n<li><p>如果子类有成员和父类同名，子类访问其成员默认访问子类的成员(本作用域，就近原则)</p>\n</li>\n<li><p>在子类通过作用域::进行同名成员区分(在派生类中使用基类的同名成员，显示使用类名限定符)</p>\n</li>\n<li><p>静态成员和函数的处理方法类似    </p>\n</li>\n</ul>\n<h3 id=\"多继承-amp-amp-菱形继承\"><a href=\"#多继承-amp-amp-菱形继承\" class=\"headerlink\" title=\"多继承&amp;&amp;菱形继承\"></a>多继承&amp;&amp;菱形继承</h3><p>写法</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> : <span class=\"type\">public B1</span>, <span class=\"type\">public B2</span>,<span class=\"type\"></span></span></span><br></pre></td></tr></table></figure>\n\n<p>避免二义性问题，使用作用域::进行成员和函数的使用。</p>\n<h3 id=\"菱形继承\"><a href=\"#菱形继承\" class=\"headerlink\" title=\"菱形继承\"></a>菱形继承</h3><p><a href=\"https://miao.su/image/T7zO8\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/27/cnm88b84.jpg\" alt=\"cnm88b84.jpg\"></a></p>\n<p>譬如羊驼这种继承羊类和驼类，而羊类和驼类又继承于动物类。以上所有类均有m_Age，则羊驼内部实质有两份m_Age的数据。要<strong>避免数据重复</strong>需要使用到<strong>虚基类</strong>。</p>\n<p>在定义羊类和驼类使用<strong>虚基类</strong>的方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BigBase</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tBigBase()&#123; mParam = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"BigBase::func\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mParam;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base1</span> :</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> BigBase&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base2</span> :</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> BigBase&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span> :</span> <span class=\"keyword\">public</span> Base1, <span class=\"keyword\">public</span> Base2&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://miao.su/image/T7oKM\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/27/vbptrbc5e0.png\" alt=\"vbptrbc5e0.png\"></a></p>\n<ul>\n<li>Base1和Base2通过虚继承的方式派生自BigBase,这两个对象的布局图中可以看出编译器为我们的对象中增加了一个vbptr (virtual base pointer),vbptr指向了一张表，这张表保存了当前的虚指针相对于虚基类的首地址的偏移量。</li>\n<li>Derived派生于Base1和Base2,继承了两个基类的vbptr指针，并调整了vbptr与虚基类的首地址的偏移量找到共有的数据。</li>\n</ul>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p><strong>父类的引用或指针指向子类对象</strong></p>\n<h3 id=\"静态联编和动态联编\"><a href=\"#静态联编和动态联编\" class=\"headerlink\" title=\"静态联编和动态联编\"></a>静态联编和动态联编</h3><p>多态分类</p>\n<ul>\n<li>静态多态  函数重载</li>\n<li>动态多态 虚函数 继承关系</li>\n<li>静态联编</li>\n<li>地址早绑定 编译阶段绑定好地址</li>\n</ul>\n<p>动态联编 </p>\n<ul>\n<li>地址晚绑定 ，运行时候绑定好地址</li>\n</ul>\n<h3 id=\"多态原理解析\"><a href=\"#多态原理解析\" class=\"headerlink\" title=\"多态原理解析\"></a>多态原理解析</h3><ul>\n<li><p>当父类中有了虚函数后，内部结构就发生了改变</p>\n</li>\n<li><p>内部多了一个 vfprt(virtual  function pointer)<strong>虚函数表指针</strong>指向 vftable  虚函数表</p>\n</li>\n<li><p>父类中结构  vfptr     &amp;Animal::speak</p>\n</li>\n<li><p>子类中 进行继承 会继承 vfptr  vftable</p>\n</li>\n<li><p>构造函数中 会将虚函数表指针 指向自己的虚函数表</p>\n</li>\n<li><p>如果<strong>发生了重写</strong>，会<strong>替换掉虚函数表</strong>中的原有的speak，改为 &amp;Cat::speak</p>\n</li>\n</ul>\n<h3 id=\"抽象类和纯虚函数\"><a href=\"#抽象类和纯虚函数\" class=\"headerlink\" title=\"抽象类和纯虚函数\"></a>抽象类和纯虚函数</h3><ul>\n<li>纯虚函数写法  virtual void func() = 0;</li>\n<li>抽象类型</li>\n<li><strong>抽象类</strong> <strong>不可以实例化对象</strong></li>\n<li>如果类 继承了抽象类， <strong>必须重写抽象类中的纯虚函数</strong></li>\n</ul>\n<h3 id=\"虚析构和纯虚析构\"><a href=\"#虚析构和纯虚析构\" class=\"headerlink\" title=\"虚析构和纯虚析构\"></a>虚析构和纯虚析构</h3><ul>\n<li>虚析构: virtual ~类名() {}</li>\n<li>解决问题： 通过父类指针指向子类对象释放时候不干净导致的问题(即子类不会执行析构函数)</li>\n<li>纯虚析构函数写法  virtual ~类名() = 0     </li>\n<li>类内声明  类外实现</li>\n<li>如果出现了纯虚析构函数，这个类也算抽象类，<strong>不可以实例化对象</strong></li>\n</ul>\n<h3 id=\"向上类型转换和向下类型转换\"><a href=\"#向上类型转换和向下类型转换\" class=\"headerlink\" title=\"向上类型转换和向下类型转换\"></a>向上类型转换和向下类型转换</h3><ul>\n<li>基类转派生类即<strong>向下类型转换</strong>：不安全的    </li>\n<li>派生类转 基类即向上类型转换：安全    </li>\n<li>如果发生多态总是安全的</li>\n</ul>\n<p>以下为一个虚函数表指针的使用例子</p>\n<p>定义父类Animal和子类Dog，使用虚函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//动态联编，讲speak方法写为虚函数</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Animal speak!!!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Animal eat!!!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> :</span><span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Dog speak!!!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Dog eat!!!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个Dog类的对象</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog dog<span class=\"comment\">;</span></span><br><span class=\"line\">//doSpeak(dog)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>主要操作</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">// 这是函数指针(void(*)())\t</span></span><br><span class=\"line\">\t<span class=\"comment\">//通过dog对象地址找到虚函数表内的函数地址执行等同doSpeak(dog)的操作</span></span><br><span class=\"line\">\t((void<span class=\"comment\">(*)()) * (int*)</span> * (int*)(&amp;dog))();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 进阶，虚函数表中有两个函数地址，现在通过编译器方式找到第二个函数的地址并且执行</span></span><br><span class=\"line\">\t((void<span class=\"comment\">(*)())(*((int*)</span> * (int*)(&amp;dog) + <span class=\"number\">1</span>)))();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>若父类还有其他变量，则获得虚函数指针时要多进行一次偏移操作。<br><a href=\"https://miao.su/image/T7RU5\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/27/0a74dbfa5e2bed1596b9d9d96b14703548ce.png\" alt=\"0a74dbfa5e2bed1596b9d9d96b14703548ce.png\"></a></p>\n<p>PS:轮子哥nb</p>"},{"title":"Holiday Note_16","date":"2019-07-28T13:25:16.000Z","_content":"\n# Holiday Note_16\n\n终于接触到了C++的**模板机制**。\n> 《C++ Primer Plus》： 模板提供参数化(parameterized)类型，即能够将类型名作为参数传递给接收方来建立类或函数\n\n<!-- more -->\n\n## 函数模板\n\n### 定义及写法\n\n简单来说，函数模板便是让函数的参数类型不再固定，而是让数据类型也参数化，即可以根据不同的数据类型进行转化从而达到函数重用的功能。\n\n> C++提供了函数模板(function template.)所谓函数模板，实际上是建立一个**通用函数**，其**函数类型和形参类型不具体制定**，用一个虚拟的类型来代表。这个通用函数就成为函数模板。凡是函数体相同的函数都可以用这个模板代替，不必定义多个函数，只需在模板中定义一次即可。在**调用函数时系统会根据实参的类型来取代模板中的虚拟类型**，从而实现不同函数的功能。\n\n> \t模板把函数或类要处理的数据类型参数化，表现为**参数的多态性**，成为**类属**。\n>\t模板用于表达**逻辑结构相同**，但具体**数据元素类型不同**的数据对象的通用行为。\n\n---\n\n一个交换函数，在不使用函数模板前，需要对int型数据写一个swap函数，对double型数据写一个swap函数...而代码除了数据类型的不同，核心的代码几乎一致。\n\n而使用函数模板，定义一个类型T(**定义的这个类型T只对其后的唯一一个类或函数生效**)，将数据类型参数化，可以大大的增强函数的重用性。\n~~~\ntemplate<class T>\nvoid MySwap(T& a,T& b){\n\tT temp = a;\n\ta = b;\n\tb = temp;\n}\n~~~\n调用时，函数模板可以自动推导参数的类型\n~~~\nint a = 10;\nint b = 20;\nMySwap(a,b);\n~~~\n也可以显式指定类型\n~~~\nchar c1 = 'a';\nchar c2 = 'b';\nMySwap<char>(c1, c2);\n~~~\n\n---\n\n### 与普通函数的区别\n-\t函数模板**不允许自动类型转化**\n-\t普通函数能够自动进行类型转化\n\n即定义一个int类型的变量a和一个char类型的b，使用swap函数时，若使用普通函数的情况下，参数为int时，char类型的b会转换为ASCLL码的int数值进行比较；而模板函数必须严格匹配类型。\n\n---\n\n### 函数模板和普通函数在一起调用规则\n-\tc++编译器**优先考虑普通函数**\n-\t可以通过**空模板实参列表**的语法**限定编译器只能通过模板匹配**(如swap<>(a, b))\n-\t函数模板**可以**像普通函数那样可以被**重载**\n-\t如果函数模板可以产生一个**更好的匹配**(即在普通函数需要进行类型转换时)，那么选择模板\n\n---\n\n### 函数模板机制\n\n-\t编译器并不是把函数模板处理成能够处理任何类型的函数\n-\t函数模板通过具体类型产生不同的函数\n-\t**编译器会对函数模板进行两次编译**，在**声明**的地方对模板代码本身进行编译，在**调用**的地方对参数替换后的代码进行编译。\n\n **但是**，编写的模板函数无法处理自定义类型，因此需要通过对模板函数进行**重载**，提供**具体化模板**。\n\n比如这样一个自定义的Person类，编译器无法处理，需要对模板进行**第三代具体化实现数据类型的匹配**\n~~~\nclass Person {\npublic:\n\tint m_Age;\n\tstring m_Name;\n};\n~~~\n函数模板\n~~~\ntemplate<class T>\nbool myCompare(T& a, T& b) {\n\tif (a == b) {\n\t\treturn true;\n\t}\n\telse return false;\n}\n~~~\n具体化模板写法为**template<> 返回值 函数名<具体类型>(参数类型)**\n~~~\ntemplate<> bool myCompare<Person>(Person& a, Person& b) {\n\tif (a.m_Age == b.m_Age && a.m_Name == b.m_Name) {\n\t\treturn true;\n\t}\n\telse return false;\n}\n~~~\n\n---\n\n## 类模板\n\n### 写法\n\n和函数模板类似，类模板是让类中的数据类型参数化\n\n类模板中的**成员函数** 一开始不会创建出来，而是在**运行时才去创建**\n~~~\ntemplate<class NameType, class AgeType>\nclass Person\n{\npublic:\n\tNameType mName;\n\tAgeType mAge;\n};\n~~~\n但是要注意的是：**类模板不能进行类型自动推导**，需要<>提供参数列表\n~~~\nvoid test01()\n{\n\tPerson<string, int>P1(\"AAA\", 10);\n\tP1.showPerson();\n}\n~~~\n\n类模板类内定义，类外实现时，需要在实现前加template等，作用域前还要加参数列表。\n~~~\n//构造函数\ntemplate<class T1, class T2>\nPerson<T1, T2>::Person(T1 name, T2 age){\n\tthis->mName = name;\n\tthis->mAge = age;\n}\n~~~\n\n---\n\n### 子类继承类模板\n父类类模板\n~~~\ntemplate<class T>\nclass Base\n{\n\tT m;\n};\n~~~\n继承类模板的时候，必须要确定基类的大小。即在基类名后加<类型>\n~~~\ntemplate<class T >\nclass Child2 : public Base<double>\n{\npublic:\n\tT mParam;\n};\n~~~\n\n---\n\n###\t类模板做函数参数的三种方式\t\n-\t显示指定类型\n-\t参数模板化\n-\t整体模板化\n\n针对Person类中的showPerson方法，以下为类模板做参数的三种方式\n\n指定传入类型(即普通函数，编译器优先调用)\n~~~\nvoid doWork(Person<string, int>& p) {\n\tp.showPerson();\n}\n~~~\n参数模板化\n~~~\n\ntemplate<class T1,class T2>\nvoid doWork(Person<T1,T2>& p) {\n\tp.showPerson();\n}\n~~~\n整体模板化\n~~~\ntemplate<class T>\nvoid doWork(T& p) {\n\tp.showPerson();\n}\n~~~\n\n---\n\n### 类模板分文件编写\n\n\n1. 问题\n-  .h .cpp分别写声明和实现\n-\t但是由于类模板的成员函数运行阶段才去创建，导致包含.h头文件，不会创建函数的实现，**无法解析外部命令**\n2.\t解决方案（不推荐导入.cpp文件 ）\n-\t不要进行分文件编写，写到同一个文件中，进行声明和实现，后缀名改为**.hpp**\n\n\n\n\n查看类型名称的方法\n~~~\ncout << typeid(T).name() << endl;\n~~~\n\n---\n\n### 类模板与友元函数\n\n1.\t友元函数类内实现\n-\tfriend void printPerson( Person<T1 ,T2> & p ) \n2. 友元函数类外实现（较为复杂）\n-\tfriend void printPerson<>(Person<T1, T2> & p); //没有**<>**仅为**普通函数**因此**加上<>模板函数声明**\n-\t而由于这个**函数在类内**，编译器**编译时无法看到**，因此需要在**类外声明**函数并且看到这个Person类型(也是在类外提前声明)\n\n先进行类外声明，否则文件编译时链接失败\n~~~\ntemplate<class T1, class T2>class Person;\ntemplate<class T1, class T2>void PrintPerson(Person<T1, T2>& p);\n~~~\n类内声明需要加<>使其变成模板函数声明\n~~~\ntemplate<class T1, class T2>\nclass Person {\npublic:\t\n\tfriend void PrintPerson<>(Person<T1, T2>& p);\n\nprivate:\n\tT1 m_Age;\n\tT2 m_Name;\n};\n~~~\n类外实现\n~~~\ntemplate<class T1, class T2>\nvoid PrintPerson(Person<T1, T2>& p) {\n\tcout << \"Name: \" << p.m_Age << \" Age: \" << p.m_Age << endl;\n}\n~~~\n\nPS:颤抖的手点下了付款。\n","source":"_posts/2019-Holiday-Note-16.md","raw":"---\ntitle: Holiday Note_16\ndate: 2019-07-28 21:25:16\ncategories: C++\ntags: [Note,C++]\n---\n\n# Holiday Note_16\n\n终于接触到了C++的**模板机制**。\n> 《C++ Primer Plus》： 模板提供参数化(parameterized)类型，即能够将类型名作为参数传递给接收方来建立类或函数\n\n<!-- more -->\n\n## 函数模板\n\n### 定义及写法\n\n简单来说，函数模板便是让函数的参数类型不再固定，而是让数据类型也参数化，即可以根据不同的数据类型进行转化从而达到函数重用的功能。\n\n> C++提供了函数模板(function template.)所谓函数模板，实际上是建立一个**通用函数**，其**函数类型和形参类型不具体制定**，用一个虚拟的类型来代表。这个通用函数就成为函数模板。凡是函数体相同的函数都可以用这个模板代替，不必定义多个函数，只需在模板中定义一次即可。在**调用函数时系统会根据实参的类型来取代模板中的虚拟类型**，从而实现不同函数的功能。\n\n> \t模板把函数或类要处理的数据类型参数化，表现为**参数的多态性**，成为**类属**。\n>\t模板用于表达**逻辑结构相同**，但具体**数据元素类型不同**的数据对象的通用行为。\n\n---\n\n一个交换函数，在不使用函数模板前，需要对int型数据写一个swap函数，对double型数据写一个swap函数...而代码除了数据类型的不同，核心的代码几乎一致。\n\n而使用函数模板，定义一个类型T(**定义的这个类型T只对其后的唯一一个类或函数生效**)，将数据类型参数化，可以大大的增强函数的重用性。\n~~~\ntemplate<class T>\nvoid MySwap(T& a,T& b){\n\tT temp = a;\n\ta = b;\n\tb = temp;\n}\n~~~\n调用时，函数模板可以自动推导参数的类型\n~~~\nint a = 10;\nint b = 20;\nMySwap(a,b);\n~~~\n也可以显式指定类型\n~~~\nchar c1 = 'a';\nchar c2 = 'b';\nMySwap<char>(c1, c2);\n~~~\n\n---\n\n### 与普通函数的区别\n-\t函数模板**不允许自动类型转化**\n-\t普通函数能够自动进行类型转化\n\n即定义一个int类型的变量a和一个char类型的b，使用swap函数时，若使用普通函数的情况下，参数为int时，char类型的b会转换为ASCLL码的int数值进行比较；而模板函数必须严格匹配类型。\n\n---\n\n### 函数模板和普通函数在一起调用规则\n-\tc++编译器**优先考虑普通函数**\n-\t可以通过**空模板实参列表**的语法**限定编译器只能通过模板匹配**(如swap<>(a, b))\n-\t函数模板**可以**像普通函数那样可以被**重载**\n-\t如果函数模板可以产生一个**更好的匹配**(即在普通函数需要进行类型转换时)，那么选择模板\n\n---\n\n### 函数模板机制\n\n-\t编译器并不是把函数模板处理成能够处理任何类型的函数\n-\t函数模板通过具体类型产生不同的函数\n-\t**编译器会对函数模板进行两次编译**，在**声明**的地方对模板代码本身进行编译，在**调用**的地方对参数替换后的代码进行编译。\n\n **但是**，编写的模板函数无法处理自定义类型，因此需要通过对模板函数进行**重载**，提供**具体化模板**。\n\n比如这样一个自定义的Person类，编译器无法处理，需要对模板进行**第三代具体化实现数据类型的匹配**\n~~~\nclass Person {\npublic:\n\tint m_Age;\n\tstring m_Name;\n};\n~~~\n函数模板\n~~~\ntemplate<class T>\nbool myCompare(T& a, T& b) {\n\tif (a == b) {\n\t\treturn true;\n\t}\n\telse return false;\n}\n~~~\n具体化模板写法为**template<> 返回值 函数名<具体类型>(参数类型)**\n~~~\ntemplate<> bool myCompare<Person>(Person& a, Person& b) {\n\tif (a.m_Age == b.m_Age && a.m_Name == b.m_Name) {\n\t\treturn true;\n\t}\n\telse return false;\n}\n~~~\n\n---\n\n## 类模板\n\n### 写法\n\n和函数模板类似，类模板是让类中的数据类型参数化\n\n类模板中的**成员函数** 一开始不会创建出来，而是在**运行时才去创建**\n~~~\ntemplate<class NameType, class AgeType>\nclass Person\n{\npublic:\n\tNameType mName;\n\tAgeType mAge;\n};\n~~~\n但是要注意的是：**类模板不能进行类型自动推导**，需要<>提供参数列表\n~~~\nvoid test01()\n{\n\tPerson<string, int>P1(\"AAA\", 10);\n\tP1.showPerson();\n}\n~~~\n\n类模板类内定义，类外实现时，需要在实现前加template等，作用域前还要加参数列表。\n~~~\n//构造函数\ntemplate<class T1, class T2>\nPerson<T1, T2>::Person(T1 name, T2 age){\n\tthis->mName = name;\n\tthis->mAge = age;\n}\n~~~\n\n---\n\n### 子类继承类模板\n父类类模板\n~~~\ntemplate<class T>\nclass Base\n{\n\tT m;\n};\n~~~\n继承类模板的时候，必须要确定基类的大小。即在基类名后加<类型>\n~~~\ntemplate<class T >\nclass Child2 : public Base<double>\n{\npublic:\n\tT mParam;\n};\n~~~\n\n---\n\n###\t类模板做函数参数的三种方式\t\n-\t显示指定类型\n-\t参数模板化\n-\t整体模板化\n\n针对Person类中的showPerson方法，以下为类模板做参数的三种方式\n\n指定传入类型(即普通函数，编译器优先调用)\n~~~\nvoid doWork(Person<string, int>& p) {\n\tp.showPerson();\n}\n~~~\n参数模板化\n~~~\n\ntemplate<class T1,class T2>\nvoid doWork(Person<T1,T2>& p) {\n\tp.showPerson();\n}\n~~~\n整体模板化\n~~~\ntemplate<class T>\nvoid doWork(T& p) {\n\tp.showPerson();\n}\n~~~\n\n---\n\n### 类模板分文件编写\n\n\n1. 问题\n-  .h .cpp分别写声明和实现\n-\t但是由于类模板的成员函数运行阶段才去创建，导致包含.h头文件，不会创建函数的实现，**无法解析外部命令**\n2.\t解决方案（不推荐导入.cpp文件 ）\n-\t不要进行分文件编写，写到同一个文件中，进行声明和实现，后缀名改为**.hpp**\n\n\n\n\n查看类型名称的方法\n~~~\ncout << typeid(T).name() << endl;\n~~~\n\n---\n\n### 类模板与友元函数\n\n1.\t友元函数类内实现\n-\tfriend void printPerson( Person<T1 ,T2> & p ) \n2. 友元函数类外实现（较为复杂）\n-\tfriend void printPerson<>(Person<T1, T2> & p); //没有**<>**仅为**普通函数**因此**加上<>模板函数声明**\n-\t而由于这个**函数在类内**，编译器**编译时无法看到**，因此需要在**类外声明**函数并且看到这个Person类型(也是在类外提前声明)\n\n先进行类外声明，否则文件编译时链接失败\n~~~\ntemplate<class T1, class T2>class Person;\ntemplate<class T1, class T2>void PrintPerson(Person<T1, T2>& p);\n~~~\n类内声明需要加<>使其变成模板函数声明\n~~~\ntemplate<class T1, class T2>\nclass Person {\npublic:\t\n\tfriend void PrintPerson<>(Person<T1, T2>& p);\n\nprivate:\n\tT1 m_Age;\n\tT2 m_Name;\n};\n~~~\n类外实现\n~~~\ntemplate<class T1, class T2>\nvoid PrintPerson(Person<T1, T2>& p) {\n\tcout << \"Name: \" << p.m_Age << \" Age: \" << p.m_Age << endl;\n}\n~~~\n\nPS:颤抖的手点下了付款。\n","slug":"2019-Holiday-Note-16","published":1,"updated":"2019-07-28T15:55:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihr001bsmjbyed83rze","content":"<h1 id=\"Holiday-Note-16\"><a href=\"#Holiday-Note-16\" class=\"headerlink\" title=\"Holiday Note_16\"></a>Holiday Note_16</h1><p>终于接触到了C++的<strong>模板机制</strong>。</p>\n<blockquote>\n<p>《C++ Primer Plus》： 模板提供参数化(parameterized)类型，即能够将类型名作为参数传递给接收方来建立类或函数</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h2 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h2><h3 id=\"定义及写法\"><a href=\"#定义及写法\" class=\"headerlink\" title=\"定义及写法\"></a>定义及写法</h3><p>简单来说，函数模板便是让函数的参数类型不再固定，而是让数据类型也参数化，即可以根据不同的数据类型进行转化从而达到函数重用的功能。</p>\n<blockquote>\n<p>C++提供了函数模板(function template.)所谓函数模板，实际上是建立一个<strong>通用函数</strong>，其<strong>函数类型和形参类型不具体制定</strong>，用一个虚拟的类型来代表。这个通用函数就成为函数模板。凡是函数体相同的函数都可以用这个模板代替，不必定义多个函数，只需在模板中定义一次即可。在<strong>调用函数时系统会根据实参的类型来取代模板中的虚拟类型</strong>，从而实现不同函数的功能。</p>\n</blockquote>\n<blockquote>\n<pre><code>模板把函数或类要处理的数据类型参数化，表现为**参数的多态性**，成为**类属**。</code></pre><p>   模板用于表达<strong>逻辑结构相同</strong>，但具体<strong>数据元素类型不同</strong>的数据对象的通用行为。</p>\n</blockquote>\n<hr>\n<p>一个交换函数，在不使用函数模板前，需要对int型数据写一个swap函数，对double型数据写一个swap函数…而代码除了数据类型的不同，核心的代码几乎一致。</p>\n<p>而使用函数模板，定义一个类型T(<strong>定义的这个类型T只对其后的唯一一个类或函数生效</strong>)，将数据类型参数化，可以大大的增强函数的重用性。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">void MySwap(T&amp; a,T&amp; <span class=\"keyword\">b)&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">\t</span>T temp = a<span class=\"comment\">;</span></span><br><span class=\"line\">\ta = <span class=\"keyword\">b;</span></span><br><span class=\"line\"><span class=\"keyword\">\t</span><span class=\"keyword\">b </span>= temp<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用时，函数模板可以自动推导参数的类型</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = <span class=\"number\">10</span><span class=\"comment\">;</span></span><br><span class=\"line\">int <span class=\"keyword\">b </span>= <span class=\"number\">20</span><span class=\"comment\">;</span></span><br><span class=\"line\">MySwap(a,<span class=\"keyword\">b);</span></span><br></pre></td></tr></table></figure>\n\n<p>也可以显式指定类型</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">char</span> c1 = <span class=\"comment\">'a';</span></span><br><span class=\"line\"><span class=\"built_in\">char</span> c2 = <span class=\"comment\">'b';</span></span><br><span class=\"line\">MySwap&lt;<span class=\"built_in\">char</span>&gt;(c1, c2);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"与普通函数的区别\"><a href=\"#与普通函数的区别\" class=\"headerlink\" title=\"与普通函数的区别\"></a>与普通函数的区别</h3><ul>\n<li>函数模板<strong>不允许自动类型转化</strong></li>\n<li>普通函数能够自动进行类型转化</li>\n</ul>\n<p>即定义一个int类型的变量a和一个char类型的b，使用swap函数时，若使用普通函数的情况下，参数为int时，char类型的b会转换为ASCLL码的int数值进行比较；而模板函数必须严格匹配类型。</p>\n<hr>\n<h3 id=\"函数模板和普通函数在一起调用规则\"><a href=\"#函数模板和普通函数在一起调用规则\" class=\"headerlink\" title=\"函数模板和普通函数在一起调用规则\"></a>函数模板和普通函数在一起调用规则</h3><ul>\n<li>c++编译器<strong>优先考虑普通函数</strong></li>\n<li>可以通过<strong>空模板实参列表</strong>的语法<strong>限定编译器只能通过模板匹配</strong>(如swap&lt;&gt;(a, b))</li>\n<li>函数模板<strong>可以</strong>像普通函数那样可以被<strong>重载</strong></li>\n<li>如果函数模板可以产生一个<strong>更好的匹配</strong>(即在普通函数需要进行类型转换时)，那么选择模板</li>\n</ul>\n<hr>\n<h3 id=\"函数模板机制\"><a href=\"#函数模板机制\" class=\"headerlink\" title=\"函数模板机制\"></a>函数模板机制</h3><ul>\n<li><p>编译器并不是把函数模板处理成能够处理任何类型的函数</p>\n</li>\n<li><p>函数模板通过具体类型产生不同的函数</p>\n</li>\n<li><p><strong>编译器会对函数模板进行两次编译</strong>，在<strong>声明</strong>的地方对模板代码本身进行编译，在<strong>调用</strong>的地方对参数替换后的代码进行编译。</p>\n<p><strong>但是</strong>，编写的模板函数无法处理自定义类型，因此需要通过对模板函数进行<strong>重载</strong>，提供<strong>具体化模板</strong>。</p>\n</li>\n</ul>\n<p>比如这样一个自定义的Person类，编译器无法处理，需要对模板进行<strong>第三代具体化实现数据类型的匹配</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_Age;</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> m_Name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>函数模板</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\">bool myCompare(T&amp; a, T&amp; b) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a == b) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体化模板写法为<strong>template&lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数类型)</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt; <span class=\"keyword\">bool</span> myCompare&lt;Person&gt;(Person&amp; a, Person&amp; b) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a.m_Age == b.m_Age &amp;&amp; a.m_Name == b.m_Name) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><h3 id=\"写法\"><a href=\"#写法\" class=\"headerlink\" title=\"写法\"></a>写法</h3><p>和函数模板类似，类模板是让类中的数据类型参数化</p>\n<p>类模板中的<strong>成员函数</strong> 一开始不会创建出来，而是在<strong>运行时才去创建</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameType</span>, <span class=\"type\">class AgeType&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNameType mName;</span><br><span class=\"line\">\tAgeType mAge;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>但是要注意的是：<strong>类模板不能进行类型自动推导</strong>，需要&lt;&gt;提供参数列表</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tPerson&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">int</span>&gt;P1(<span class=\"string\">\"AAA\"</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">\tP1.showPerson();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类模板类内定义，类外实现时，需要在实现前加template等，作用域前还要加参数列表。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造函数</span></span><br><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span>, <span class=\"type\">class T2&gt;</span></span></span><br><span class=\"line\">Person&lt;T1, T2&gt;::Person(T1 name, T2 age)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;mName = name;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;mAge = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"子类继承类模板\"><a href=\"#子类继承类模板\" class=\"headerlink\" title=\"子类继承类模板\"></a>子类继承类模板</h3><p>父类类模板</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT m;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>继承类模板的时候，必须要确定基类的大小。即在基类名后加&lt;类型&gt;</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span> &gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Child2</span> :</span> <span class=\"keyword\">public</span> Base&lt;<span class=\"keyword\">double</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tT mParam;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"类模板做函数参数的三种方式\"><a href=\"#类模板做函数参数的三种方式\" class=\"headerlink\" title=\"类模板做函数参数的三种方式\"></a>类模板做函数参数的三种方式</h3><ul>\n<li>显示指定类型</li>\n<li>参数模板化</li>\n<li>整体模板化</li>\n</ul>\n<p>针对Person类中的showPerson方法，以下为类模板做参数的三种方式</p>\n<p>指定传入类型(即普通函数，编译器优先调用)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">(Person&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class=\"line\">\tp.showPerson();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参数模板化</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">template&lt;class <span class=\"built_in\">T1</span>,class <span class=\"built_in\">T2</span>&gt;</span><br><span class=\"line\">void doWork(Person&lt;<span class=\"built_in\">T1</span>,<span class=\"built_in\">T2</span>&gt;&amp; p) &#123;</span><br><span class=\"line\">\tp.<span class=\"keyword\">showPerson();</span></span><br><span class=\"line\"><span class=\"keyword\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>整体模板化</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">doWork</span>(<span class=\"title\">T</span>&amp; <span class=\"title\">p</span>) &#123;</span></span><br><span class=\"line\">\tp.showPerson();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"类模板分文件编写\"><a href=\"#类模板分文件编写\" class=\"headerlink\" title=\"类模板分文件编写\"></a>类模板分文件编写</h3><ol>\n<li>问题</li>\n</ol>\n<ul>\n<li>.h .cpp分别写声明和实现</li>\n<li>但是由于类模板的成员函数运行阶段才去创建，导致包含.h头文件，不会创建函数的实现，<strong>无法解析外部命令</strong></li>\n</ul>\n<ol start=\"2\">\n<li>解决方案（不推荐导入.cpp文件 ）</li>\n</ol>\n<ul>\n<li>不要进行分文件编写，写到同一个文件中，进行声明和实现，后缀名改为<strong>.hpp</strong></li>\n</ul>\n<p>查看类型名称的方法</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">cout</span> &lt;&lt; typeid(<span class=\"type\">T</span>).name() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"类模板与友元函数\"><a href=\"#类模板与友元函数\" class=\"headerlink\" title=\"类模板与友元函数\"></a>类模板与友元函数</h3><ol>\n<li>友元函数类内实现</li>\n</ol>\n<ul>\n<li>friend void printPerson( Person&lt;T1 ,T2&gt; &amp; p ) </li>\n</ul>\n<ol start=\"2\">\n<li>友元函数类外实现（较为复杂）</li>\n</ol>\n<ul>\n<li>friend void printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp; p); //没有<strong>&lt;&gt;</strong>仅为<strong>普通函数</strong>因此<strong>加上&lt;&gt;模板函数声明</strong></li>\n<li>而由于这个<strong>函数在类内</strong>，编译器<strong>编译时无法看到</strong>，因此需要在<strong>类外声明</strong>函数并且看到这个Person类型(也是在类外提前声明)</li>\n</ul>\n<p>先进行类外声明，否则文件编译时链接失败</p>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T1, <span class=\"keyword\">class</span> T2&gt;<span class=\"keyword\">class</span> Person;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T1, <span class=\"keyword\">class</span> T2&gt;<span class=\"keyword\">void</span> PrintPerson(Person&lt;T1, T2&gt;&amp; p);</span><br></pre></td></tr></table></figure>\n\n<p>类内声明需要加&lt;&gt;使其变成模板函数声明</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class <span class=\"built_in\">T1</span>, class <span class=\"built_in\">T2</span>&gt;</span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\"><span class=\"symbol\">public:</span>\t</span><br><span class=\"line\">\tfriend void PrintPerson&lt;&gt;(Person&lt;<span class=\"built_in\">T1</span>, <span class=\"built_in\">T2</span>&gt;&amp; p)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">private:</span></span><br><span class=\"line\">\t<span class=\"built_in\">T1</span> m_Age<span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"built_in\">T2</span> m_Name<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>类外实现</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span>, <span class=\"title\">class</span> <span class=\"title\">T2</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">PrintPerson</span>(<span class=\"title\">Person</span>&lt;T1, T2&gt;&amp; <span class=\"title\">p</span>) &#123;</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Name: \"</span> &lt;&lt; p.m_Age &lt;&lt; <span class=\"string\">\" Age: \"</span> &lt;&lt; p.m_Age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS:颤抖的手点下了付款。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-16\"><a href=\"#Holiday-Note-16\" class=\"headerlink\" title=\"Holiday Note_16\"></a>Holiday Note_16</h1><p>终于接触到了C++的<strong>模板机制</strong>。</p>\n<blockquote>\n<p>《C++ Primer Plus》： 模板提供参数化(parameterized)类型，即能够将类型名作为参数传递给接收方来建立类或函数</p>\n</blockquote>","more":"<h2 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h2><h3 id=\"定义及写法\"><a href=\"#定义及写法\" class=\"headerlink\" title=\"定义及写法\"></a>定义及写法</h3><p>简单来说，函数模板便是让函数的参数类型不再固定，而是让数据类型也参数化，即可以根据不同的数据类型进行转化从而达到函数重用的功能。</p>\n<blockquote>\n<p>C++提供了函数模板(function template.)所谓函数模板，实际上是建立一个<strong>通用函数</strong>，其<strong>函数类型和形参类型不具体制定</strong>，用一个虚拟的类型来代表。这个通用函数就成为函数模板。凡是函数体相同的函数都可以用这个模板代替，不必定义多个函数，只需在模板中定义一次即可。在<strong>调用函数时系统会根据实参的类型来取代模板中的虚拟类型</strong>，从而实现不同函数的功能。</p>\n</blockquote>\n<blockquote>\n<pre><code>模板把函数或类要处理的数据类型参数化，表现为**参数的多态性**，成为**类属**。</code></pre><p>   模板用于表达<strong>逻辑结构相同</strong>，但具体<strong>数据元素类型不同</strong>的数据对象的通用行为。</p>\n</blockquote>\n<hr>\n<p>一个交换函数，在不使用函数模板前，需要对int型数据写一个swap函数，对double型数据写一个swap函数…而代码除了数据类型的不同，核心的代码几乎一致。</p>\n<p>而使用函数模板，定义一个类型T(<strong>定义的这个类型T只对其后的唯一一个类或函数生效</strong>)，将数据类型参数化，可以大大的增强函数的重用性。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">void MySwap(T&amp; a,T&amp; <span class=\"keyword\">b)&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">\t</span>T temp = a<span class=\"comment\">;</span></span><br><span class=\"line\">\ta = <span class=\"keyword\">b;</span></span><br><span class=\"line\"><span class=\"keyword\">\t</span><span class=\"keyword\">b </span>= temp<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用时，函数模板可以自动推导参数的类型</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = <span class=\"number\">10</span><span class=\"comment\">;</span></span><br><span class=\"line\">int <span class=\"keyword\">b </span>= <span class=\"number\">20</span><span class=\"comment\">;</span></span><br><span class=\"line\">MySwap(a,<span class=\"keyword\">b);</span></span><br></pre></td></tr></table></figure>\n\n<p>也可以显式指定类型</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">char</span> c1 = <span class=\"comment\">'a';</span></span><br><span class=\"line\"><span class=\"built_in\">char</span> c2 = <span class=\"comment\">'b';</span></span><br><span class=\"line\">MySwap&lt;<span class=\"built_in\">char</span>&gt;(c1, c2);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"与普通函数的区别\"><a href=\"#与普通函数的区别\" class=\"headerlink\" title=\"与普通函数的区别\"></a>与普通函数的区别</h3><ul>\n<li>函数模板<strong>不允许自动类型转化</strong></li>\n<li>普通函数能够自动进行类型转化</li>\n</ul>\n<p>即定义一个int类型的变量a和一个char类型的b，使用swap函数时，若使用普通函数的情况下，参数为int时，char类型的b会转换为ASCLL码的int数值进行比较；而模板函数必须严格匹配类型。</p>\n<hr>\n<h3 id=\"函数模板和普通函数在一起调用规则\"><a href=\"#函数模板和普通函数在一起调用规则\" class=\"headerlink\" title=\"函数模板和普通函数在一起调用规则\"></a>函数模板和普通函数在一起调用规则</h3><ul>\n<li>c++编译器<strong>优先考虑普通函数</strong></li>\n<li>可以通过<strong>空模板实参列表</strong>的语法<strong>限定编译器只能通过模板匹配</strong>(如swap&lt;&gt;(a, b))</li>\n<li>函数模板<strong>可以</strong>像普通函数那样可以被<strong>重载</strong></li>\n<li>如果函数模板可以产生一个<strong>更好的匹配</strong>(即在普通函数需要进行类型转换时)，那么选择模板</li>\n</ul>\n<hr>\n<h3 id=\"函数模板机制\"><a href=\"#函数模板机制\" class=\"headerlink\" title=\"函数模板机制\"></a>函数模板机制</h3><ul>\n<li><p>编译器并不是把函数模板处理成能够处理任何类型的函数</p>\n</li>\n<li><p>函数模板通过具体类型产生不同的函数</p>\n</li>\n<li><p><strong>编译器会对函数模板进行两次编译</strong>，在<strong>声明</strong>的地方对模板代码本身进行编译，在<strong>调用</strong>的地方对参数替换后的代码进行编译。</p>\n<p><strong>但是</strong>，编写的模板函数无法处理自定义类型，因此需要通过对模板函数进行<strong>重载</strong>，提供<strong>具体化模板</strong>。</p>\n</li>\n</ul>\n<p>比如这样一个自定义的Person类，编译器无法处理，需要对模板进行<strong>第三代具体化实现数据类型的匹配</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_Age;</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> m_Name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>函数模板</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\">bool myCompare(T&amp; a, T&amp; b) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a == b) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体化模板写法为<strong>template&lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数类型)</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt; <span class=\"keyword\">bool</span> myCompare&lt;Person&gt;(Person&amp; a, Person&amp; b) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a.m_Age == b.m_Age &amp;&amp; a.m_Name == b.m_Name) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><h3 id=\"写法\"><a href=\"#写法\" class=\"headerlink\" title=\"写法\"></a>写法</h3><p>和函数模板类似，类模板是让类中的数据类型参数化</p>\n<p>类模板中的<strong>成员函数</strong> 一开始不会创建出来，而是在<strong>运行时才去创建</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameType</span>, <span class=\"type\">class AgeType&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNameType mName;</span><br><span class=\"line\">\tAgeType mAge;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>但是要注意的是：<strong>类模板不能进行类型自动推导</strong>，需要&lt;&gt;提供参数列表</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tPerson&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">int</span>&gt;P1(<span class=\"string\">\"AAA\"</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">\tP1.showPerson();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类模板类内定义，类外实现时，需要在实现前加template等，作用域前还要加参数列表。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造函数</span></span><br><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span>, <span class=\"type\">class T2&gt;</span></span></span><br><span class=\"line\">Person&lt;T1, T2&gt;::Person(T1 name, T2 age)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;mName = name;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;mAge = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"子类继承类模板\"><a href=\"#子类继承类模板\" class=\"headerlink\" title=\"子类继承类模板\"></a>子类继承类模板</h3><p>父类类模板</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT m;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>继承类模板的时候，必须要确定基类的大小。即在基类名后加&lt;类型&gt;</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span> &gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Child2</span> :</span> <span class=\"keyword\">public</span> Base&lt;<span class=\"keyword\">double</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tT mParam;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"类模板做函数参数的三种方式\"><a href=\"#类模板做函数参数的三种方式\" class=\"headerlink\" title=\"类模板做函数参数的三种方式\"></a>类模板做函数参数的三种方式</h3><ul>\n<li>显示指定类型</li>\n<li>参数模板化</li>\n<li>整体模板化</li>\n</ul>\n<p>针对Person类中的showPerson方法，以下为类模板做参数的三种方式</p>\n<p>指定传入类型(即普通函数，编译器优先调用)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">(Person&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class=\"line\">\tp.showPerson();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参数模板化</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">template&lt;class <span class=\"built_in\">T1</span>,class <span class=\"built_in\">T2</span>&gt;</span><br><span class=\"line\">void doWork(Person&lt;<span class=\"built_in\">T1</span>,<span class=\"built_in\">T2</span>&gt;&amp; p) &#123;</span><br><span class=\"line\">\tp.<span class=\"keyword\">showPerson();</span></span><br><span class=\"line\"><span class=\"keyword\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>整体模板化</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">doWork</span>(<span class=\"title\">T</span>&amp; <span class=\"title\">p</span>) &#123;</span></span><br><span class=\"line\">\tp.showPerson();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"类模板分文件编写\"><a href=\"#类模板分文件编写\" class=\"headerlink\" title=\"类模板分文件编写\"></a>类模板分文件编写</h3><ol>\n<li>问题</li>\n</ol>\n<ul>\n<li>.h .cpp分别写声明和实现</li>\n<li>但是由于类模板的成员函数运行阶段才去创建，导致包含.h头文件，不会创建函数的实现，<strong>无法解析外部命令</strong></li>\n</ul>\n<ol start=\"2\">\n<li>解决方案（不推荐导入.cpp文件 ）</li>\n</ol>\n<ul>\n<li>不要进行分文件编写，写到同一个文件中，进行声明和实现，后缀名改为<strong>.hpp</strong></li>\n</ul>\n<p>查看类型名称的方法</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">cout</span> &lt;&lt; typeid(<span class=\"type\">T</span>).name() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"类模板与友元函数\"><a href=\"#类模板与友元函数\" class=\"headerlink\" title=\"类模板与友元函数\"></a>类模板与友元函数</h3><ol>\n<li>友元函数类内实现</li>\n</ol>\n<ul>\n<li>friend void printPerson( Person&lt;T1 ,T2&gt; &amp; p ) </li>\n</ul>\n<ol start=\"2\">\n<li>友元函数类外实现（较为复杂）</li>\n</ol>\n<ul>\n<li>friend void printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp; p); //没有<strong>&lt;&gt;</strong>仅为<strong>普通函数</strong>因此<strong>加上&lt;&gt;模板函数声明</strong></li>\n<li>而由于这个<strong>函数在类内</strong>，编译器<strong>编译时无法看到</strong>，因此需要在<strong>类外声明</strong>函数并且看到这个Person类型(也是在类外提前声明)</li>\n</ul>\n<p>先进行类外声明，否则文件编译时链接失败</p>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T1, <span class=\"keyword\">class</span> T2&gt;<span class=\"keyword\">class</span> Person;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T1, <span class=\"keyword\">class</span> T2&gt;<span class=\"keyword\">void</span> PrintPerson(Person&lt;T1, T2&gt;&amp; p);</span><br></pre></td></tr></table></figure>\n\n<p>类内声明需要加&lt;&gt;使其变成模板函数声明</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class <span class=\"built_in\">T1</span>, class <span class=\"built_in\">T2</span>&gt;</span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\"><span class=\"symbol\">public:</span>\t</span><br><span class=\"line\">\tfriend void PrintPerson&lt;&gt;(Person&lt;<span class=\"built_in\">T1</span>, <span class=\"built_in\">T2</span>&gt;&amp; p)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">private:</span></span><br><span class=\"line\">\t<span class=\"built_in\">T1</span> m_Age<span class=\"comment\">;</span></span><br><span class=\"line\">\t<span class=\"built_in\">T2</span> m_Name<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>类外实现</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span>, <span class=\"title\">class</span> <span class=\"title\">T2</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">PrintPerson</span>(<span class=\"title\">Person</span>&lt;T1, T2&gt;&amp; <span class=\"title\">p</span>) &#123;</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Name: \"</span> &lt;&lt; p.m_Age &lt;&lt; <span class=\"string\">\" Age: \"</span> &lt;&lt; p.m_Age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS:颤抖的手点下了付款。</p>"},{"title":"Holiday Note_17","date":"2019-07-29T14:08:02.000Z","_content":"# Holiday Note_17\n\n**类型转换**，**标准I/O流**，**文件读写**，这些都感觉不是很重要，而且记的东西太多了估计明天就忘了。**异常**是今天的一个重点，try，throw，catch。\n\n<!-- more -->\n\n##\t类型转换\n1.\t静态转换 static_cast\n-\t使用方式  static_cast< 目标类型>（原始数据）\n-\t**可以进行基础数据类型转换** \n-\t父与子类型转换\n-\t没有父子关系的自定义类型不可以转换\n2.\t动态转换 \n-\t使用方式dynamic_cast< 目标类型>（原始数据）\n-\t**不可以转换基础数据类型**\n-\t父子之间可以转换(**父转子不可以**；子转父可以；发生多态都可以)\n\t\n3.\t常量转换 \n-\t使用方式const_cast< 目标类型>（原始数据）\n-\t**不能对非指针或者非引用进行转换**\n4.\t重新解释转换 \n-\t使用方法reinterpret_cast < 目标类型>（原始数据）\n-\t**最不安全**，最鸡肋 不推荐\n\n\n---\n\n## 异常\n\n异常处理就是处理程序中的错误。\n\n在异常处理过程中，由**问题检测代码**(try)可以**抛出一个对象**(throw)给**问题处理代码**(catch)，通过这个对象的类型和内容，实际上完成了两个部分的通信。\n\n### 异常捕捉方式**严格类型匹配**\n~~~\nthrow 'a';\n\ncatch(char){}\n~~~\n\n\n\n### ...为其他所有类型的异常，通常写在其余类型捕获之后\n~~~\ncatch (...){}\n~~~\n\n\n\n### 栈解旋(unwinding)\n一句话：**异常被抛出后**，**从进入try块起，到异常被抛掷前**，这期间在**栈上**构造的**所有对象**，都会被**自动析构**。析构的顺序与构造的顺序相反，这一过程称为栈的解旋(unwinding)\n\n\n\n### 异常接口声明\n-\t如果想抛出**特定的类型**异常 ，可以利用异常的**接口声明**\n-\tvoid func() throw (int) 只能抛出 int类型\n-\tvoid func() throw() **不抛出任何类型异常**\n-\t若函数抛出了接口不允许的异常，将会调用terminate函数中断程序\n\n\n### 异常变量的生命周期\n-\t(MyException e)，会多开销一份数据, 调用拷贝构造\n-\t(MyExcepiton *e)，需要管理delete\n-\t推荐(MyException &e)\n\n\n### 异常的多态\n-\t利用多态来实现如printError同一个接口调用\n-\t抛出不同的错误对象，提示不同错误\n\n### 系统标准异常\n 需要 #incldue <stdexcept>\n\n例如out_of_range, lenger_error等等。接收的类型名即为抛出的异常名\n~~~\nthrow out_of_range（\"a123\"） 。。。\n\ncatch(out_of_range & e)  {\n\tcout  <<  e.what();\n}\n~~~\n\n### string与char* 的转换\n~~~\nstring 转 char *   .c_str();\n~~~\n\n---\n\n## 标准I/O流\n\n标准I/O对象:cin，cout，cerr，clog\n\n### 标准输入流\n标准输入流对象cin一些常见函数\n\n- cin.get 缓冲区中读取一个字符\n- cin.get(两个参数) 不读换行符\n- cin.getline () 读取换行 并且扔掉\n- cin.ignore 忽略 （N） N代表忽略字符数 \n- cin.peek 偷窥   偷看1个字符然后放回去\n- cin.putback  放回 把字符放回缓冲区\n- cin.fail() 看标志位  0正常 1不正常\n- cin.clear()重置标志位\n- cin.syne() 清空缓冲区\n\n### 标准输出流\n\n#### 流对象的成员函数\n-\tint number = 99;\n-\tcout.width(20);\n-\tcout.fill('*');\n-\tcout.setf(ios::left); //设置格式  输入内容做对齐\n-\tcout.unsetf(ios::dec); //卸载十进制\n-\tcout.setf(ios::hex); //安装16进制\n-\tcout.setf(ios::showbase); // 强制输出整数基数  0  0x\n-\tcout.unsetf(ios::hex);\n-\tcout.setf(ios::oct);\n-\tcout << number << endl;\n\n#### 控制符\n\n使用控制符方式则需要**iomanip头文件**\n~~~\nint number = 99;\n\n cout << setw(20)\n\n<< setfill('~')\n\n<< setiosflags(ios::showbase) //基数\n\t\t\n<< setiosflags(ios::left) //左对齐\n\n<< hex // 十六进制\n\n<< number\n\n<< endl;\n~~~\n\nPS:下了大半天雨的空气才难得清新一会。","source":"_posts/2019-Holiday-Note-17.md","raw":"---\ntitle: Holiday Note_17\ndate: 2019-07-29 22:08:02\ncategories: C++\ntags: [Note,C++]\n---\n# Holiday Note_17\n\n**类型转换**，**标准I/O流**，**文件读写**，这些都感觉不是很重要，而且记的东西太多了估计明天就忘了。**异常**是今天的一个重点，try，throw，catch。\n\n<!-- more -->\n\n##\t类型转换\n1.\t静态转换 static_cast\n-\t使用方式  static_cast< 目标类型>（原始数据）\n-\t**可以进行基础数据类型转换** \n-\t父与子类型转换\n-\t没有父子关系的自定义类型不可以转换\n2.\t动态转换 \n-\t使用方式dynamic_cast< 目标类型>（原始数据）\n-\t**不可以转换基础数据类型**\n-\t父子之间可以转换(**父转子不可以**；子转父可以；发生多态都可以)\n\t\n3.\t常量转换 \n-\t使用方式const_cast< 目标类型>（原始数据）\n-\t**不能对非指针或者非引用进行转换**\n4.\t重新解释转换 \n-\t使用方法reinterpret_cast < 目标类型>（原始数据）\n-\t**最不安全**，最鸡肋 不推荐\n\n\n---\n\n## 异常\n\n异常处理就是处理程序中的错误。\n\n在异常处理过程中，由**问题检测代码**(try)可以**抛出一个对象**(throw)给**问题处理代码**(catch)，通过这个对象的类型和内容，实际上完成了两个部分的通信。\n\n### 异常捕捉方式**严格类型匹配**\n~~~\nthrow 'a';\n\ncatch(char){}\n~~~\n\n\n\n### ...为其他所有类型的异常，通常写在其余类型捕获之后\n~~~\ncatch (...){}\n~~~\n\n\n\n### 栈解旋(unwinding)\n一句话：**异常被抛出后**，**从进入try块起，到异常被抛掷前**，这期间在**栈上**构造的**所有对象**，都会被**自动析构**。析构的顺序与构造的顺序相反，这一过程称为栈的解旋(unwinding)\n\n\n\n### 异常接口声明\n-\t如果想抛出**特定的类型**异常 ，可以利用异常的**接口声明**\n-\tvoid func() throw (int) 只能抛出 int类型\n-\tvoid func() throw() **不抛出任何类型异常**\n-\t若函数抛出了接口不允许的异常，将会调用terminate函数中断程序\n\n\n### 异常变量的生命周期\n-\t(MyException e)，会多开销一份数据, 调用拷贝构造\n-\t(MyExcepiton *e)，需要管理delete\n-\t推荐(MyException &e)\n\n\n### 异常的多态\n-\t利用多态来实现如printError同一个接口调用\n-\t抛出不同的错误对象，提示不同错误\n\n### 系统标准异常\n 需要 #incldue <stdexcept>\n\n例如out_of_range, lenger_error等等。接收的类型名即为抛出的异常名\n~~~\nthrow out_of_range（\"a123\"） 。。。\n\ncatch(out_of_range & e)  {\n\tcout  <<  e.what();\n}\n~~~\n\n### string与char* 的转换\n~~~\nstring 转 char *   .c_str();\n~~~\n\n---\n\n## 标准I/O流\n\n标准I/O对象:cin，cout，cerr，clog\n\n### 标准输入流\n标准输入流对象cin一些常见函数\n\n- cin.get 缓冲区中读取一个字符\n- cin.get(两个参数) 不读换行符\n- cin.getline () 读取换行 并且扔掉\n- cin.ignore 忽略 （N） N代表忽略字符数 \n- cin.peek 偷窥   偷看1个字符然后放回去\n- cin.putback  放回 把字符放回缓冲区\n- cin.fail() 看标志位  0正常 1不正常\n- cin.clear()重置标志位\n- cin.syne() 清空缓冲区\n\n### 标准输出流\n\n#### 流对象的成员函数\n-\tint number = 99;\n-\tcout.width(20);\n-\tcout.fill('*');\n-\tcout.setf(ios::left); //设置格式  输入内容做对齐\n-\tcout.unsetf(ios::dec); //卸载十进制\n-\tcout.setf(ios::hex); //安装16进制\n-\tcout.setf(ios::showbase); // 强制输出整数基数  0  0x\n-\tcout.unsetf(ios::hex);\n-\tcout.setf(ios::oct);\n-\tcout << number << endl;\n\n#### 控制符\n\n使用控制符方式则需要**iomanip头文件**\n~~~\nint number = 99;\n\n cout << setw(20)\n\n<< setfill('~')\n\n<< setiosflags(ios::showbase) //基数\n\t\t\n<< setiosflags(ios::left) //左对齐\n\n<< hex // 十六进制\n\n<< number\n\n<< endl;\n~~~\n\nPS:下了大半天雨的空气才难得清新一会。","slug":"2019-Holiday-Note-17","published":1,"updated":"2019-07-29T15:14:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihs001fsmjbssyd9dpi","content":"<h1 id=\"Holiday-Note-17\"><a href=\"#Holiday-Note-17\" class=\"headerlink\" title=\"Holiday Note_17\"></a>Holiday Note_17</h1><p><strong>类型转换</strong>，<strong>标准I/O流</strong>，<strong>文件读写</strong>，这些都感觉不是很重要，而且记的东西太多了估计明天就忘了。<strong>异常</strong>是今天的一个重点，try，throw，catch。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><ol>\n<li>静态转换 static_cast</li>\n</ol>\n<ul>\n<li>使用方式  static_cast&lt; 目标类型&gt;（原始数据）</li>\n<li><strong>可以进行基础数据类型转换</strong> </li>\n<li>父与子类型转换</li>\n<li>没有父子关系的自定义类型不可以转换</li>\n</ul>\n<ol start=\"2\">\n<li>动态转换 </li>\n</ol>\n<ul>\n<li>使用方式dynamic_cast&lt; 目标类型&gt;（原始数据）</li>\n<li><strong>不可以转换基础数据类型</strong></li>\n<li>父子之间可以转换(<strong>父转子不可以</strong>；子转父可以；发生多态都可以)</li>\n</ul>\n<ol start=\"3\">\n<li>常量转换 </li>\n</ol>\n<ul>\n<li>使用方式const_cast&lt; 目标类型&gt;（原始数据）</li>\n<li><strong>不能对非指针或者非引用进行转换</strong></li>\n</ul>\n<ol start=\"4\">\n<li>重新解释转换 </li>\n</ol>\n<ul>\n<li>使用方法reinterpret_cast &lt; 目标类型&gt;（原始数据）</li>\n<li><strong>最不安全</strong>，最鸡肋 不推荐</li>\n</ul>\n<hr>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>异常处理就是处理程序中的错误。</p>\n<p>在异常处理过程中，由<strong>问题检测代码</strong>(try)可以<strong>抛出一个对象</strong>(throw)给<strong>问题处理代码</strong>(catch)，通过这个对象的类型和内容，实际上完成了两个部分的通信。</p>\n<h3 id=\"异常捕捉方式严格类型匹配\"><a href=\"#异常捕捉方式严格类型匹配\" class=\"headerlink\" title=\"异常捕捉方式严格类型匹配\"></a>异常捕捉方式<strong>严格类型匹配</strong></h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">'a'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">catch</span>(<span class=\"keyword\">char</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"…为其他所有类型的异常，通常写在其余类型捕获之后\"><a href=\"#…为其他所有类型的异常，通常写在其余类型捕获之后\" class=\"headerlink\" title=\"…为其他所有类型的异常，通常写在其余类型捕获之后\"></a>…为其他所有类型的异常，通常写在其余类型捕获之后</h3><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">catch</span></span> (...)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"栈解旋-unwinding\"><a href=\"#栈解旋-unwinding\" class=\"headerlink\" title=\"栈解旋(unwinding)\"></a>栈解旋(unwinding)</h3><p>一句话：<strong>异常被抛出后</strong>，<strong>从进入try块起，到异常被抛掷前</strong>，这期间在<strong>栈上</strong>构造的<strong>所有对象</strong>，都会被<strong>自动析构</strong>。析构的顺序与构造的顺序相反，这一过程称为栈的解旋(unwinding)</p>\n<h3 id=\"异常接口声明\"><a href=\"#异常接口声明\" class=\"headerlink\" title=\"异常接口声明\"></a>异常接口声明</h3><ul>\n<li>如果想抛出<strong>特定的类型</strong>异常 ，可以利用异常的<strong>接口声明</strong></li>\n<li>void func() throw (int) 只能抛出 int类型</li>\n<li>void func() throw() <strong>不抛出任何类型异常</strong></li>\n<li>若函数抛出了接口不允许的异常，将会调用terminate函数中断程序</li>\n</ul>\n<h3 id=\"异常变量的生命周期\"><a href=\"#异常变量的生命周期\" class=\"headerlink\" title=\"异常变量的生命周期\"></a>异常变量的生命周期</h3><ul>\n<li>(MyException e)，会多开销一份数据, 调用拷贝构造</li>\n<li>(MyExcepiton *e)，需要管理delete</li>\n<li>推荐(MyException &amp;e)</li>\n</ul>\n<h3 id=\"异常的多态\"><a href=\"#异常的多态\" class=\"headerlink\" title=\"异常的多态\"></a>异常的多态</h3><ul>\n<li>利用多态来实现如printError同一个接口调用</li>\n<li>抛出不同的错误对象，提示不同错误</li>\n</ul>\n<h3 id=\"系统标准异常\"><a href=\"#系统标准异常\" class=\"headerlink\" title=\"系统标准异常\"></a>系统标准异常</h3><p> 需要 #incldue <stdexcept></stdexcept></p>\n<p>例如out_of_range, lenger_error等等。接收的类型名即为抛出的异常名</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">out</span><span class=\"number\">_</span><span class=\"keyword\">of</span><span class=\"number\">_</span>range（<span class=\"string\">\"a123\"</span>） 。。。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">catch</span>(<span class=\"keyword\">out</span><span class=\"number\">_</span><span class=\"keyword\">of</span><span class=\"number\">_</span>range &amp; e)  &#123;</span><br><span class=\"line\">\tcout  &lt;&lt;  e.what();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"string与char-的转换\"><a href=\"#string与char-的转换\" class=\"headerlink\" title=\"string与char* 的转换\"></a>string与char* 的转换</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> 转 <span class=\"keyword\">char</span> *   .c_str();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"标准I-O流\"><a href=\"#标准I-O流\" class=\"headerlink\" title=\"标准I/O流\"></a>标准I/O流</h2><p>标准I/O对象:cin，cout，cerr，clog</p>\n<h3 id=\"标准输入流\"><a href=\"#标准输入流\" class=\"headerlink\" title=\"标准输入流\"></a>标准输入流</h3><p>标准输入流对象cin一些常见函数</p>\n<ul>\n<li>cin.get 缓冲区中读取一个字符</li>\n<li>cin.get(两个参数) 不读换行符</li>\n<li>cin.getline () 读取换行 并且扔掉</li>\n<li>cin.ignore 忽略 （N） N代表忽略字符数 </li>\n<li>cin.peek 偷窥   偷看1个字符然后放回去</li>\n<li>cin.putback  放回 把字符放回缓冲区</li>\n<li>cin.fail() 看标志位  0正常 1不正常</li>\n<li>cin.clear()重置标志位</li>\n<li>cin.syne() 清空缓冲区</li>\n</ul>\n<h3 id=\"标准输出流\"><a href=\"#标准输出流\" class=\"headerlink\" title=\"标准输出流\"></a>标准输出流</h3><h4 id=\"流对象的成员函数\"><a href=\"#流对象的成员函数\" class=\"headerlink\" title=\"流对象的成员函数\"></a>流对象的成员函数</h4><ul>\n<li>int number = 99;</li>\n<li>cout.width(20);</li>\n<li>cout.fill(‘*’);</li>\n<li>cout.setf(ios::left); //设置格式  输入内容做对齐</li>\n<li>cout.unsetf(ios::dec); //卸载十进制</li>\n<li>cout.setf(ios::hex); //安装16进制</li>\n<li>cout.setf(ios::showbase); // 强制输出整数基数  0  0x</li>\n<li>cout.unsetf(ios::hex);</li>\n<li>cout.setf(ios::oct);</li>\n<li>cout &lt;&lt; number &lt;&lt; endl;</li>\n</ul>\n<h4 id=\"控制符\"><a href=\"#控制符\" class=\"headerlink\" title=\"控制符\"></a>控制符</h4><p>使用控制符方式则需要<strong>iomanip头文件</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> number = <span class=\"number\">99</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">cout</span> &lt;&lt; setw(<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&lt; setfill(<span class=\"string\">'~'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&lt; setiosflags(ios::showbase) <span class=\"comment\">//基数</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">&lt;&lt; setiosflags(ios::left) <span class=\"comment\">//左对齐</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&lt; hex <span class=\"comment\">// 十六进制</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&lt; number</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&lt; <span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n\n<p>PS:下了大半天雨的空气才难得清新一会。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-17\"><a href=\"#Holiday-Note-17\" class=\"headerlink\" title=\"Holiday Note_17\"></a>Holiday Note_17</h1><p><strong>类型转换</strong>，<strong>标准I/O流</strong>，<strong>文件读写</strong>，这些都感觉不是很重要，而且记的东西太多了估计明天就忘了。<strong>异常</strong>是今天的一个重点，try，throw，catch。</p>","more":"<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><ol>\n<li>静态转换 static_cast</li>\n</ol>\n<ul>\n<li>使用方式  static_cast&lt; 目标类型&gt;（原始数据）</li>\n<li><strong>可以进行基础数据类型转换</strong> </li>\n<li>父与子类型转换</li>\n<li>没有父子关系的自定义类型不可以转换</li>\n</ul>\n<ol start=\"2\">\n<li>动态转换 </li>\n</ol>\n<ul>\n<li>使用方式dynamic_cast&lt; 目标类型&gt;（原始数据）</li>\n<li><strong>不可以转换基础数据类型</strong></li>\n<li>父子之间可以转换(<strong>父转子不可以</strong>；子转父可以；发生多态都可以)</li>\n</ul>\n<ol start=\"3\">\n<li>常量转换 </li>\n</ol>\n<ul>\n<li>使用方式const_cast&lt; 目标类型&gt;（原始数据）</li>\n<li><strong>不能对非指针或者非引用进行转换</strong></li>\n</ul>\n<ol start=\"4\">\n<li>重新解释转换 </li>\n</ol>\n<ul>\n<li>使用方法reinterpret_cast &lt; 目标类型&gt;（原始数据）</li>\n<li><strong>最不安全</strong>，最鸡肋 不推荐</li>\n</ul>\n<hr>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>异常处理就是处理程序中的错误。</p>\n<p>在异常处理过程中，由<strong>问题检测代码</strong>(try)可以<strong>抛出一个对象</strong>(throw)给<strong>问题处理代码</strong>(catch)，通过这个对象的类型和内容，实际上完成了两个部分的通信。</p>\n<h3 id=\"异常捕捉方式严格类型匹配\"><a href=\"#异常捕捉方式严格类型匹配\" class=\"headerlink\" title=\"异常捕捉方式严格类型匹配\"></a>异常捕捉方式<strong>严格类型匹配</strong></h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">'a'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">catch</span>(<span class=\"keyword\">char</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"…为其他所有类型的异常，通常写在其余类型捕获之后\"><a href=\"#…为其他所有类型的异常，通常写在其余类型捕获之后\" class=\"headerlink\" title=\"…为其他所有类型的异常，通常写在其余类型捕获之后\"></a>…为其他所有类型的异常，通常写在其余类型捕获之后</h3><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">catch</span></span> (...)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"栈解旋-unwinding\"><a href=\"#栈解旋-unwinding\" class=\"headerlink\" title=\"栈解旋(unwinding)\"></a>栈解旋(unwinding)</h3><p>一句话：<strong>异常被抛出后</strong>，<strong>从进入try块起，到异常被抛掷前</strong>，这期间在<strong>栈上</strong>构造的<strong>所有对象</strong>，都会被<strong>自动析构</strong>。析构的顺序与构造的顺序相反，这一过程称为栈的解旋(unwinding)</p>\n<h3 id=\"异常接口声明\"><a href=\"#异常接口声明\" class=\"headerlink\" title=\"异常接口声明\"></a>异常接口声明</h3><ul>\n<li>如果想抛出<strong>特定的类型</strong>异常 ，可以利用异常的<strong>接口声明</strong></li>\n<li>void func() throw (int) 只能抛出 int类型</li>\n<li>void func() throw() <strong>不抛出任何类型异常</strong></li>\n<li>若函数抛出了接口不允许的异常，将会调用terminate函数中断程序</li>\n</ul>\n<h3 id=\"异常变量的生命周期\"><a href=\"#异常变量的生命周期\" class=\"headerlink\" title=\"异常变量的生命周期\"></a>异常变量的生命周期</h3><ul>\n<li>(MyException e)，会多开销一份数据, 调用拷贝构造</li>\n<li>(MyExcepiton *e)，需要管理delete</li>\n<li>推荐(MyException &amp;e)</li>\n</ul>\n<h3 id=\"异常的多态\"><a href=\"#异常的多态\" class=\"headerlink\" title=\"异常的多态\"></a>异常的多态</h3><ul>\n<li>利用多态来实现如printError同一个接口调用</li>\n<li>抛出不同的错误对象，提示不同错误</li>\n</ul>\n<h3 id=\"系统标准异常\"><a href=\"#系统标准异常\" class=\"headerlink\" title=\"系统标准异常\"></a>系统标准异常</h3><p> 需要 #incldue <stdexcept></stdexcept></p>\n<p>例如out_of_range, lenger_error等等。接收的类型名即为抛出的异常名</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">out</span><span class=\"number\">_</span><span class=\"keyword\">of</span><span class=\"number\">_</span>range（<span class=\"string\">\"a123\"</span>） 。。。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">catch</span>(<span class=\"keyword\">out</span><span class=\"number\">_</span><span class=\"keyword\">of</span><span class=\"number\">_</span>range &amp; e)  &#123;</span><br><span class=\"line\">\tcout  &lt;&lt;  e.what();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"string与char-的转换\"><a href=\"#string与char-的转换\" class=\"headerlink\" title=\"string与char* 的转换\"></a>string与char* 的转换</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> 转 <span class=\"keyword\">char</span> *   .c_str();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"标准I-O流\"><a href=\"#标准I-O流\" class=\"headerlink\" title=\"标准I/O流\"></a>标准I/O流</h2><p>标准I/O对象:cin，cout，cerr，clog</p>\n<h3 id=\"标准输入流\"><a href=\"#标准输入流\" class=\"headerlink\" title=\"标准输入流\"></a>标准输入流</h3><p>标准输入流对象cin一些常见函数</p>\n<ul>\n<li>cin.get 缓冲区中读取一个字符</li>\n<li>cin.get(两个参数) 不读换行符</li>\n<li>cin.getline () 读取换行 并且扔掉</li>\n<li>cin.ignore 忽略 （N） N代表忽略字符数 </li>\n<li>cin.peek 偷窥   偷看1个字符然后放回去</li>\n<li>cin.putback  放回 把字符放回缓冲区</li>\n<li>cin.fail() 看标志位  0正常 1不正常</li>\n<li>cin.clear()重置标志位</li>\n<li>cin.syne() 清空缓冲区</li>\n</ul>\n<h3 id=\"标准输出流\"><a href=\"#标准输出流\" class=\"headerlink\" title=\"标准输出流\"></a>标准输出流</h3><h4 id=\"流对象的成员函数\"><a href=\"#流对象的成员函数\" class=\"headerlink\" title=\"流对象的成员函数\"></a>流对象的成员函数</h4><ul>\n<li>int number = 99;</li>\n<li>cout.width(20);</li>\n<li>cout.fill(‘*’);</li>\n<li>cout.setf(ios::left); //设置格式  输入内容做对齐</li>\n<li>cout.unsetf(ios::dec); //卸载十进制</li>\n<li>cout.setf(ios::hex); //安装16进制</li>\n<li>cout.setf(ios::showbase); // 强制输出整数基数  0  0x</li>\n<li>cout.unsetf(ios::hex);</li>\n<li>cout.setf(ios::oct);</li>\n<li>cout &lt;&lt; number &lt;&lt; endl;</li>\n</ul>\n<h4 id=\"控制符\"><a href=\"#控制符\" class=\"headerlink\" title=\"控制符\"></a>控制符</h4><p>使用控制符方式则需要<strong>iomanip头文件</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> number = <span class=\"number\">99</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">cout</span> &lt;&lt; setw(<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&lt; setfill(<span class=\"string\">'~'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&lt; setiosflags(ios::showbase) <span class=\"comment\">//基数</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">&lt;&lt; setiosflags(ios::left) <span class=\"comment\">//左对齐</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&lt; hex <span class=\"comment\">// 十六进制</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&lt; number</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&lt; <span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n\n<p>PS:下了大半天雨的空气才难得清新一会。</p>"},{"title":"Holiday Note_18","date":"2019-07-30T12:00:50.000Z","_content":"# Holiday Note_18\n\n使用**STL**写代码的确是方便了很多，STL提供的三大组件(**容器**，**算法**，**迭代器**)实现了**数据和操作分离**，数据由容器管理，操作由定制的算法定义，再由迭代器起将其二者连接，使得开发时多关注于实现功能的逻辑。而不用像以前一样，先定义好数据结构，再实现算法等一系列繁琐的步骤了。BUT 不简单啊。\n\n<!-- more -->\n\n---\n\n\n## string\nstring管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。\n\n### 构造函数\n~~~\nstring();//创建一个空的字符串 例如: string str;      \nstring(const string& str);//使用一个string对象初始化另一个string对象\nstring(const char* s);//使用字符串s初始化\nstring(int n, char c);//使用n个字符c初始化 \n~~~\n\n\n### 基本赋值操作\n相同达到功能使用string类成员.assign没有直接使用构造函数方便。\n~~~\nstring& operator=(const char* s);//char*类型字符串 赋值给当前的字符串\nstring& operator=(const string &s);//把字符串s赋给当前的字符串\nstring& operator=(char c);//字符赋值给当前的字符串\nstring& assign(const char *s);//把字符串s赋给当前的字符串\nstring& assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串\nstring& assign(const string &s);//把字符串s赋给当前字符串\nstring& assign(int n, char c);//用n个字符c赋给当前字符串\nstring& assign(const string &s, int start, int n);//将s从start开始n个字符赋值给字符串\n~~~\n\n\n### 存取字符操作\n使用at方式若越界会抛出**out_of_range**的异常，而使用[]越界程序会直接终止。\n~~~\nchar& operator[](int n);//通过[]方式取字符\nchar& at(int n);//通过at方法获取字符\n~~~\n\n\n\n### 拼接操作\n~~~\nstring& operator+=(const string& str);//重载+=操作符\nstring& operator+=(const char* str);//重载+=操作符\nstring& operator+=(const char c);//重载+=操作符\nstring& append(const char *s);//把字符串s连接到当前字符串结尾\nstring& append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾\nstring& append(const string &s);//同operator+=()\nstring& append(const string &s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾\nstring& append(int n, char c);//在当前字符串结尾添加n个字符c\n~~~\n\n### 查找和替换\n~~~\nint find(const string& str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找\nint find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找\nint find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置\nint find(const char c, int pos = 0) const;  //查找字符c第一次出现位置\nint rfind(const string& str, int pos = npos) const;//查找str最后一次位置,从pos开始查找\nint rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找\nint rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置\nint rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置\nstring& replace(int pos, int n, const string& str); //替换从pos开始n个字符为字符串str\nstring& replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s\n~~~\n\n\n### 比较操作\n~~~\n/*\ncompare函数在>时返回 1，<时返回 -1，==时返回 0。\n比较区分大小写，比较时参考字典顺序，排越前面的越小。\n大写的A比小写的a小。\n*/\n\nint compare(const string &s) const;//与字符串s比较\nint compare(const char *s) const;//与字符串s比较\n~~~\n\n### string子串\n~~~\nstring substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串\n~~~\n\n### 插入和删除操作\n~~~\nstring& insert(int pos, const char* s); //插入字符串\nstring& insert(int pos, const string& str); //插入字符串\nstring& insert(int pos, int n, char c);//在指定位置插入n个字符c\nstring& erase(int pos, int n = npos);//删除从Pos开始的n个字符 \n~~~\n\n### string和c-style字符串转换\n**const char*到string存在隐式类型转换，但是string不能自动类型转换为C_string。**\n~~~\n//string 转 char*\nstring str = \"itcast\";\nconst char* cstr = str.c_str();\n\n//char* 转 string \nchar* s = \"itcast\";\nstring str(s);\n~~~\n\n### 大小写转换\n~~~\n//大写转换\ntoupper\n//小写转换\ntolower\n~~~\n\n---\n\n## vector\n与普通数组不同的是，vector是**动态空间**，随着元素的加入，它的内部机制会**自动扩充空间**以容纳新元素。即把原空间拷贝到一块新空间，且vector提供的是**随机访问迭代器**\n\n[![vectormodel13ef3.md.png](https://miao.su/images/2019/07/30/vectormodel13ef3.md.png)](https://miao.su/image/TPULP)\n\n> 一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。\n\n-\t构造、赋值\n-\t大小 size 重置大小 resize 容量 capacity\n-\t是否为空 empty \n-\t巧用swap收缩空间 (匿名对象方法)\n-\treserve 预留空间\n-\tinsert 插入（迭代器） erase删除 （迭代器） clear（）清空容器\n-\tpop_back 尾删 front返回第一个数据，back返回最后一个数据\n-\t逆序遍历 使用reverse_iterator迭代器 (rbegin rend ++)\n\n\n\n### 构造\n~~~\nvector<T> v; //采用模板实现类实现，默认构造函数\nvector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。\nvector(n, elem);//构造函数将n个elem拷贝给本身。\nvector(const vector &vec);//拷贝构造函数。\n\n\nint arr[] = {2,3,4,1,9};\nvector<int> v1(arr, arr + sizeof(arr) / sizeof(int)); \n~~~\n\n### 需要注意的几个API\n~~~\nresize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。\nresize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长>度的元素被删除。\ncapacity();//容器的容量\nreserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。\n~~~\n\n### 关于swap的技巧(通过匿名对象收缩空间)\n~~~\nvector<int> v1;\nfor (int i = 0; i < 100000; ++i) {\n\tv1.push_back(i);\n}\n\ncout << \"容量 \" << v1.capacity() <<endl;//138255\ncout << \"大小 \" << v1.size() <<endl;//10000\n\nv1.resize(3);//进行resize后，元素大小变小了，但是容量依旧不变\n\ncout << \"容量 \" << v1.capacity() << endl;//138255\ncout << \"大小 \" << v1.size() << endl;//3\n\n\nvector<int>(v1).swap(v1);//利用匿名对象，将v1传给拷贝给匿名对象时不会拷贝空的空间，即根据大小拷贝\n//再进行匿名对象和v1的交换，实则交换指针指向，由于匿名对象的容量为v1元素大小，因此达到了收缩空间目的。\n\ncout << \"容量 \" << v1.capacity() << endl;//3\ncout << \"大小 \" << v1.size() << endl;//3\n~~~\n\n\n### reserve使用技巧\n~~~\nvector<int> v;\n\nint* p = NULL;//原理：每次空间扩充p指向的便不再是原来vector空间的地址了\nint num = 0;//记录容器重新开辟了多少次空间\n//在有些已知需要多大空间的情况下，为了提高效率，提前给vector容器分配好大空间减少不断进行动态增加空间的过程\n\t\nv.reserve(100000);//不提前分配时，需要30次\n\nfor (int i = 0; i < 100000; ++i) {\n\n\tv.push_back(i);\n\n\tif (p != &(v[0])) {\n\t\tp = &(v[0]);\n\t\t++num;\n\t}\n\n}\n\ncout << num << endl;//30 change 1\n~~~\n\n---\n\n### deque\n\n与vector的差别：支持头部删除 头部插入\n-\tpop_front\n-\tpush_front\n\n> Deque容器和vector容器最大的差异，一在于deque允许使用**常数项**时间对**头端进行元素的插入和删除操作**。二在于deque**没有容量的概念**，因为它是**动态**的以**分段连续空间组合**而成，随时可以增加一段新的空间并**链接**起来，\n\n[![dequemodel9ffa4.md.png](https://miao.su/images/2019/07/30/dequemodel9ffa4.md.png)](https://miao.su/image/TPI6Y)\n\n\n> Deque采取一块所谓的map(注意，不是STL的map容器)作为**主控**，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。**缓冲区**才是deque的存储空间的主体。\n\n[![deque33cfe.md.png](https://miao.su/images/2019/07/30/deque33cfe.md.png)](https://miao.su/image/TP34o)\n\nPS:大学老师整的和小学老师没什么区别，这说明了什么问题:）","source":"_posts/2019-Holiday-Note-18.md","raw":"---\ntitle: Holiday Note_18\ndate: 2019-07-30 20:00:50\ncategories: C++\ntags: [Note,STL,C++]\n---\n# Holiday Note_18\n\n使用**STL**写代码的确是方便了很多，STL提供的三大组件(**容器**，**算法**，**迭代器**)实现了**数据和操作分离**，数据由容器管理，操作由定制的算法定义，再由迭代器起将其二者连接，使得开发时多关注于实现功能的逻辑。而不用像以前一样，先定义好数据结构，再实现算法等一系列繁琐的步骤了。BUT 不简单啊。\n\n<!-- more -->\n\n---\n\n\n## string\nstring管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。\n\n### 构造函数\n~~~\nstring();//创建一个空的字符串 例如: string str;      \nstring(const string& str);//使用一个string对象初始化另一个string对象\nstring(const char* s);//使用字符串s初始化\nstring(int n, char c);//使用n个字符c初始化 \n~~~\n\n\n### 基本赋值操作\n相同达到功能使用string类成员.assign没有直接使用构造函数方便。\n~~~\nstring& operator=(const char* s);//char*类型字符串 赋值给当前的字符串\nstring& operator=(const string &s);//把字符串s赋给当前的字符串\nstring& operator=(char c);//字符赋值给当前的字符串\nstring& assign(const char *s);//把字符串s赋给当前的字符串\nstring& assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串\nstring& assign(const string &s);//把字符串s赋给当前字符串\nstring& assign(int n, char c);//用n个字符c赋给当前字符串\nstring& assign(const string &s, int start, int n);//将s从start开始n个字符赋值给字符串\n~~~\n\n\n### 存取字符操作\n使用at方式若越界会抛出**out_of_range**的异常，而使用[]越界程序会直接终止。\n~~~\nchar& operator[](int n);//通过[]方式取字符\nchar& at(int n);//通过at方法获取字符\n~~~\n\n\n\n### 拼接操作\n~~~\nstring& operator+=(const string& str);//重载+=操作符\nstring& operator+=(const char* str);//重载+=操作符\nstring& operator+=(const char c);//重载+=操作符\nstring& append(const char *s);//把字符串s连接到当前字符串结尾\nstring& append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾\nstring& append(const string &s);//同operator+=()\nstring& append(const string &s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾\nstring& append(int n, char c);//在当前字符串结尾添加n个字符c\n~~~\n\n### 查找和替换\n~~~\nint find(const string& str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找\nint find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找\nint find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置\nint find(const char c, int pos = 0) const;  //查找字符c第一次出现位置\nint rfind(const string& str, int pos = npos) const;//查找str最后一次位置,从pos开始查找\nint rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找\nint rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置\nint rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置\nstring& replace(int pos, int n, const string& str); //替换从pos开始n个字符为字符串str\nstring& replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s\n~~~\n\n\n### 比较操作\n~~~\n/*\ncompare函数在>时返回 1，<时返回 -1，==时返回 0。\n比较区分大小写，比较时参考字典顺序，排越前面的越小。\n大写的A比小写的a小。\n*/\n\nint compare(const string &s) const;//与字符串s比较\nint compare(const char *s) const;//与字符串s比较\n~~~\n\n### string子串\n~~~\nstring substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串\n~~~\n\n### 插入和删除操作\n~~~\nstring& insert(int pos, const char* s); //插入字符串\nstring& insert(int pos, const string& str); //插入字符串\nstring& insert(int pos, int n, char c);//在指定位置插入n个字符c\nstring& erase(int pos, int n = npos);//删除从Pos开始的n个字符 \n~~~\n\n### string和c-style字符串转换\n**const char*到string存在隐式类型转换，但是string不能自动类型转换为C_string。**\n~~~\n//string 转 char*\nstring str = \"itcast\";\nconst char* cstr = str.c_str();\n\n//char* 转 string \nchar* s = \"itcast\";\nstring str(s);\n~~~\n\n### 大小写转换\n~~~\n//大写转换\ntoupper\n//小写转换\ntolower\n~~~\n\n---\n\n## vector\n与普通数组不同的是，vector是**动态空间**，随着元素的加入，它的内部机制会**自动扩充空间**以容纳新元素。即把原空间拷贝到一块新空间，且vector提供的是**随机访问迭代器**\n\n[![vectormodel13ef3.md.png](https://miao.su/images/2019/07/30/vectormodel13ef3.md.png)](https://miao.su/image/TPULP)\n\n> 一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。\n\n-\t构造、赋值\n-\t大小 size 重置大小 resize 容量 capacity\n-\t是否为空 empty \n-\t巧用swap收缩空间 (匿名对象方法)\n-\treserve 预留空间\n-\tinsert 插入（迭代器） erase删除 （迭代器） clear（）清空容器\n-\tpop_back 尾删 front返回第一个数据，back返回最后一个数据\n-\t逆序遍历 使用reverse_iterator迭代器 (rbegin rend ++)\n\n\n\n### 构造\n~~~\nvector<T> v; //采用模板实现类实现，默认构造函数\nvector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。\nvector(n, elem);//构造函数将n个elem拷贝给本身。\nvector(const vector &vec);//拷贝构造函数。\n\n\nint arr[] = {2,3,4,1,9};\nvector<int> v1(arr, arr + sizeof(arr) / sizeof(int)); \n~~~\n\n### 需要注意的几个API\n~~~\nresize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。\nresize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长>度的元素被删除。\ncapacity();//容器的容量\nreserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。\n~~~\n\n### 关于swap的技巧(通过匿名对象收缩空间)\n~~~\nvector<int> v1;\nfor (int i = 0; i < 100000; ++i) {\n\tv1.push_back(i);\n}\n\ncout << \"容量 \" << v1.capacity() <<endl;//138255\ncout << \"大小 \" << v1.size() <<endl;//10000\n\nv1.resize(3);//进行resize后，元素大小变小了，但是容量依旧不变\n\ncout << \"容量 \" << v1.capacity() << endl;//138255\ncout << \"大小 \" << v1.size() << endl;//3\n\n\nvector<int>(v1).swap(v1);//利用匿名对象，将v1传给拷贝给匿名对象时不会拷贝空的空间，即根据大小拷贝\n//再进行匿名对象和v1的交换，实则交换指针指向，由于匿名对象的容量为v1元素大小，因此达到了收缩空间目的。\n\ncout << \"容量 \" << v1.capacity() << endl;//3\ncout << \"大小 \" << v1.size() << endl;//3\n~~~\n\n\n### reserve使用技巧\n~~~\nvector<int> v;\n\nint* p = NULL;//原理：每次空间扩充p指向的便不再是原来vector空间的地址了\nint num = 0;//记录容器重新开辟了多少次空间\n//在有些已知需要多大空间的情况下，为了提高效率，提前给vector容器分配好大空间减少不断进行动态增加空间的过程\n\t\nv.reserve(100000);//不提前分配时，需要30次\n\nfor (int i = 0; i < 100000; ++i) {\n\n\tv.push_back(i);\n\n\tif (p != &(v[0])) {\n\t\tp = &(v[0]);\n\t\t++num;\n\t}\n\n}\n\ncout << num << endl;//30 change 1\n~~~\n\n---\n\n### deque\n\n与vector的差别：支持头部删除 头部插入\n-\tpop_front\n-\tpush_front\n\n> Deque容器和vector容器最大的差异，一在于deque允许使用**常数项**时间对**头端进行元素的插入和删除操作**。二在于deque**没有容量的概念**，因为它是**动态**的以**分段连续空间组合**而成，随时可以增加一段新的空间并**链接**起来，\n\n[![dequemodel9ffa4.md.png](https://miao.su/images/2019/07/30/dequemodel9ffa4.md.png)](https://miao.su/image/TPI6Y)\n\n\n> Deque采取一块所谓的map(注意，不是STL的map容器)作为**主控**，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。**缓冲区**才是deque的存储空间的主体。\n\n[![deque33cfe.md.png](https://miao.su/images/2019/07/30/deque33cfe.md.png)](https://miao.su/image/TP34o)\n\nPS:大学老师整的和小学老师没什么区别，这说明了什么问题:）","slug":"2019-Holiday-Note-18","published":1,"updated":"2019-07-30T12:54:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihu001jsmjbzt7bnd9i","content":"<h1 id=\"Holiday-Note-18\"><a href=\"#Holiday-Note-18\" class=\"headerlink\" title=\"Holiday Note_18\"></a>Holiday Note_18</h1><p>使用<strong>STL</strong>写代码的确是方便了很多，STL提供的三大组件(<strong>容器</strong>，<strong>算法</strong>，<strong>迭代器</strong>)实现了<strong>数据和操作分离</strong>，数据由容器管理，操作由定制的算法定义，再由迭代器起将其二者连接，使得开发时多关注于实现功能的逻辑。而不用像以前一样，先定义好数据结构，再实现算法等一系列繁琐的步骤了。BUT 不简单啊。</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h2><p>string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span>();<span class=\"comment\">//创建一个空的字符串 例如: string str;      </span></span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str);<span class=\"comment\">//使用一个string对象初始化另一个string对象</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s);<span class=\"comment\">//使用字符串s初始化</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"keyword\">int</span> n, <span class=\"keyword\">char</span> c);<span class=\"comment\">//使用n个字符c初始化</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本赋值操作\"><a href=\"#基本赋值操作\" class=\"headerlink\" title=\"基本赋值操作\"></a>基本赋值操作</h3><p>相同达到功能使用string类成员.assign没有直接使用构造函数方便。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s);<span class=\"comment\">//char*类型字符串 赋值给当前的字符串</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s);<span class=\"comment\">//把字符串s赋给当前的字符串</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">char</span> c);<span class=\"comment\">//字符赋值给当前的字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">assign</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s)</span></span>;<span class=\"comment\">//把字符串s赋给当前的字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">assign</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">int</span> n)</span></span>;<span class=\"comment\">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">assign</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s)</span></span>;<span class=\"comment\">//把字符串s赋给当前字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">assign</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">char</span> c)</span></span>;<span class=\"comment\">//用n个字符c赋给当前字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">assign</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> n)</span></span>;<span class=\"comment\">//将s从start开始n个字符赋值给字符串</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存取字符操作\"><a href=\"#存取字符操作\" class=\"headerlink\" title=\"存取字符操作\"></a>存取字符操作</h3><p>使用at方式若越界会抛出<strong>out_of_range</strong>的异常，而使用[]越界程序会直接终止。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">int</span> n);<span class=\"comment\">//通过[]方式取字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>&amp; <span class=\"title\">at</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;<span class=\"comment\">//通过at方法获取字符</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"拼接操作\"><a href=\"#拼接操作\" class=\"headerlink\" title=\"拼接操作\"></a>拼接操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>+=(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str);<span class=\"comment\">//重载+=操作符</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>+=(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str);<span class=\"comment\">//重载+=操作符</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>+=(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> c);<span class=\"comment\">//重载+=操作符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">append</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s)</span></span>;<span class=\"comment\">//把字符串s连接到当前字符串结尾</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">append</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">int</span> n)</span></span>;<span class=\"comment\">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">append</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s)</span></span>;<span class=\"comment\">//同operator+=()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">append</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n)</span></span>;<span class=\"comment\">//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">append</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">char</span> c)</span></span>;<span class=\"comment\">//在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查找和替换\"><a href=\"#查找和替换\" class=\"headerlink\" title=\"查找和替换\"></a>查找和替换</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str, <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>)</span> <span class=\"keyword\">const</span></span>; <span class=\"comment\">//查找str第一次出现位置,从pos开始查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>)</span> <span class=\"keyword\">const</span></span>;  <span class=\"comment\">//查找s第一次出现位置,从pos开始查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n)</span> <span class=\"keyword\">const</span></span>;  <span class=\"comment\">//从pos位置查找s的前n个字符第一次位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> c, <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>)</span> <span class=\"keyword\">const</span></span>;  <span class=\"comment\">//查找字符c第一次出现位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rfind</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str, <span class=\"keyword\">int</span> pos = npos)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//查找str最后一次位置,从pos开始查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rfind</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> pos = npos)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//查找s最后一次出现位置,从pos开始查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rfind</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//从pos查找s的前n个字符最后一次位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rfind</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> c, <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>)</span> <span class=\"keyword\">const</span></span>; <span class=\"comment\">//查找字符c最后一次出现位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">replace</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str)</span></span>; <span class=\"comment\">//替换从pos开始n个字符为字符串str</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">replace</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s)</span></span>; <span class=\"comment\">//替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"比较操作\"><a href=\"#比较操作\" class=\"headerlink\" title=\"比较操作\"></a>比较操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。</span></span><br><span class=\"line\"><span class=\"comment\">比较区分大小写，比较时参考字典顺序，排越前面的越小。</span></span><br><span class=\"line\"><span class=\"comment\">大写的A比小写的a小。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//与字符串s比较</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//与字符串s比较</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"string子串\"><a href=\"#string子串\" class=\"headerlink\" title=\"string子串\"></a>string子串</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">substr</span><span class=\"params\">(<span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> n = npos)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//返回由pos开始的n个字符组成的字符串</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入和删除操作\"><a href=\"#插入和删除操作\" class=\"headerlink\" title=\"插入和删除操作\"></a>插入和删除操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s)</span></span>; <span class=\"comment\">//插入字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str)</span></span>; <span class=\"comment\">//插入字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n, <span class=\"keyword\">char</span> c)</span></span>;<span class=\"comment\">//在指定位置插入n个字符c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">erase</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n = npos)</span></span>;<span class=\"comment\">//删除从Pos开始的n个字符</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"string和c-style字符串转换\"><a href=\"#string和c-style字符串转换\" class=\"headerlink\" title=\"string和c-style字符串转换\"></a>string和c-style字符串转换</h3><p><strong>const char*到string存在隐式类型转换，但是string不能自动类型转换为C_string。</strong></p>\n<figure class=\"highlight nimrod\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"built_in\">string</span> 转 <span class=\"built_in\">char</span>*</span><br><span class=\"line\"><span class=\"built_in\">string</span> str = <span class=\"string\">\"itcast\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">char</span>* cstr = str.c_str();</span><br><span class=\"line\"></span><br><span class=\"line\">//<span class=\"built_in\">char</span>* 转 <span class=\"built_in\">string</span> </span><br><span class=\"line\"><span class=\"built_in\">char</span>* s = <span class=\"string\">\"itcast\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> str(s);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"大小写转换\"><a href=\"#大小写转换\" class=\"headerlink\" title=\"大小写转换\"></a>大小写转换</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//大写转换</span></span><br><span class=\"line\"><span class=\"built_in\">toupper</span></span><br><span class=\"line\"><span class=\"comment\">//小写转换</span></span><br><span class=\"line\"><span class=\"built_in\">tolower</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h2><p>与普通数组不同的是，vector是<strong>动态空间</strong>，随着元素的加入，它的内部机制会<strong>自动扩充空间</strong>以容纳新元素。即把原空间拷贝到一块新空间，且vector提供的是<strong>随机访问迭代器</strong></p>\n<p><a href=\"https://miao.su/image/TPULP\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/30/vectormodel13ef3.md.png\" alt=\"vectormodel13ef3.md.png\"></a></p>\n<blockquote>\n<p>一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。</p>\n</blockquote>\n<ul>\n<li>构造、赋值</li>\n<li>大小 size 重置大小 resize 容量 capacity</li>\n<li>是否为空 empty </li>\n<li>巧用swap收缩空间 (匿名对象方法)</li>\n<li>reserve 预留空间</li>\n<li>insert 插入（迭代器） erase删除 （迭代器） clear（）清空容器</li>\n<li>pop_back 尾删 front返回第一个数据，back返回最后一个数据</li>\n<li>逆序遍历 使用reverse_iterator迭代器 (rbegin rend ++)</li>\n</ul>\n<h3 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;T&gt; v; <span class=\"comment\">//采用模板实现类实现，默认构造函数</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>(v.begin(), v.end());<span class=\"comment\">//将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>(n, elem);<span class=\"comment\">//构造函数将n个elem拷贝给本身。</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span> &amp;vec);<span class=\"comment\">//拷贝构造函数。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v1(arr, arr + <span class=\"keyword\">sizeof</span>(arr) / <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"需要注意的几个API\"><a href=\"#需要注意的几个API\" class=\"headerlink\" title=\"需要注意的几个API\"></a>需要注意的几个API</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resize(<span class=\"built_in\">int</span> <span class=\"built_in\">num</span>);<span class=\"comment\">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class=\"line\">resize(<span class=\"built_in\">int</span> <span class=\"built_in\">num</span>, elem);<span class=\"comment\">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</span></span><br><span class=\"line\">capacity();<span class=\"comment\">//容器的容量</span></span><br><span class=\"line\">reserve(<span class=\"built_in\">int</span> len);<span class=\"comment\">//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关于swap的技巧-通过匿名对象收缩空间\"><a href=\"#关于swap的技巧-通过匿名对象收缩空间\" class=\"headerlink\" title=\"关于swap的技巧(通过匿名对象收缩空间)\"></a>关于swap的技巧(通过匿名对象收缩空间)</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v1;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; ++i) &#123;</span><br><span class=\"line\">\tv1.push_back(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"容量 \"</span> &lt;&lt; v1.capacity() &lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//138255</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"大小 \"</span> &lt;&lt; v1.size() &lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//10000</span></span><br><span class=\"line\"></span><br><span class=\"line\">v1.resize(<span class=\"number\">3</span>);<span class=\"comment\">//进行resize后，元素大小变小了，但是容量依旧不变</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"容量 \"</span> &lt;&lt; v1.capacity() &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//138255</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"大小 \"</span> &lt;&lt; v1.size() &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(v1).swap(v1);<span class=\"comment\">//利用匿名对象，将v1传给拷贝给匿名对象时不会拷贝空的空间，即根据大小拷贝</span></span><br><span class=\"line\"><span class=\"comment\">//再进行匿名对象和v1的交换，实则交换指针指向，由于匿名对象的容量为v1元素大小，因此达到了收缩空间目的。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"容量 \"</span> &lt;&lt; v1.capacity() &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//3</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"大小 \"</span> &lt;&lt; v1.size() &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"reserve使用技巧\"><a href=\"#reserve使用技巧\" class=\"headerlink\" title=\"reserve使用技巧\"></a>reserve使用技巧</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>* p = <span class=\"literal\">NULL</span>;<span class=\"comment\">//原理：每次空间扩充p指向的便不再是原来vector空间的地址了</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//记录容器重新开辟了多少次空间</span></span><br><span class=\"line\"><span class=\"comment\">//在有些已知需要多大空间的情况下，为了提高效率，提前给vector容器分配好大空间减少不断进行动态增加空间的过程</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">v.reserve(<span class=\"number\">100000</span>);<span class=\"comment\">//不提前分配时，需要30次</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tv.push_back(i);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p != &amp;(v[<span class=\"number\">0</span>])) &#123;</span><br><span class=\"line\">\t\tp = &amp;(v[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t++num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; num &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//30 change 1</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>与vector的差别：支持头部删除 头部插入</p>\n<ul>\n<li>pop_front</li>\n<li>push_front</li>\n</ul>\n<blockquote>\n<p>Deque容器和vector容器最大的差异，一在于deque允许使用<strong>常数项</strong>时间对<strong>头端进行元素的插入和删除操作</strong>。二在于deque<strong>没有容量的概念</strong>，因为它是<strong>动态</strong>的以<strong>分段连续空间组合</strong>而成，随时可以增加一段新的空间并<strong>链接</strong>起来，</p>\n</blockquote>\n<p><a href=\"https://miao.su/image/TPI6Y\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/30/dequemodel9ffa4.md.png\" alt=\"dequemodel9ffa4.md.png\"></a></p>\n<blockquote>\n<p>Deque采取一块所谓的map(注意，不是STL的map容器)作为<strong>主控</strong>，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。<strong>缓冲区</strong>才是deque的存储空间的主体。</p>\n</blockquote>\n<p><a href=\"https://miao.su/image/TP34o\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/30/deque33cfe.md.png\" alt=\"deque33cfe.md.png\"></a></p>\n<p>PS:大学老师整的和小学老师没什么区别，这说明了什么问题:）</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Holiday-Note-18\"><a href=\"#Holiday-Note-18\" class=\"headerlink\" title=\"Holiday Note_18\"></a>Holiday Note_18</h1><p>使用<strong>STL</strong>写代码的确是方便了很多，STL提供的三大组件(<strong>容器</strong>，<strong>算法</strong>，<strong>迭代器</strong>)实现了<strong>数据和操作分离</strong>，数据由容器管理，操作由定制的算法定义，再由迭代器起将其二者连接，使得开发时多关注于实现功能的逻辑。而不用像以前一样，先定义好数据结构，再实现算法等一系列繁琐的步骤了。BUT 不简单啊。</p>","more":"<hr>\n<h2 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h2><p>string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span>();<span class=\"comment\">//创建一个空的字符串 例如: string str;      </span></span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str);<span class=\"comment\">//使用一个string对象初始化另一个string对象</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s);<span class=\"comment\">//使用字符串s初始化</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"keyword\">int</span> n, <span class=\"keyword\">char</span> c);<span class=\"comment\">//使用n个字符c初始化</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本赋值操作\"><a href=\"#基本赋值操作\" class=\"headerlink\" title=\"基本赋值操作\"></a>基本赋值操作</h3><p>相同达到功能使用string类成员.assign没有直接使用构造函数方便。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s);<span class=\"comment\">//char*类型字符串 赋值给当前的字符串</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s);<span class=\"comment\">//把字符串s赋给当前的字符串</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">char</span> c);<span class=\"comment\">//字符赋值给当前的字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">assign</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s)</span></span>;<span class=\"comment\">//把字符串s赋给当前的字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">assign</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">int</span> n)</span></span>;<span class=\"comment\">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">assign</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s)</span></span>;<span class=\"comment\">//把字符串s赋给当前字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">assign</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">char</span> c)</span></span>;<span class=\"comment\">//用n个字符c赋给当前字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">assign</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> n)</span></span>;<span class=\"comment\">//将s从start开始n个字符赋值给字符串</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存取字符操作\"><a href=\"#存取字符操作\" class=\"headerlink\" title=\"存取字符操作\"></a>存取字符操作</h3><p>使用at方式若越界会抛出<strong>out_of_range</strong>的异常，而使用[]越界程序会直接终止。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">int</span> n);<span class=\"comment\">//通过[]方式取字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>&amp; <span class=\"title\">at</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;<span class=\"comment\">//通过at方法获取字符</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"拼接操作\"><a href=\"#拼接操作\" class=\"headerlink\" title=\"拼接操作\"></a>拼接操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>+=(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str);<span class=\"comment\">//重载+=操作符</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>+=(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str);<span class=\"comment\">//重载+=操作符</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>+=(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> c);<span class=\"comment\">//重载+=操作符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">append</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s)</span></span>;<span class=\"comment\">//把字符串s连接到当前字符串结尾</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">append</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">int</span> n)</span></span>;<span class=\"comment\">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">append</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s)</span></span>;<span class=\"comment\">//同operator+=()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">append</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n)</span></span>;<span class=\"comment\">//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">append</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">char</span> c)</span></span>;<span class=\"comment\">//在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查找和替换\"><a href=\"#查找和替换\" class=\"headerlink\" title=\"查找和替换\"></a>查找和替换</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str, <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>)</span> <span class=\"keyword\">const</span></span>; <span class=\"comment\">//查找str第一次出现位置,从pos开始查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>)</span> <span class=\"keyword\">const</span></span>;  <span class=\"comment\">//查找s第一次出现位置,从pos开始查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n)</span> <span class=\"keyword\">const</span></span>;  <span class=\"comment\">//从pos位置查找s的前n个字符第一次位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> c, <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>)</span> <span class=\"keyword\">const</span></span>;  <span class=\"comment\">//查找字符c第一次出现位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rfind</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str, <span class=\"keyword\">int</span> pos = npos)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//查找str最后一次位置,从pos开始查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rfind</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> pos = npos)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//查找s最后一次出现位置,从pos开始查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rfind</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//从pos查找s的前n个字符最后一次位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rfind</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> c, <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>)</span> <span class=\"keyword\">const</span></span>; <span class=\"comment\">//查找字符c最后一次出现位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">replace</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str)</span></span>; <span class=\"comment\">//替换从pos开始n个字符为字符串str</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">replace</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s)</span></span>; <span class=\"comment\">//替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"比较操作\"><a href=\"#比较操作\" class=\"headerlink\" title=\"比较操作\"></a>比较操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。</span></span><br><span class=\"line\"><span class=\"comment\">比较区分大小写，比较时参考字典顺序，排越前面的越小。</span></span><br><span class=\"line\"><span class=\"comment\">大写的A比小写的a小。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//与字符串s比较</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//与字符串s比较</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"string子串\"><a href=\"#string子串\" class=\"headerlink\" title=\"string子串\"></a>string子串</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">substr</span><span class=\"params\">(<span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> n = npos)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//返回由pos开始的n个字符组成的字符串</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入和删除操作\"><a href=\"#插入和删除操作\" class=\"headerlink\" title=\"插入和删除操作\"></a>插入和删除操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s)</span></span>; <span class=\"comment\">//插入字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str)</span></span>; <span class=\"comment\">//插入字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n, <span class=\"keyword\">char</span> c)</span></span>;<span class=\"comment\">//在指定位置插入n个字符c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">erase</span><span class=\"params\">(<span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> n = npos)</span></span>;<span class=\"comment\">//删除从Pos开始的n个字符</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"string和c-style字符串转换\"><a href=\"#string和c-style字符串转换\" class=\"headerlink\" title=\"string和c-style字符串转换\"></a>string和c-style字符串转换</h3><p><strong>const char*到string存在隐式类型转换，但是string不能自动类型转换为C_string。</strong></p>\n<figure class=\"highlight nimrod\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"built_in\">string</span> 转 <span class=\"built_in\">char</span>*</span><br><span class=\"line\"><span class=\"built_in\">string</span> str = <span class=\"string\">\"itcast\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">char</span>* cstr = str.c_str();</span><br><span class=\"line\"></span><br><span class=\"line\">//<span class=\"built_in\">char</span>* 转 <span class=\"built_in\">string</span> </span><br><span class=\"line\"><span class=\"built_in\">char</span>* s = <span class=\"string\">\"itcast\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> str(s);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"大小写转换\"><a href=\"#大小写转换\" class=\"headerlink\" title=\"大小写转换\"></a>大小写转换</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//大写转换</span></span><br><span class=\"line\"><span class=\"built_in\">toupper</span></span><br><span class=\"line\"><span class=\"comment\">//小写转换</span></span><br><span class=\"line\"><span class=\"built_in\">tolower</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h2><p>与普通数组不同的是，vector是<strong>动态空间</strong>，随着元素的加入，它的内部机制会<strong>自动扩充空间</strong>以容纳新元素。即把原空间拷贝到一块新空间，且vector提供的是<strong>随机访问迭代器</strong></p>\n<p><a href=\"https://miao.su/image/TPULP\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/30/vectormodel13ef3.md.png\" alt=\"vectormodel13ef3.md.png\"></a></p>\n<blockquote>\n<p>一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。</p>\n</blockquote>\n<ul>\n<li>构造、赋值</li>\n<li>大小 size 重置大小 resize 容量 capacity</li>\n<li>是否为空 empty </li>\n<li>巧用swap收缩空间 (匿名对象方法)</li>\n<li>reserve 预留空间</li>\n<li>insert 插入（迭代器） erase删除 （迭代器） clear（）清空容器</li>\n<li>pop_back 尾删 front返回第一个数据，back返回最后一个数据</li>\n<li>逆序遍历 使用reverse_iterator迭代器 (rbegin rend ++)</li>\n</ul>\n<h3 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;T&gt; v; <span class=\"comment\">//采用模板实现类实现，默认构造函数</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>(v.begin(), v.end());<span class=\"comment\">//将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>(n, elem);<span class=\"comment\">//构造函数将n个elem拷贝给本身。</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span> &amp;vec);<span class=\"comment\">//拷贝构造函数。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v1(arr, arr + <span class=\"keyword\">sizeof</span>(arr) / <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"需要注意的几个API\"><a href=\"#需要注意的几个API\" class=\"headerlink\" title=\"需要注意的几个API\"></a>需要注意的几个API</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resize(<span class=\"built_in\">int</span> <span class=\"built_in\">num</span>);<span class=\"comment\">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class=\"line\">resize(<span class=\"built_in\">int</span> <span class=\"built_in\">num</span>, elem);<span class=\"comment\">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</span></span><br><span class=\"line\">capacity();<span class=\"comment\">//容器的容量</span></span><br><span class=\"line\">reserve(<span class=\"built_in\">int</span> len);<span class=\"comment\">//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关于swap的技巧-通过匿名对象收缩空间\"><a href=\"#关于swap的技巧-通过匿名对象收缩空间\" class=\"headerlink\" title=\"关于swap的技巧(通过匿名对象收缩空间)\"></a>关于swap的技巧(通过匿名对象收缩空间)</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v1;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; ++i) &#123;</span><br><span class=\"line\">\tv1.push_back(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"容量 \"</span> &lt;&lt; v1.capacity() &lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//138255</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"大小 \"</span> &lt;&lt; v1.size() &lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//10000</span></span><br><span class=\"line\"></span><br><span class=\"line\">v1.resize(<span class=\"number\">3</span>);<span class=\"comment\">//进行resize后，元素大小变小了，但是容量依旧不变</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"容量 \"</span> &lt;&lt; v1.capacity() &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//138255</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"大小 \"</span> &lt;&lt; v1.size() &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(v1).swap(v1);<span class=\"comment\">//利用匿名对象，将v1传给拷贝给匿名对象时不会拷贝空的空间，即根据大小拷贝</span></span><br><span class=\"line\"><span class=\"comment\">//再进行匿名对象和v1的交换，实则交换指针指向，由于匿名对象的容量为v1元素大小，因此达到了收缩空间目的。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"容量 \"</span> &lt;&lt; v1.capacity() &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//3</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"大小 \"</span> &lt;&lt; v1.size() &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"reserve使用技巧\"><a href=\"#reserve使用技巧\" class=\"headerlink\" title=\"reserve使用技巧\"></a>reserve使用技巧</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>* p = <span class=\"literal\">NULL</span>;<span class=\"comment\">//原理：每次空间扩充p指向的便不再是原来vector空间的地址了</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//记录容器重新开辟了多少次空间</span></span><br><span class=\"line\"><span class=\"comment\">//在有些已知需要多大空间的情况下，为了提高效率，提前给vector容器分配好大空间减少不断进行动态增加空间的过程</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">v.reserve(<span class=\"number\">100000</span>);<span class=\"comment\">//不提前分配时，需要30次</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; ++i) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tv.push_back(i);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p != &amp;(v[<span class=\"number\">0</span>])) &#123;</span><br><span class=\"line\">\t\tp = &amp;(v[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t++num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; num &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//30 change 1</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>与vector的差别：支持头部删除 头部插入</p>\n<ul>\n<li>pop_front</li>\n<li>push_front</li>\n</ul>\n<blockquote>\n<p>Deque容器和vector容器最大的差异，一在于deque允许使用<strong>常数项</strong>时间对<strong>头端进行元素的插入和删除操作</strong>。二在于deque<strong>没有容量的概念</strong>，因为它是<strong>动态</strong>的以<strong>分段连续空间组合</strong>而成，随时可以增加一段新的空间并<strong>链接</strong>起来，</p>\n</blockquote>\n<p><a href=\"https://miao.su/image/TPI6Y\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/30/dequemodel9ffa4.md.png\" alt=\"dequemodel9ffa4.md.png\"></a></p>\n<blockquote>\n<p>Deque采取一块所谓的map(注意，不是STL的map容器)作为<strong>主控</strong>，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。<strong>缓冲区</strong>才是deque的存储空间的主体。</p>\n</blockquote>\n<p><a href=\"https://miao.su/image/TP34o\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/30/deque33cfe.md.png\" alt=\"deque33cfe.md.png\"></a></p>\n<p>PS:大学老师整的和小学老师没什么区别，这说明了什么问题:）</p>"},{"title":"Intro","date":"2019-02-22T14:22:22.000Z","_content":"<h1 style=\"text-align:center\">Hello World <h1>\n\n![jon-tyson-473366-unsplashff5be.jpg](https://miao.su/images/2019/02/22/jon-tyson-473366-unsplashff5be.jpg)\n<!--more-->\n<h3 style=\"text-align:center\">My first blog with Github Pages + Hexo <h3>\n<h4 style>五六年级的时候, 便逐渐抛掉了写日记这个从幼儿园坚持起的习惯, 闲来无事之际从书柜角落里拿来翻阅, 时而笑得前俯后仰捧腹大笑, 时而为儿时所做的荒唐事感叹不已, 如今重拾那三脚猫的文字功夫操练一番, 记录大学这四年我究竟折腾了什么名堂, 想来某一天翻看的时候一定是趣味良多<h4>\n\n\n\n \n \n \n\n\n","source":"_posts/Intro.md","raw":"---\ntitle: Intro\ndate: 2019-02-22 22:22:22\ncategories: Life\ntags: [Time, Life]\n---\n<h1 style=\"text-align:center\">Hello World <h1>\n\n![jon-tyson-473366-unsplashff5be.jpg](https://miao.su/images/2019/02/22/jon-tyson-473366-unsplashff5be.jpg)\n<!--more-->\n<h3 style=\"text-align:center\">My first blog with Github Pages + Hexo <h3>\n<h4 style>五六年级的时候, 便逐渐抛掉了写日记这个从幼儿园坚持起的习惯, 闲来无事之际从书柜角落里拿来翻阅, 时而笑得前俯后仰捧腹大笑, 时而为儿时所做的荒唐事感叹不已, 如今重拾那三脚猫的文字功夫操练一番, 记录大学这四年我究竟折腾了什么名堂, 想来某一天翻看的时候一定是趣味良多<h4>\n\n\n\n \n \n \n\n\n","slug":"Intro","published":1,"updated":"2019-02-22T15:27:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihv001msmjbvdgt9q7h","content":"<h1 style=\"text-align:center\">Hello World <h1>\n\n<p><img src=\"https://miao.su/images/2019/02/22/jon-tyson-473366-unsplashff5be.jpg\" alt=\"jon-tyson-473366-unsplashff5be.jpg\"></p>\n<a id=\"more\"></a>\n<h3 style=\"text-align:center\">My first blog with Github Pages + Hexo <h3>\n<h4 style>五六年级的时候, 便逐渐抛掉了写日记这个从幼儿园坚持起的习惯, 闲来无事之际从书柜角落里拿来翻阅, 时而笑得前俯后仰捧腹大笑, 时而为儿时所做的荒唐事感叹不已, 如今重拾那三脚猫的文字功夫操练一番, 记录大学这四年我究竟折腾了什么名堂, 想来某一天翻看的时候一定是趣味良多<h4>\n\n\n\n\n\n\n\n\n</h4></h4></h3></h3></h1></h1>","site":{"data":{}},"excerpt":"<h1 style=\"text-align:center\">Hello World <h1>\n\n<p><img src=\"https://miao.su/images/2019/02/22/jon-tyson-473366-unsplashff5be.jpg\" alt=\"jon-tyson-473366-unsplashff5be.jpg\"></p>","more":"<h3 style=\"text-align:center\">My first blog with Github Pages + Hexo <h3>\n<h4 style>五六年级的时候, 便逐渐抛掉了写日记这个从幼儿园坚持起的习惯, 闲来无事之际从书柜角落里拿来翻阅, 时而笑得前俯后仰捧腹大笑, 时而为儿时所做的荒唐事感叹不已, 如今重拾那三脚猫的文字功夫操练一番, 记录大学这四年我究竟折腾了什么名堂, 想来某一天翻看的时候一定是趣味良多<h4>\n\n\n\n\n\n\n\n\n</h4></h4></h3></h3></h1></h1>"},{"title":"Weekly Report 1","date":"2019-07-19T14:03:33.000Z","_content":"\n# Weekly Report 1\n\n一周了，把杂乱事儿都记录下。\n\n开始写的时候，本想先把这周手机屏幕使用时间和Forest的截屏传一下的，可惜手机还是锁着的——说实话Forest(专注森林)这个app已经对我没什么用了，至于为什么还在用，就是因为锁俩小时手机可以有43金币，2000金币可以种一棵树。而且还有一点就是IOS有一个统计屏幕使用时间的功能，我正在努力的将这个数字变小，变小。\n\n\n[![72ad41b9c5f5a211c5a45e300c34e8847de5.md.jpg](https://miao.su/images/2019/07/19/72ad41b9c5f5a211c5a45e300c34e8847de5.md.jpg)](https://miao.su/image/T3uHf)\n\n\n<!-- more -->\n\n\n\n先做个大概的总结吧：吃了一周的外卖，下过一次楼而且那一次顺便倒垃圾加取快递加和一好哥们吃烧烤。白天看视频敲代码，晚上总结笔记发完博客还有空余时间要不就是看书要不就是预习之后的内容。可以说是非常的无聊了。\n\n隔壁的舍友，7点准时出门去现教自习，中午12点半回来，下午两点又出门到十点半才回来，日复一日。每次想玩的时候看看他就冷静了。他12月底考研二战；我的话，大厂的提前批大概2月底开始，时间都不多，共勉。\n\n每晚总结白天的代码还是挺有意思的一件事，很多时候白天只是赶进度把功能快快实现一遍然后接着看后边的视频。晚上写总结的时候，不只是简单回忆了一遍白天学习的知识，而且强行逼着自己写总结也让印象加深了许多。\n>费曼原理大致是这么讲的，要想掌握一个知识，最有效的方式就是把一个不会的人教懂\n\n写博客的意义也正是在此了。虽然这个假期开始更新博客的主要目的是怕自己学一天忘两天，当作一个笔记和总结的功能在写，后边想想将一段代码总结出来的质量实际也是对这个知识的理解程度和掌握程度的深浅。\n\n很多时候明明感觉这个函数的功能或者这个知识点的含义心里边很清楚，但一用文字或语言去表述时却出不来一个字。其实说白了就是理解的层次低，感觉很懂却经不起一点点的推敲，仅仅浮于表面罢了。\n\n通过总结，的确锻炼了自己对自己白天学习知识的思考能力，但貌似我每天写的东西太冗杂了，白天已经写好的代码，稍微修改就大段大段的copy过来，然后做一个总结，其实我自己都不想细看。\n\n所以我打算下周将每天笔记的代码量压缩，只把核心代码和需要重点思考理解的代码放进来，这样，也方便我自己今后阅读。\n\n\n*不知道什么时候能把书架上的这些书给读完*\n![68a63097e38aae32ef1fe6aba8808a14de99.jpg](https://miao.su/images/2019/07/19/68a63097e38aae32ef1fe6aba8808a14de99.jpg)\n\n\n另外，这周开始看《编程珠玑》和《C陷阱与缺陷》了，按我目前的阅读进度来说，前者有些太深了，前言明明写着阅读本书的唯一背景知识就是某种高级语言的编程经验，结果开篇就以一个磁盘文件排序为引子开始不断思考并解决问题，嗯，都是些我看不懂的东西。但是仅仅从这么三言两语就可以从中感受到这是一本非常棒的的著作，引导你的思维方式不断进行创新性思考去解决问题；后者的话刚开始看感觉很贴切实际，直白且准确的告诉你使用C编程时容易犯的错误。让我感到震惊的是，这本神书大概是1988发行到现在的几十个印刷版本中除了第二次修改了一些问题再无任何修正。或许这就是大佬吧，三十年总结的错误现在的程序员还在大量的犯。这两本书共同点都是有课后题，而且都是些可以激起你深入去思考解决的问题，非常的nice，看起来着实津津有味。和什么XX天学会XX语言一类的教材简直是一个天一个地。\n\n叨叨完了，下边可以上图了。\n\n多说一句，手机电池还是蛮耐用的，整整四天还有23%。发现手机现在除了点外卖。。。一无是处🤣\n\n[![f7b70e4e29589ac9c6e1b3f150a885b87385.md.png](https://miao.su/images/2019/07/19/f7b70e4e29589ac9c6e1b3f150a885b87385.md.png)](https://miao.su/image/T3rs8)\n[![670c48bae35e7b18035a3d76fdbaacd9de08.md.png](https://miao.su/images/2019/07/19/670c48bae35e7b18035a3d76fdbaacd9de08.md.png)](https://miao.su/image/T3d66)\n\n[![73e655a615dd2cf80e490599358cfb047570.md.png](https://miao.su/images/2019/07/19/73e655a615dd2cf80e490599358cfb047570.md.png)](https://miao.su/image/T3MI9)\n[![2209a1ada0976f1c61a4bb036ff58b97a32e.md.png](https://miao.su/images/2019/07/19/2209a1ada0976f1c61a4bb036ff58b97a32e.md.png)](https://miao.su/image/T3J4a)\n[![eefbaa0e86ab968d422195af5e5bd6cdfbc3.md.png](https://miao.su/images/2019/07/19/eefbaa0e86ab968d422195af5e5bd6cdfbc3.md.png)](https://miao.su/image/T3xpL)","source":"_posts/XBB01.md","raw":"---\ntitle: Weekly Report 1\ndate: 2019-07-19 22:03:33\ncategories: Life\ntags: [Time, Life]\n---\n\n# Weekly Report 1\n\n一周了，把杂乱事儿都记录下。\n\n开始写的时候，本想先把这周手机屏幕使用时间和Forest的截屏传一下的，可惜手机还是锁着的——说实话Forest(专注森林)这个app已经对我没什么用了，至于为什么还在用，就是因为锁俩小时手机可以有43金币，2000金币可以种一棵树。而且还有一点就是IOS有一个统计屏幕使用时间的功能，我正在努力的将这个数字变小，变小。\n\n\n[![72ad41b9c5f5a211c5a45e300c34e8847de5.md.jpg](https://miao.su/images/2019/07/19/72ad41b9c5f5a211c5a45e300c34e8847de5.md.jpg)](https://miao.su/image/T3uHf)\n\n\n<!-- more -->\n\n\n\n先做个大概的总结吧：吃了一周的外卖，下过一次楼而且那一次顺便倒垃圾加取快递加和一好哥们吃烧烤。白天看视频敲代码，晚上总结笔记发完博客还有空余时间要不就是看书要不就是预习之后的内容。可以说是非常的无聊了。\n\n隔壁的舍友，7点准时出门去现教自习，中午12点半回来，下午两点又出门到十点半才回来，日复一日。每次想玩的时候看看他就冷静了。他12月底考研二战；我的话，大厂的提前批大概2月底开始，时间都不多，共勉。\n\n每晚总结白天的代码还是挺有意思的一件事，很多时候白天只是赶进度把功能快快实现一遍然后接着看后边的视频。晚上写总结的时候，不只是简单回忆了一遍白天学习的知识，而且强行逼着自己写总结也让印象加深了许多。\n>费曼原理大致是这么讲的，要想掌握一个知识，最有效的方式就是把一个不会的人教懂\n\n写博客的意义也正是在此了。虽然这个假期开始更新博客的主要目的是怕自己学一天忘两天，当作一个笔记和总结的功能在写，后边想想将一段代码总结出来的质量实际也是对这个知识的理解程度和掌握程度的深浅。\n\n很多时候明明感觉这个函数的功能或者这个知识点的含义心里边很清楚，但一用文字或语言去表述时却出不来一个字。其实说白了就是理解的层次低，感觉很懂却经不起一点点的推敲，仅仅浮于表面罢了。\n\n通过总结，的确锻炼了自己对自己白天学习知识的思考能力，但貌似我每天写的东西太冗杂了，白天已经写好的代码，稍微修改就大段大段的copy过来，然后做一个总结，其实我自己都不想细看。\n\n所以我打算下周将每天笔记的代码量压缩，只把核心代码和需要重点思考理解的代码放进来，这样，也方便我自己今后阅读。\n\n\n*不知道什么时候能把书架上的这些书给读完*\n![68a63097e38aae32ef1fe6aba8808a14de99.jpg](https://miao.su/images/2019/07/19/68a63097e38aae32ef1fe6aba8808a14de99.jpg)\n\n\n另外，这周开始看《编程珠玑》和《C陷阱与缺陷》了，按我目前的阅读进度来说，前者有些太深了，前言明明写着阅读本书的唯一背景知识就是某种高级语言的编程经验，结果开篇就以一个磁盘文件排序为引子开始不断思考并解决问题，嗯，都是些我看不懂的东西。但是仅仅从这么三言两语就可以从中感受到这是一本非常棒的的著作，引导你的思维方式不断进行创新性思考去解决问题；后者的话刚开始看感觉很贴切实际，直白且准确的告诉你使用C编程时容易犯的错误。让我感到震惊的是，这本神书大概是1988发行到现在的几十个印刷版本中除了第二次修改了一些问题再无任何修正。或许这就是大佬吧，三十年总结的错误现在的程序员还在大量的犯。这两本书共同点都是有课后题，而且都是些可以激起你深入去思考解决的问题，非常的nice，看起来着实津津有味。和什么XX天学会XX语言一类的教材简直是一个天一个地。\n\n叨叨完了，下边可以上图了。\n\n多说一句，手机电池还是蛮耐用的，整整四天还有23%。发现手机现在除了点外卖。。。一无是处🤣\n\n[![f7b70e4e29589ac9c6e1b3f150a885b87385.md.png](https://miao.su/images/2019/07/19/f7b70e4e29589ac9c6e1b3f150a885b87385.md.png)](https://miao.su/image/T3rs8)\n[![670c48bae35e7b18035a3d76fdbaacd9de08.md.png](https://miao.su/images/2019/07/19/670c48bae35e7b18035a3d76fdbaacd9de08.md.png)](https://miao.su/image/T3d66)\n\n[![73e655a615dd2cf80e490599358cfb047570.md.png](https://miao.su/images/2019/07/19/73e655a615dd2cf80e490599358cfb047570.md.png)](https://miao.su/image/T3MI9)\n[![2209a1ada0976f1c61a4bb036ff58b97a32e.md.png](https://miao.su/images/2019/07/19/2209a1ada0976f1c61a4bb036ff58b97a32e.md.png)](https://miao.su/image/T3J4a)\n[![eefbaa0e86ab968d422195af5e5bd6cdfbc3.md.png](https://miao.su/images/2019/07/19/eefbaa0e86ab968d422195af5e5bd6cdfbc3.md.png)](https://miao.su/image/T3xpL)","slug":"XBB01","published":1,"updated":"2019-07-21T01:02:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihw001qsmjbkn80gks0","content":"<h1 id=\"Weekly-Report-1\"><a href=\"#Weekly-Report-1\" class=\"headerlink\" title=\"Weekly Report 1\"></a>Weekly Report 1</h1><p>一周了，把杂乱事儿都记录下。</p>\n<p>开始写的时候，本想先把这周手机屏幕使用时间和Forest的截屏传一下的，可惜手机还是锁着的——说实话Forest(专注森林)这个app已经对我没什么用了，至于为什么还在用，就是因为锁俩小时手机可以有43金币，2000金币可以种一棵树。而且还有一点就是IOS有一个统计屏幕使用时间的功能，我正在努力的将这个数字变小，变小。</p>\n<p><a href=\"https://miao.su/image/T3uHf\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/19/72ad41b9c5f5a211c5a45e300c34e8847de5.md.jpg\" alt=\"72ad41b9c5f5a211c5a45e300c34e8847de5.md.jpg\"></a></p>\n<a id=\"more\"></a>\n\n\n\n<p>先做个大概的总结吧：吃了一周的外卖，下过一次楼而且那一次顺便倒垃圾加取快递加和一好哥们吃烧烤。白天看视频敲代码，晚上总结笔记发完博客还有空余时间要不就是看书要不就是预习之后的内容。可以说是非常的无聊了。</p>\n<p>隔壁的舍友，7点准时出门去现教自习，中午12点半回来，下午两点又出门到十点半才回来，日复一日。每次想玩的时候看看他就冷静了。他12月底考研二战；我的话，大厂的提前批大概2月底开始，时间都不多，共勉。</p>\n<p>每晚总结白天的代码还是挺有意思的一件事，很多时候白天只是赶进度把功能快快实现一遍然后接着看后边的视频。晚上写总结的时候，不只是简单回忆了一遍白天学习的知识，而且强行逼着自己写总结也让印象加深了许多。</p>\n<blockquote>\n<p>费曼原理大致是这么讲的，要想掌握一个知识，最有效的方式就是把一个不会的人教懂</p>\n</blockquote>\n<p>写博客的意义也正是在此了。虽然这个假期开始更新博客的主要目的是怕自己学一天忘两天，当作一个笔记和总结的功能在写，后边想想将一段代码总结出来的质量实际也是对这个知识的理解程度和掌握程度的深浅。</p>\n<p>很多时候明明感觉这个函数的功能或者这个知识点的含义心里边很清楚，但一用文字或语言去表述时却出不来一个字。其实说白了就是理解的层次低，感觉很懂却经不起一点点的推敲，仅仅浮于表面罢了。</p>\n<p>通过总结，的确锻炼了自己对自己白天学习知识的思考能力，但貌似我每天写的东西太冗杂了，白天已经写好的代码，稍微修改就大段大段的copy过来，然后做一个总结，其实我自己都不想细看。</p>\n<p>所以我打算下周将每天笔记的代码量压缩，只把核心代码和需要重点思考理解的代码放进来，这样，也方便我自己今后阅读。</p>\n<p><em>不知道什么时候能把书架上的这些书给读完</em><br><img src=\"https://miao.su/images/2019/07/19/68a63097e38aae32ef1fe6aba8808a14de99.jpg\" alt=\"68a63097e38aae32ef1fe6aba8808a14de99.jpg\"></p>\n<p>另外，这周开始看《编程珠玑》和《C陷阱与缺陷》了，按我目前的阅读进度来说，前者有些太深了，前言明明写着阅读本书的唯一背景知识就是某种高级语言的编程经验，结果开篇就以一个磁盘文件排序为引子开始不断思考并解决问题，嗯，都是些我看不懂的东西。但是仅仅从这么三言两语就可以从中感受到这是一本非常棒的的著作，引导你的思维方式不断进行创新性思考去解决问题；后者的话刚开始看感觉很贴切实际，直白且准确的告诉你使用C编程时容易犯的错误。让我感到震惊的是，这本神书大概是1988发行到现在的几十个印刷版本中除了第二次修改了一些问题再无任何修正。或许这就是大佬吧，三十年总结的错误现在的程序员还在大量的犯。这两本书共同点都是有课后题，而且都是些可以激起你深入去思考解决的问题，非常的nice，看起来着实津津有味。和什么XX天学会XX语言一类的教材简直是一个天一个地。</p>\n<p>叨叨完了，下边可以上图了。</p>\n<p>多说一句，手机电池还是蛮耐用的，整整四天还有23%。发现手机现在除了点外卖。。。一无是处🤣</p>\n<p><a href=\"https://miao.su/image/T3rs8\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/19/f7b70e4e29589ac9c6e1b3f150a885b87385.md.png\" alt=\"f7b70e4e29589ac9c6e1b3f150a885b87385.md.png\"></a><br><a href=\"https://miao.su/image/T3d66\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/19/670c48bae35e7b18035a3d76fdbaacd9de08.md.png\" alt=\"670c48bae35e7b18035a3d76fdbaacd9de08.md.png\"></a></p>\n<p><a href=\"https://miao.su/image/T3MI9\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/19/73e655a615dd2cf80e490599358cfb047570.md.png\" alt=\"73e655a615dd2cf80e490599358cfb047570.md.png\"></a><br><a href=\"https://miao.su/image/T3J4a\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/19/2209a1ada0976f1c61a4bb036ff58b97a32e.md.png\" alt=\"2209a1ada0976f1c61a4bb036ff58b97a32e.md.png\"></a><br><a href=\"https://miao.su/image/T3xpL\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/19/eefbaa0e86ab968d422195af5e5bd6cdfbc3.md.png\" alt=\"eefbaa0e86ab968d422195af5e5bd6cdfbc3.md.png\"></a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Weekly-Report-1\"><a href=\"#Weekly-Report-1\" class=\"headerlink\" title=\"Weekly Report 1\"></a>Weekly Report 1</h1><p>一周了，把杂乱事儿都记录下。</p>\n<p>开始写的时候，本想先把这周手机屏幕使用时间和Forest的截屏传一下的，可惜手机还是锁着的——说实话Forest(专注森林)这个app已经对我没什么用了，至于为什么还在用，就是因为锁俩小时手机可以有43金币，2000金币可以种一棵树。而且还有一点就是IOS有一个统计屏幕使用时间的功能，我正在努力的将这个数字变小，变小。</p>\n<p><a href=\"https://miao.su/image/T3uHf\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/19/72ad41b9c5f5a211c5a45e300c34e8847de5.md.jpg\" alt=\"72ad41b9c5f5a211c5a45e300c34e8847de5.md.jpg\"></a></p>","more":"<p>先做个大概的总结吧：吃了一周的外卖，下过一次楼而且那一次顺便倒垃圾加取快递加和一好哥们吃烧烤。白天看视频敲代码，晚上总结笔记发完博客还有空余时间要不就是看书要不就是预习之后的内容。可以说是非常的无聊了。</p>\n<p>隔壁的舍友，7点准时出门去现教自习，中午12点半回来，下午两点又出门到十点半才回来，日复一日。每次想玩的时候看看他就冷静了。他12月底考研二战；我的话，大厂的提前批大概2月底开始，时间都不多，共勉。</p>\n<p>每晚总结白天的代码还是挺有意思的一件事，很多时候白天只是赶进度把功能快快实现一遍然后接着看后边的视频。晚上写总结的时候，不只是简单回忆了一遍白天学习的知识，而且强行逼着自己写总结也让印象加深了许多。</p>\n<blockquote>\n<p>费曼原理大致是这么讲的，要想掌握一个知识，最有效的方式就是把一个不会的人教懂</p>\n</blockquote>\n<p>写博客的意义也正是在此了。虽然这个假期开始更新博客的主要目的是怕自己学一天忘两天，当作一个笔记和总结的功能在写，后边想想将一段代码总结出来的质量实际也是对这个知识的理解程度和掌握程度的深浅。</p>\n<p>很多时候明明感觉这个函数的功能或者这个知识点的含义心里边很清楚，但一用文字或语言去表述时却出不来一个字。其实说白了就是理解的层次低，感觉很懂却经不起一点点的推敲，仅仅浮于表面罢了。</p>\n<p>通过总结，的确锻炼了自己对自己白天学习知识的思考能力，但貌似我每天写的东西太冗杂了，白天已经写好的代码，稍微修改就大段大段的copy过来，然后做一个总结，其实我自己都不想细看。</p>\n<p>所以我打算下周将每天笔记的代码量压缩，只把核心代码和需要重点思考理解的代码放进来，这样，也方便我自己今后阅读。</p>\n<p><em>不知道什么时候能把书架上的这些书给读完</em><br><img src=\"https://miao.su/images/2019/07/19/68a63097e38aae32ef1fe6aba8808a14de99.jpg\" alt=\"68a63097e38aae32ef1fe6aba8808a14de99.jpg\"></p>\n<p>另外，这周开始看《编程珠玑》和《C陷阱与缺陷》了，按我目前的阅读进度来说，前者有些太深了，前言明明写着阅读本书的唯一背景知识就是某种高级语言的编程经验，结果开篇就以一个磁盘文件排序为引子开始不断思考并解决问题，嗯，都是些我看不懂的东西。但是仅仅从这么三言两语就可以从中感受到这是一本非常棒的的著作，引导你的思维方式不断进行创新性思考去解决问题；后者的话刚开始看感觉很贴切实际，直白且准确的告诉你使用C编程时容易犯的错误。让我感到震惊的是，这本神书大概是1988发行到现在的几十个印刷版本中除了第二次修改了一些问题再无任何修正。或许这就是大佬吧，三十年总结的错误现在的程序员还在大量的犯。这两本书共同点都是有课后题，而且都是些可以激起你深入去思考解决的问题，非常的nice，看起来着实津津有味。和什么XX天学会XX语言一类的教材简直是一个天一个地。</p>\n<p>叨叨完了，下边可以上图了。</p>\n<p>多说一句，手机电池还是蛮耐用的，整整四天还有23%。发现手机现在除了点外卖。。。一无是处🤣</p>\n<p><a href=\"https://miao.su/image/T3rs8\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/19/f7b70e4e29589ac9c6e1b3f150a885b87385.md.png\" alt=\"f7b70e4e29589ac9c6e1b3f150a885b87385.md.png\"></a><br><a href=\"https://miao.su/image/T3d66\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/19/670c48bae35e7b18035a3d76fdbaacd9de08.md.png\" alt=\"670c48bae35e7b18035a3d76fdbaacd9de08.md.png\"></a></p>\n<p><a href=\"https://miao.su/image/T3MI9\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/19/73e655a615dd2cf80e490599358cfb047570.md.png\" alt=\"73e655a615dd2cf80e490599358cfb047570.md.png\"></a><br><a href=\"https://miao.su/image/T3J4a\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/19/2209a1ada0976f1c61a4bb036ff58b97a32e.md.png\" alt=\"2209a1ada0976f1c61a4bb036ff58b97a32e.md.png\"></a><br><a href=\"https://miao.su/image/T3xpL\" target=\"_blank\" rel=\"noopener\"><img src=\"https://miao.su/images/2019/07/19/eefbaa0e86ab968d422195af5e5bd6cdfbc3.md.png\" alt=\"eefbaa0e86ab968d422195af5e5bd6cdfbc3.md.png\"></a></p>"},{"title":"笑傲江湖DEMO","date":"2019-02-28T13:22:20.000Z","_content":"<h1 style=\"text-align:center\">My first console game demo <h1>\n\n![2019-02-2831b3de.png](https://miao.su/images/2019/02/28/2019-02-2831b3de.png)\n<!-- more -->\n\n\n这个demo简单的实现了用户输入方向键, 数字键达到在不同地图切换, 购买商品, 打怪升级等功能, 希望在后期能够实现更加丰富的功能并且能连接网络对战, \n开发环境为Atom,CodeBlocks,MinGW\n\n\n## 数据类型\n1. 道具\n2. 地图\n3. 背包(背包包括道具类型)\n4. 门派\n5. 玩家(玩家包含背包以及门派数据类型)\n6. 怪物\n\n### 道具 (Prop)\n\n**属性字段**\n\n|属性|定义|\n|:-:|:-:|\n|编号|int id|\n|名称|char name[30]|\n|价格|double price|\n|等级|int level|\n|库存|int stock|\n|类别|propType type(使用枚举)|\n|最小属性|union(使用联合体)|\n|最大属性|union(使用联合体)|\n|描述|char desc[200]|\n\n\n枚举代码\n~~~\ntypedef enum _propType {\n    Weapon,     //武器\n    Armor,      //防具\n    Con,        //消耗品\n    Frag,       //碎片\n} Type;\n~~~\n联合体代码  (不同类别拥有不同属性类别)\n~~~\nunion {\n    int minAttack;     //如果是武器类别, 则最 低/高 攻击力为\n    int minDefence;    //如果是防具类别, 则最 低/高 防御力为\n    int minPower;      //如果是消耗品类别, 则最 低/高 回复值为\n}\n~~~\n~~~\n要注意若定义枚举中使用 ; 分隔开, 则报错如下(这是我自己踩过的一个坑)\nExpected '= constant-expression' or end of enumerator definition\n~~~\n\n\n### 地图(Map)\n- 该DEMO的地图大小为8 * 8\n- 后期增加地图进入的等级限制\n\n**属性字段** \n\n|属性|定义|\n|:-:|:-:|\n|编号|int id|\n|名称|char name[20]|\n|进入地图的最低等级|minLevel|\n|坐标结构|COORD coord|\n|地图描述|desc[500]|\n~~~\n地图的坐标使用window.h头文件下的COORD结构, 使用方式为coord.X = 0, coord.Y = 0\n~~~\n\n### 背包 (Bag)\n- 背包类型是玩家的一个属性\n- 后期改进实现人民币玩家可以提升背包容量上限\n\n**属性字段**\n\n|属性|定义|\n|:-:|:-:|\n|所属玩家ID|int playId|\n|当前的道具数量|int propsCount|\n|背包最大容量|maxCount|\n|道具数组|Prop props|\n\n### 门派 (Martial)\n- 门派为玩家的一个属性\n- 后期改进实现人名币玩家解锁更多帮派功能\n\n**属性字段**\n\n|属性|定义|\n|:-:|:-:|\n|编号|int id|\n|名称|char name[20]|\n|门派类型|char type[10]|\n|门派总部坐标结构|COORD hqCoord|\n|是否对玩家开放|int isOpen|\n|门派描述|char desc[1000]|\n\n### 玩家 (Player)\n\n**属性字段**\n\n|属性|定义|\n|:-:|:-:|\n|名称|char name[30]|\n|编号|id[10]|\n|密码|char passwd[30]|\n|等级|int level|\n|经验值|int exp|\n|血量|int hp|\n|内力|int mp|\n|金币|int gold|\n|门派结构|Martial martial|\n|武器道具|Prop weapon|\n|防具道具|Prop armor|\n|玩家当前坐标|COORD coord|\n|背包结构|Bag bag|\n\n### 怪物 (Monster)\n- 后期加入怪物掉落装备功能\n\n**属性字段**\n\n|属性|定义|\n|:-:|:-:|\n|编号|int id|\n|名称|char name[20]|\n|等级|int level|\n|血量|int hp|\n|攻击力|int attact|\n|防御力|int defence|\n|掉落的最小金币|int minMoney|\n|掉落的最大金币|int maxMoney|\n|玩家能够获取的最大经验|int exp|\n|怪物的状态(0死1活)|int state|\n|怪物的坐标|COORD coord|\n***\n## 功能实现\n\n**通过系统函数辅助实现的方法, 以下方法在GameLib源文件中**\n1. 更改控制台标题(SetTitle)\n2. 更改控制台内字体(SetColor)\n3. 设置控制台内光标的位置(SetPosition)\n  \n### 更改控制台标题(SetTitle)\n~~~\n/** 设置控制台的标题 */\nvoid SetTitle(char *title) {\n    SetConsoleTitle(title);     //调用windows.h头文件下的系统函数\n}\n~~~\n### 更改控制台内字体(SetColor)\n~~~\n/* 设置控制台的颜色\n * 0-黑色,   1-蓝色,   2-绿色,    3-浅绿色,  4-红色,\n * 5-紫色,   6-黄色,   7-白色,    8-灰色,   9-淡蓝色,\n * 10-淡绿色,  11-淡浅绿色   12-淡红色   13-淡紫色\n * 14-淡黄色   15-亮白色\n */\nvoid SetColor(int ForeColor, int BackColor) {//分别设置前景色与背景色\n     //HANDLE: 句柄, GetStdHandle(STD_OUTPUT_HANDLE)获得标准输出流的句柄, 均为windows.h下的系统函数\n     HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);       //获取当前窗口句柄\n     SetConsoleTextAttribute(handle, ForeColor + BackColor * 0x10);//设置颜色\n   \n    //句柄(HANDLE)补充:\n    //WINDOWS程序中并不是用物理地址来标识一个内存块，文件，任务或动态装入模块的。\n    //相反，WINDOWS API给这些项目分配确定的句柄并将句柄返回给应用程序，\n    //然后通过句柄来进行操作(句柄不是指针, 是32或64位的无符号整型)\n }\n~~~\n### 设置控制台内光标的位置(SetPosition)\n~~~\nvoid SetPosition(int x, int y) {\n     HANDLE winHandle = GetStdHandle(STD_OUTPUT_HANDLE);\n     COORD pos = {x, y};\n     //SetConsoleCursorPosition()为windows.h下系统函数\n     SetConsoleCursorPosition(winHandle, pos);      //设置光标位置\n }\n~~~\n***\n**以下方法为自己定义实现游戏主要逻辑功能中比较重要的几个, 在Game源文件中**\n1. **GameProcess():** 接收并判断用户的输入, 返回游戏的各个功能(例如用户输入方向键将会移动玩家的所在地图,输入1会显示玩家的个人信息窗口等等)这是游戏最重要的一个方法, 决定了游戏的逻辑实现, 本人水平较差, 当初没有想到将所有的操作均封装到此方法来, 因此使得判断用户输入包括方向键的接收为一个方法并且放入于main()中, 导致了维护困难, 代码不清晰等等问题 \n2. **Clear():** 功能为清理指定区域内的所有字符, 用'\\0'替代, 达到刷新屏幕的功能, 由于清屏操作需要使用的次数极多因此封装成方法\n3. **ShowMonster():** 该方法为显示当前地图所有怪物的信息: 等级名称, 但是我却在一个方法包含了接收用户输入导致方法过于复杂难以复用维护, 而且此方法打印怪物使用指针以及辅助数组较难理解\n4. **MonsterFight():** 接收用户输入的怪物编号, 让玩家与怪物进行战斗, 以当前时间为种子, 攻击力防御力取范围该范围内的随机数, 战斗后返回判断打印不同情况的结果 \n5. **PropInit():** 初始化游戏玩家数据, 用于测试功能 \n6. **Trade():** 交易方法, 接收游戏玩家编号与商品编号, 重点为判断无法交易的情况以及对背包物品的添加(背包已有该类别商品/背包暂无此类别商品) \n7. **ShowProps():** 显示商城的信息, 此方法与ShowMonster()类似,  同样我没考虑到方法的复用以及维护, 将Show 和 接收用户的输入 两个方法写在一个方法里了\n8. **showTrade():** 接收Trade()返回的值, 对应交易成功与失败分别执行不同操作\n9. **Login():** 登陆方法, 接收用户输入的用户名以及密码(无回显)进行判断以达到登陆功能\n\n#### 以下为主要方法的源代码\n- 一些宏定义, 例如游戏窗口的各个部分的行数等等, 在移动光标时使用频率极高\n~~~\n#define COL 78                //游戏的界面的总宽度\n#define MAXGIN_X 20           //游戏界面与控制台的左边距\n#define ENDINFO 78            //各个框架结束'|'的列数\n#define MAPSART_START_Y 3     //游戏地图开始的行\n#define MAPSART_END_Y 11      //游戏地图结束行\n#define INFORMATION_START_Y 12//游戏信息开始行\n#define INFORMATION_END_Y 19  //游戏信息结束行\n#define MAINMENUE_START_Y 20  //游戏主菜单开始行\n#define MAINMENUE_END_Y 28    //游戏主菜单结束行\n#define SEP \"*******************************************************************************\"\n~~~\n- 游戏主体的逻辑实现\n~~~\n接收main()传递的key, 分别执行不同的功能\n/** 执行游戏主菜单功能 */\nvoid GameProcess(char key) {\n    switch (key) {\n        case '1': ShowPlayerInfo();//显示玩家个人信息\n            break;\n        case '2': ShowMonster();//显示当前地图的怪物(内有打怪)\n            break;\n        case '3': Move(currPlayer->martial.hqCoord.X, currPlayer->martial.hqCoord.Y);//移动到玩家的帮派地图中\n            break;\n        case '4': ShowProps();//展示游戏商品\n            break;\n        default : printf(\"少侠究竟想要作甚?\");\n    }\n}\n\n以下为游戏主逻辑, 死循环中对用户输入进行判断并对应相应的输出(即实现不同游戏功能)\n****************************************************************************\nmain()包括了判断字符进行移动玩家所在地图的功能(未封装成方法!)\n****************************************************************************\nint main() {//最好通过一个游戏进程函数将main方法里边的各种方法封装, 通过不同状态执行不同方法\n    char key;           //接收用户输入\n    SetColor(2,0);      //设置控制台文本颜色(front color为绿色, background color为黑色)\n    SetConsoleTitle(\"笑傲江湖之精忠报国 C语言实现 BY 左手工匠\");    //设置控制台标题\n    PropInit();         //初始化测试人物\n    ShowWelcome();      //显示欢迎栏\n    Login();            //登陆, 登陆成功继续执行\n    ShowMap();          //显示地图\n    ShowInformation();  //显示信息栏\n    ShowMainMenu();     //显示菜单栏\n    while (1) {//死循环, 除非用户选择退出, 否则停止等待用户输入\n    fflush(stdin);\n    //接收用户输入(无回显)\n    key = getch();\n    fflush(stdin);\n    if(key == '1' || key == '2' || key == '3' || key == '4'){\n        GameProcess(key);//输入正常, 将值传递给GameProcess()来对应输出\n        continue;\n    }\n    else if(key == '5' || key == '6' ){\n        SetPosition(20, 12);\n        Clear(20 , 12, 7);\n        SetPosition(20 + 5, 12 + 2);\n        printf(\"放过我吧, 还没开发完呐!!!\\n\");\n    }\n    else if(key == '7') {\n        break;\n    }\n    else if(key == VK_UP || key == 72) {//X, Y为游戏坐标, 控制X, YS实现地图移动\n        Y--;            //输入上\n    }\n    else if(key == VK_RIGHT || key == 77) {\n        X++;            //输入右\n    }\n    else if(key == VK_DOWN || key == 80) {\n        Y++;            //输入下\n    }\n    else if(key == VK_LEFT || key == 75) {\n        X--;            //输入左\n    }\n    if(X > 7) {//移动到最边的话重新回到0, 如贪食蛇穿过地图边缘\n        X = 0;\n    }\n    if(X < 0) {\n        X = 7;\n    }\n    if(Y > 7) {\n        Y = 0;\n    }\n    if(Y < 0) {\n        Y = 7;\n    }\n    ShowMap();\n}\n    return 0;\n}\n~~~\n\n- 清空指定区域内所有字符 \n~~~\n/** 清除信息区内所有内容(给定坐标及清理的行数) */\nvoid Clear(int x, int y, int rowCount) {\n    for(int i = 0; i < rowCount; i ++) {\n        SetPosition(x + 1, y + i);\n        for(int j = 0; j < COL - 1; j ++)  {    //使用' '替换指定区域\n            printf(\" \");\n        }\n    }\n}\n~~~\n\n- 打印怪物的信息以及接收并判断玩家的输入的怪物编号, 玩家选择查看怪物信息时调用该方法\n~~~\n/** 显示当前地图的怪物********(功能略复杂些)*************/\nvoid ShowMonster() {\n    //给怪物各个等级对应相应称号\n    //例如：3级怪物，那么就显示这个怪物的描述为粗通皮毛\n    char *monsterlevelNames[] = {\"乳臭未干\", \"初出茅庐\", \"粗通皮毛\", \"青年才俊\", \"略有小成\", \"心领神会\", \"出类拔萃\", \"所向无敌\", \"天人合一\"};\n    Clear(MAXGIN_X,  INFORMATION_START_Y, 7);   //清空信息区的所有内容\n    int monsterCount;\n    // 记录整个游戏的怪物总数\n    monsterCount = sizeof(monsterArray) / sizeof(Monster);\n    //记录当前地图的怪数量 记得变量定义时赋初值!!! debug了好久...\n    int currMapMonsterCount = 0;\n    // 定义一个只有九个空间的一维数组, 用以记录怪物在怪物列表里的下标\n    int monsterIndex[9];\n    for(int i = 0; i < monsterCount; i++) {\n        // 关键!!! 满足怪物坐标与当前地图坐标相等 并且 该怪物的状态为存活的条件, 将怪物与怪物数组的下标记录并且当前地图怪物数量自增\n        if(monsterArray[i].coord.X == X && monsterArray[i].coord.Y == Y && monsterArray[i].state == 1) {\n            // 记录下标\n            monsterIndex[currMapMonsterCount] = i;\n            currMapMonsterCount++;\n            // 设定每个地图最多显示 9 个怪物\n            if(currMapMonsterCount == 9) {\n                break;\n            }\n        }\n    }\n\n    // 打印怪物\n    SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 1);\n    if(currMapMonsterCount == 0) {\n        SetColor(7, 0);//白字黑底\n        printf(\"这里冷冷清清的什么也没有, 少侠还是到别处看看吧, 呆着也没银子给你!\");\n        SetColor(2, 0);//恢复颜色\n        return;\n    }\n\n/*********以下语句为判定用户输入的编号来返回地图信息或进行打怪操作*******/\n    int pkMonsterId = 0;// 接收玩家输入的怪物编号, 定义在循环外部是因为循环外仍需使用进行判断是否打印地图信息\n    while(1){\n        pkMonsterId = -1;\n        Clear(MAXGIN_X,  INFORMATION_START_Y, 7);   //清空信息区的所有内容\n        SetPosition(MAXGIN_X + 20, INFORMATION_START_Y + 0);\n        printf(\"少侠, 这儿有怪物! 要为百姓除暴安良吗?\" );\n        SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 2);\n        for(int i = 0; i < currMapMonsterCount; i++) {\n            if(i % 3 == 0 && i != 0){//每行打印三个怪物\n                SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 2 + i / 3);\n            }\n            //打印怪物, 较为繁琐\n            //monsterIndex[i]即为该怪物列表中的怪物编号\n            SetColor(4, 0);//红字怪物\n            printf(\"%d.%s(%s)\\t  \", i + 1, monsterArray[monsterIndex[i]].name, monsterlevelNames[monsterArray[monsterIndex[i]].level - 1]);\n        }\n        SetColor(2, 0);//恢复颜色\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"少侠想攻击几号怪物呢? (按0返回)\");\n        scanf(\"%d\", &pkMonsterId);\n        if(pkMonsterId == 0) {//输入0, 退出循环来返回显示地图信息\n            break;\n        }\n        else if(pkMonsterId < 0 || pkMonsterId > currMapMonsterCount) {\n            //输入的怪物标号在当前地图不存在\n            SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n            //简易清屏\n            printf(\"                                                             \");\n            SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n            printf(\"少侠选错了吧, 怪物不存在呢!(按任意键重新输入)\");\n            char recoverKey = getch();\n            if(recoverKey){//停顿直到接收任意键后重新显示怪物\n                continue;\n            }\n        }\n        else {//编号对应地图所有的怪物时, 将怪物地址传入打怪方法\n            MonsterFight(&monsterArray[monsterIndex[pkMonsterId - 1]]);\n            break;\n        }\n    }\n    if(pkMonsterId == 0) {//输入0, 返回显示地图信息\n        ShowMapInfo();\n    }\n}\n~~~\n- 玩家与指定地图指定怪兽进行战斗\n~~~\n/** 选定怪物进行对战 */\nvoid MonsterFight(Monster *monster) {\n    SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n    printf(\"                                                             \");//简易清屏(偷懒)\n    SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n    srand(time(NULL));//以当前时间为种子\n    /* random函数的用法(只能0 - 32767之间)\n    * 随机一个a ~ b的数字, 即 rand() % (b - a + 1) + a; 例如0 ~ 5, 即rand() % 6;\n    */\n    int playerAttact = 0;\n    // 玩家的实际攻击力\n    playerAttact = rand() % (currPlayer->weapon.maxAttack - currPlayer->weapon.minAttack + 1) + currPlayer->weapon.minAttack;\n    int playerDeffence =0;\n    //玩家实际防御力\n    playerDeffence = rand() % (currPlayer->armor.maxDefence - currPlayer->armor.minDefence + 1) + currPlayer->armor.minDefence;\n    //怪物实际掉落的金钱\n    int monsterGold = 0;\n    monsterGold = rand() % (monster->maxMoney - monster->minMoney + 1) + monster->minMoney;\n    int pkRound = 0;    //记录战斗的轮次\n    while(1){//打斗循环, 任意一方死亡退出\n        //玩家血量变化\n        currPlayer->hp -= monster->attact - playerDeffence;\n        //怪物的血量变化\n        monster->hp -= playerAttact - monster->defence;\n        if(monster->hp <= 0) {//怪物的血量少于等于0时退出\n            break;\n        }\n        if(currPlayer->hp <= 0) {//玩家血量小于等于0时退出\n            break;\n        }\n        //以下为打印战斗详情\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"                                                                         \");//简易清屏(偷懒)\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        pkRound++;\n        //战斗详情使用白底红字\n        SetColor(4,7);\n        //该语句较长......\n        printf(\"第 %d 轮战斗详情:%s 对 %s 造成了 %d 伤害且受到 %s %d 的伤害\", pkRound, currPlayer->name, monster->name, playerAttact - monster->defence, monster->name, monster->attact - playerDeffence);\n        //放慢过程\n        usleep(1000 * 800);//1000毫秒*800\n        SetColor(2, 0);\n    }\n    SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n    printf(\"                                                                   \");//简易清屏(偷懒)\n    SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n    if(currPlayer->hp <= 0) {\n        //玩家死亡输入完任意键后返回\n        printf(\"江湖快讯: 大侠 %s 在与 %s 的对决中壮烈牺牲! (请按任意键返回)\", currPlayer->name, monster->name);\n        //重置人物的金币与血量\n        currPlayer->hp = 100;\n        currPlayer->gold = 100;\n        getch();\n        return;\n    }\n    //以下即为怪物死亡的情况\n    printf(\"%s 轻而易举的便被 %s 大侠收拾了, 同时掉落了 \", monster->name, currPlayer->name);\n    //将怪物的状态调整至死亡\n    monster->state = 0;\n    //设置金币的front color为黄色, background color为亮白色\n    SetColor(6, 15);\n    printf(\"%d 金币   \", monsterGold);\n    // 设置经验的front color为黄色, background color为亮白色\n    SetColor(1, 15);\n    printf(\"%d 经验  \", monster->exp);\n    SetColor(2, 0); //颜色恢复\n    //玩家获得金币与经验值的加成\n    currPlayer->gold += monsterGold;\n    currPlayer->exp += monster->exp;\n    getch();\n    ShowMonster();\n}\n~~~\n初始化游戏数据: 将地图, 玩家, 装备, 怪物置入, 测试各功能\n~~~\nPlayer *currPlayer;\nvoid PropInit() {//初始化游戏数据 (测试用数据)\n    currPlayer = &playArray[0];\n    currPlayer->weapon = propArray[8];\n    currPlayer->armor = propArray[4];\n    currPlayer->martial = martials[4];\n    Bag bag = {95001, 0, 8};\n    currPlayer->bag = bag;\n}\n~~~\n交易, 玩家购买指定道具\n~~~\n/** 交易\n  * 参数1: 玩家的地址\n  * 参数2: 商品的编号\n  * 返回交易是否成功, 0 失败, 1 成功\n  */\nint Trade(Player *player, int propsId) {\n    Prop *tradeProp = NULL;     //定义一个用于指向及交易商品的指针\n    for(int i = 0; i < sizeof(propArray) / sizeof(Prop); i++) {\n        if(propsId == propArray[i].id) {//找到该商品, 并让tradeProp指向它\n            tradeProp = propArray + i;  //即tradeProp = &propArray[i]\n            break;\n        }\n    }\n    //判断商品是否有库存\n    if(tradeProp->stock <= 0) {\n        Clear(MAXGIN_X, INFORMATION_END_Y - 1, 1);\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"地主家都没有余粮！商店都被买空啦！\");\n        return 0;\n    }\n    //判断玩家是否金币足够支付\n    if(currPlayer->gold < tradeProp->price) {\n        Clear(MAXGIN_X, INFORMATION_END_Y - 1, 1);\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"钱包都是瘪的，这可是个看钱的江湖！！!\");\n        return 0;\n    }\n    //判断玩家背包容量是否充足\n    if(currPlayer->bag.propsCount > currPlayer->bag.maxCount && currPlayer->bag.propsCount != 0) {\n        //玩家的背包道具数量大于最大容量并且背包道具数不为0则判定为失败\n        Clear(MAXGIN_X, INFORMATION_END_Y - 1, 1);\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"背包已满，交易失败！\");\n        return 0;\n    }\n    //满足交易条件，执行交易的业务操作\n    //1、商品库存-1\n    tradeProp->stock--;\n    //2、玩家金币-商品单价\n    player->gold -= tradeProp->price;\n\n    //*****************************玩家背包道具增加*******************************//\n    //判断玩家背包中是否已有该商品 !!!\n    int i;\n    for(i = 0; i < currPlayer->bag.propsCount; i++) {\n        if(propsId == currPlayer->bag.props[i].id) {\n            currPlayer->bag.props[i].stock++;\n            break;\n        }\n    }\n    //若为循环正常结束, i = currPlayer->bag.propsCount, 即为背包无此商品, 需要给背包添加该商品!!!\n    if(i == currPlayer->bag.propsCount) {\n        //向背包中创建一个商品-复制一份要交易的商品信息到背包中\n        currPlayer->bag.props[currPlayer->bag.propsCount].id = tradeProp->id;\n        currPlayer->bag.props[currPlayer->bag.propsCount].price = tradeProp->price;\n        currPlayer->bag.props[currPlayer->bag.propsCount].stock = 1;\n        strcpy(currPlayer->bag.props[currPlayer->bag.propsCount].name, tradeProp->name);\n        strcpy(currPlayer->bag.props[currPlayer->bag.propsCount].desc, tradeProp->desc);\n        currPlayer->bag.propsCount++;\n    }\n    //交易成功\n    return 1;\n}\n~~~\n- 打印商品列表, 玩家选择购买道具调用该方法\n~~~\n/** 展示游戏商品 */\nvoid ShowProps() {\n    //此方法应拆分为打印商品 以及用户输入并检验商品编号两个方法!!!!!!!!\n    /*******************************/\n    Clear(MAXGIN_X, INFORMATION_START_Y, 7);\n    SetPosition(MAXGIN_X + 5, INFORMATION_START_Y);\n    SetColor(8, 0);     //灰字黑底\n    printf(\"欢迎大侠 %s 来到 %s 童叟无欺的杂货铺, 瞧一瞧看一看可有需要的?\", currPlayer->name, mapArray[X][Y].name);\n    SetColor(6, 0);     //黄字黑底\n    SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 2);\n    int propCount = sizeof(propArray) / sizeof(Prop) >= 9 ? 9 : sizeof(propArray) / sizeof(Prop);\n    for(int i = 0; i < propCount; i++) {\n        if(i % 3 == 0) {//打印商品, 每行 3 个, 且只打印最多 9 个\n            SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 2 + i / 3);\n        }\n        printf(\"%-3d.%-10s(%-2d)%-4c\", propArray[i].id, propArray[i].name, propArray[i].stock, ' ');\n    }\n    SetColor(2, 0);//恢复颜色\n\n    int tradeId;//接收用户输入的商品编号\n    while(1) {\n        //用于判断输入编号是否正确(此判断未包括检验玩家金币及商品库存及玩家背包是否已满等状态)\n        Clear(MAXGIN_X, INFORMATION_END_Y - 1, 1);\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"大侠需要什么, 请输入编号立即购买(按 0 退出)\");\n        scanf(\"%d\", &tradeId);\n        if(tradeId == 0) {//输入0返回显示地图信息\n            ShowMapInfo();\n            break;\n        }\n        else if(tradeId < 0 || tradeId > 9) {//输入的商品编号错误的情况, 重新输入\n            Clear(MAXGIN_X, INFORMATION_END_Y - 1, 1);\n            SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n            printf(\"少侠选错了吧, 商品不存在呢!(按任意键重新输入)\");\n            char recoverKey = getch();\n            if(recoverKey){//停顿直到接收任意键后重新显示怪物\n                continue;\n            }\n        }\n        else {//输入在1 - 9的情况, 将编号传入交易函数\n            showTrade(Trade(currPlayer, tradeId), tradeId);//******调用交易方法, 展示交易信息方法******//\n            //以下为重新刷新商品列表, 应该封装为一个打印商品的方法, 该ShowProps()方法过于繁琐, 加入了打印以及检验两个功能\n            /********************************/\n            Clear(MAXGIN_X, INFORMATION_START_Y, 7);\n            SetPosition(MAXGIN_X + 5, INFORMATION_START_Y);\n            SetColor(8, 0);     //灰字黑底\n            printf(\"欢迎大侠 %s 来到 %s 童叟无欺的杂货铺, 瞧一瞧看一看可有需要的?\", currPlayer->name, mapArray[X][Y].name);\n            SetColor(6, 0);     //黄字黑底\n            SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 2);\n            int propCount = sizeof(propArray) / sizeof(Prop) >= 9 ? 9 : sizeof(propArray) / sizeof(Prop);\n            for(int i = 0; i < propCount; i++) {\n                if(i % 3 == 0) {//打印商品, 每行 3 个, 且只打印最多 9 个\n                    SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 2 + i / 3);\n                }\n                printf(\"%-3d.%-10s(%-2d)%-4c\", propArray[i].id, propArray[i].name, propArray[i].stock, ' ');\n            }\n            SetColor(2, 0);//恢复颜色\n            /********************************/\n            }\n        }\n}\n~~~\n- 返回交易结束后的信息\n~~~\n/** 接收Trade()返回的值, 判断交易是否成功 */\nvoid showTrade(int flag, int propId) {\n    if(flag == 0) {\n        ShowMapInfo();\n        return;\n    }\n    if(flag == 1) {\n        Clear(MAXGIN_X, INFORMATION_END_Y - 1, 1);\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"交易成功, \");\n        SetColor(6, 0);     //打印装备为黑底黄字\n        printf(\"%s\", propArray[propId - 1].name);\n        SetColor(2, 0);     //恢复黑底绿字\n        printf(\" 已经加入你的背包, 赶紧瞧一瞧吧!(按任意键继续)\");\n        getch();            //暂停\n    }\n}\n~~~\n验证登陆信息\n~~~\n/** 玩家登陆(暂无注册) */\nvoid Login() {\n    while(1) {\n        char id[10];\n        char key[10];       //接收用户输入的id 和 passwd\n        SetColor(2, 0);\n        Clear(MAXGIN_X, MAPSART_START_Y, 4);\n        SetPosition(MAXGIN_X + 24, MAPSART_START_Y);\n        printf(\"请在下方输入您的用户名和密码\");\n        SetPosition(MAXGIN_X + 5, MAPSART_START_Y + 1);\n        printf(\"用户名: \");\n        scanf(\"%s\", id);\n        SetPosition(MAXGIN_X + 5, MAPSART_START_Y  + 2);\n        printf(\"密码(无回显哦回车确定): \");\n        for(int i = 0; 1; i++) {\n            key[i] = getch();//无回显输入密码\n            if(key[i] == 13) {\n                //接收到回车跳出循环\n                //将回车字符重置为空字符\n                key[i] = '\\0';\n                break;\n            }\n        }\n        //判断玩家输入的信息是否与玩家id, passwd匹配\n        if(strcmp(currPlayer->id, id) == 0 && strcmp(currPlayer->passwd, key) == 0) {\n            //只有玩家输入成功才跳出死循环\n            break;\n        }\n        else {\n            SetPosition(MAXGIN_X + 5, MAPSART_START_Y + 3);\n            SetColor(12, 0);    //浅红色字体\n            printf(\"用户名或密码错误, 请检查后再次输入!(按任意键继续)\");\n            getch();\n        }\n    }\n    //用户输入成功后\n    SetColor(12, 0);\n    SetPosition(MAXGIN_X, MAPSART_START_Y);\n    Clear(MAXGIN_X, MAPSART_START_Y, 4);\n    SetPosition(MAXGIN_X + 15, MAPSART_START_Y);\n    printf(\"欢迎 \");\n    SetColor(1, 0);      //蓝字显示玩家name\n    printf(\"%s\", currPlayer->name);\n    SetColor(2, 0);\n    printf(\" 成功登陆笑傲江湖的世界(按任意键继续)\");\n    getch();    //暂停\n}\n~~~\n## 拓展功能\n以下的功能为此DEMO适合拓展的有趣功能:\n- 玩家的背包容量: 初始设定只有9, 可以通过充值元宝等方式扩充背包最大容量\n- 注册功能, 玩家设定任意符合指定规则的用户名及密码, 并且在下次可以继续使用\n- NPC, 逻辑与怪物相似, 地图随机刷新NPC并且贩卖普通商店没有的道具\n- 打斗过程加入回复, 增益等功能(打斗前使用消耗品提升属性, 打斗过程回复血量, 内力)\n- 怪物指定时间刷新\n- 连接网络, 满足两个玩家在同一张地图进行, 怪物道具资源同步刷新, 并且玩家可以决斗(遥远的目标啊)\n\n## 最后的吐槽\n\n先说说为什么要写这个极小极小的DEMO吧, 寒假前半段在学数据结构, 时间较短, 仅仅实现了顺序表, 单链表, 循环链表等几个简单的数据结构的定义以及实现, 过程不算太美好: 虽然大二上讲过数据结构与算法, 但是非常的粗略, 对数据结构与算法的理解仅仅为有那么几种表, 有那么几种排序方式, 而且C是大一上学的, 早已忘得一干二净, 很多语法尤其是之前就不过关的指针的不熟悉, 应验了那句: 当C的指针指向你的时候, 菜鸡原形毕露! 被头指针头结点折腾的头皮发麻, 尽管磕磕绊绊用代码实现了, 但我深刻感受到了效率的低下, 进度十分缓慢, 遂觉得应该恶补以下C, 于是有了以上的DEMO\n\n前前后后一共花了十天, 四天的时间都是疯狂刷视频, 把指针, 结构体, 字符串, 数组这四个章节重点看了一到两遍, 然后六天把这个DEMO完成了, 跟着老九的视频, 每天看完示范再理解完敲代码实现, 慢慢的也完成了, 自己也没想到可以写出1000行的东西(可能是我注释比较多吧捂脸), 过程最难过的不是理解也不是一行一行敲出一个功能, 而是无穷无尽的BUG, 早期是用Clion + Cmake的环境, 第二天开始实现游戏的界面栏目并且改变控制台标题栏以及字体颜色时, 因为要在控制台检验, 但是发现Clion + Cmake不能调出Windows的Console, 一顿查阅亦未果, 因此使用了最早使用的Codeblocks(还是这个简单多了...), 嫌弃Cb丑陋UI的我又入坑了Atom, 用Atom码代码, Cb编译.....十分的奇葩, 但是也算是完成了\n\n总体来讲, 对我感触最深的东西应该就是封装以及设计了, 这次的初版的DEMO我总体时非常不满意的, 糟糕的代码, 凌乱的代码, 混乱的设计, 可能源于我过于追求速度, 也许我做出了和视频效果相似甚至更加花里胡哨的打印结果, 但是里面的东西差距时非常遥远的, 空有其表, 败絮其中. 这种代码在日后非常难以维护, 即使我加了非常多的代码, 缩进也尽量按照标准来, 但是我自己都很难找到一个方法在哪里, 非常难以修改, 修改了一个方法可能需要同时修改其他的很多地方, 或者是修改完出现各种各样的内存问题等等...我现在认为一个方法仅仅对于一个功能是非常重要的, 而且便于记忆以及修改的宏定义我也尝到了它的甜头, 还有对整体程序的逻辑设计, 在不考虑这些东西而仅仅根据几条需求如同大一考试对于问题对于解出来就完事儿了的态度去码代码, 码出来的程序可能是正常运行的, 但是接下来的维护呢, 况且随心所欲的写方法我现在感觉是非常可怕的, 乱码一时爽, 码完以后火葬场, 每次DEBUG的时间都与真实写代码的时间一样长了, 每次改完以后心里憔悴, 这都是不好好规划设计, 拿起手就是敲的后果, 正所谓: 代码千万条, 规范第一条, 代码不规范, 亲人两行泪!写完这个DEMO也让我更加深入理解了一些数据结构, 如同此DEMO中的玩家结构, 玩家中有背包, 背包中有道具, 道具中有类别对应不同属性, 武器对应攻击力, 防具对应防御力等等, 现在我可能会思考, 需要经常插入而又很少需要随机读取的类型会不使用链表更加好一些等等的问题, 看来这波不亏\n\n最后, 可能我不会再继续修改这个DEMO了, 要么也是重写了(实在太烂了...) 感谢这个DEMO, 感谢老九, 用这样一种方式让我认识到了上课所无法理解的思想, 让我对未来的代码有了期待, 但是这只是一个极小的开始, 这只是站在了一个小石子儿看世界, 要想看到真正的世界, 还需走的更远, 爬到更高的地方去眺望, 去欣赏, 去体味)","source":"_posts/笑傲江湖DEMO.md","raw":"---\ntitle: 笑傲江湖DEMO\ndate: 2019-02-28 21:22:20\ncategories: C\ntags: [C, DEMO, Game]\n---\n<h1 style=\"text-align:center\">My first console game demo <h1>\n\n![2019-02-2831b3de.png](https://miao.su/images/2019/02/28/2019-02-2831b3de.png)\n<!-- more -->\n\n\n这个demo简单的实现了用户输入方向键, 数字键达到在不同地图切换, 购买商品, 打怪升级等功能, 希望在后期能够实现更加丰富的功能并且能连接网络对战, \n开发环境为Atom,CodeBlocks,MinGW\n\n\n## 数据类型\n1. 道具\n2. 地图\n3. 背包(背包包括道具类型)\n4. 门派\n5. 玩家(玩家包含背包以及门派数据类型)\n6. 怪物\n\n### 道具 (Prop)\n\n**属性字段**\n\n|属性|定义|\n|:-:|:-:|\n|编号|int id|\n|名称|char name[30]|\n|价格|double price|\n|等级|int level|\n|库存|int stock|\n|类别|propType type(使用枚举)|\n|最小属性|union(使用联合体)|\n|最大属性|union(使用联合体)|\n|描述|char desc[200]|\n\n\n枚举代码\n~~~\ntypedef enum _propType {\n    Weapon,     //武器\n    Armor,      //防具\n    Con,        //消耗品\n    Frag,       //碎片\n} Type;\n~~~\n联合体代码  (不同类别拥有不同属性类别)\n~~~\nunion {\n    int minAttack;     //如果是武器类别, 则最 低/高 攻击力为\n    int minDefence;    //如果是防具类别, 则最 低/高 防御力为\n    int minPower;      //如果是消耗品类别, 则最 低/高 回复值为\n}\n~~~\n~~~\n要注意若定义枚举中使用 ; 分隔开, 则报错如下(这是我自己踩过的一个坑)\nExpected '= constant-expression' or end of enumerator definition\n~~~\n\n\n### 地图(Map)\n- 该DEMO的地图大小为8 * 8\n- 后期增加地图进入的等级限制\n\n**属性字段** \n\n|属性|定义|\n|:-:|:-:|\n|编号|int id|\n|名称|char name[20]|\n|进入地图的最低等级|minLevel|\n|坐标结构|COORD coord|\n|地图描述|desc[500]|\n~~~\n地图的坐标使用window.h头文件下的COORD结构, 使用方式为coord.X = 0, coord.Y = 0\n~~~\n\n### 背包 (Bag)\n- 背包类型是玩家的一个属性\n- 后期改进实现人民币玩家可以提升背包容量上限\n\n**属性字段**\n\n|属性|定义|\n|:-:|:-:|\n|所属玩家ID|int playId|\n|当前的道具数量|int propsCount|\n|背包最大容量|maxCount|\n|道具数组|Prop props|\n\n### 门派 (Martial)\n- 门派为玩家的一个属性\n- 后期改进实现人名币玩家解锁更多帮派功能\n\n**属性字段**\n\n|属性|定义|\n|:-:|:-:|\n|编号|int id|\n|名称|char name[20]|\n|门派类型|char type[10]|\n|门派总部坐标结构|COORD hqCoord|\n|是否对玩家开放|int isOpen|\n|门派描述|char desc[1000]|\n\n### 玩家 (Player)\n\n**属性字段**\n\n|属性|定义|\n|:-:|:-:|\n|名称|char name[30]|\n|编号|id[10]|\n|密码|char passwd[30]|\n|等级|int level|\n|经验值|int exp|\n|血量|int hp|\n|内力|int mp|\n|金币|int gold|\n|门派结构|Martial martial|\n|武器道具|Prop weapon|\n|防具道具|Prop armor|\n|玩家当前坐标|COORD coord|\n|背包结构|Bag bag|\n\n### 怪物 (Monster)\n- 后期加入怪物掉落装备功能\n\n**属性字段**\n\n|属性|定义|\n|:-:|:-:|\n|编号|int id|\n|名称|char name[20]|\n|等级|int level|\n|血量|int hp|\n|攻击力|int attact|\n|防御力|int defence|\n|掉落的最小金币|int minMoney|\n|掉落的最大金币|int maxMoney|\n|玩家能够获取的最大经验|int exp|\n|怪物的状态(0死1活)|int state|\n|怪物的坐标|COORD coord|\n***\n## 功能实现\n\n**通过系统函数辅助实现的方法, 以下方法在GameLib源文件中**\n1. 更改控制台标题(SetTitle)\n2. 更改控制台内字体(SetColor)\n3. 设置控制台内光标的位置(SetPosition)\n  \n### 更改控制台标题(SetTitle)\n~~~\n/** 设置控制台的标题 */\nvoid SetTitle(char *title) {\n    SetConsoleTitle(title);     //调用windows.h头文件下的系统函数\n}\n~~~\n### 更改控制台内字体(SetColor)\n~~~\n/* 设置控制台的颜色\n * 0-黑色,   1-蓝色,   2-绿色,    3-浅绿色,  4-红色,\n * 5-紫色,   6-黄色,   7-白色,    8-灰色,   9-淡蓝色,\n * 10-淡绿色,  11-淡浅绿色   12-淡红色   13-淡紫色\n * 14-淡黄色   15-亮白色\n */\nvoid SetColor(int ForeColor, int BackColor) {//分别设置前景色与背景色\n     //HANDLE: 句柄, GetStdHandle(STD_OUTPUT_HANDLE)获得标准输出流的句柄, 均为windows.h下的系统函数\n     HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);       //获取当前窗口句柄\n     SetConsoleTextAttribute(handle, ForeColor + BackColor * 0x10);//设置颜色\n   \n    //句柄(HANDLE)补充:\n    //WINDOWS程序中并不是用物理地址来标识一个内存块，文件，任务或动态装入模块的。\n    //相反，WINDOWS API给这些项目分配确定的句柄并将句柄返回给应用程序，\n    //然后通过句柄来进行操作(句柄不是指针, 是32或64位的无符号整型)\n }\n~~~\n### 设置控制台内光标的位置(SetPosition)\n~~~\nvoid SetPosition(int x, int y) {\n     HANDLE winHandle = GetStdHandle(STD_OUTPUT_HANDLE);\n     COORD pos = {x, y};\n     //SetConsoleCursorPosition()为windows.h下系统函数\n     SetConsoleCursorPosition(winHandle, pos);      //设置光标位置\n }\n~~~\n***\n**以下方法为自己定义实现游戏主要逻辑功能中比较重要的几个, 在Game源文件中**\n1. **GameProcess():** 接收并判断用户的输入, 返回游戏的各个功能(例如用户输入方向键将会移动玩家的所在地图,输入1会显示玩家的个人信息窗口等等)这是游戏最重要的一个方法, 决定了游戏的逻辑实现, 本人水平较差, 当初没有想到将所有的操作均封装到此方法来, 因此使得判断用户输入包括方向键的接收为一个方法并且放入于main()中, 导致了维护困难, 代码不清晰等等问题 \n2. **Clear():** 功能为清理指定区域内的所有字符, 用'\\0'替代, 达到刷新屏幕的功能, 由于清屏操作需要使用的次数极多因此封装成方法\n3. **ShowMonster():** 该方法为显示当前地图所有怪物的信息: 等级名称, 但是我却在一个方法包含了接收用户输入导致方法过于复杂难以复用维护, 而且此方法打印怪物使用指针以及辅助数组较难理解\n4. **MonsterFight():** 接收用户输入的怪物编号, 让玩家与怪物进行战斗, 以当前时间为种子, 攻击力防御力取范围该范围内的随机数, 战斗后返回判断打印不同情况的结果 \n5. **PropInit():** 初始化游戏玩家数据, 用于测试功能 \n6. **Trade():** 交易方法, 接收游戏玩家编号与商品编号, 重点为判断无法交易的情况以及对背包物品的添加(背包已有该类别商品/背包暂无此类别商品) \n7. **ShowProps():** 显示商城的信息, 此方法与ShowMonster()类似,  同样我没考虑到方法的复用以及维护, 将Show 和 接收用户的输入 两个方法写在一个方法里了\n8. **showTrade():** 接收Trade()返回的值, 对应交易成功与失败分别执行不同操作\n9. **Login():** 登陆方法, 接收用户输入的用户名以及密码(无回显)进行判断以达到登陆功能\n\n#### 以下为主要方法的源代码\n- 一些宏定义, 例如游戏窗口的各个部分的行数等等, 在移动光标时使用频率极高\n~~~\n#define COL 78                //游戏的界面的总宽度\n#define MAXGIN_X 20           //游戏界面与控制台的左边距\n#define ENDINFO 78            //各个框架结束'|'的列数\n#define MAPSART_START_Y 3     //游戏地图开始的行\n#define MAPSART_END_Y 11      //游戏地图结束行\n#define INFORMATION_START_Y 12//游戏信息开始行\n#define INFORMATION_END_Y 19  //游戏信息结束行\n#define MAINMENUE_START_Y 20  //游戏主菜单开始行\n#define MAINMENUE_END_Y 28    //游戏主菜单结束行\n#define SEP \"*******************************************************************************\"\n~~~\n- 游戏主体的逻辑实现\n~~~\n接收main()传递的key, 分别执行不同的功能\n/** 执行游戏主菜单功能 */\nvoid GameProcess(char key) {\n    switch (key) {\n        case '1': ShowPlayerInfo();//显示玩家个人信息\n            break;\n        case '2': ShowMonster();//显示当前地图的怪物(内有打怪)\n            break;\n        case '3': Move(currPlayer->martial.hqCoord.X, currPlayer->martial.hqCoord.Y);//移动到玩家的帮派地图中\n            break;\n        case '4': ShowProps();//展示游戏商品\n            break;\n        default : printf(\"少侠究竟想要作甚?\");\n    }\n}\n\n以下为游戏主逻辑, 死循环中对用户输入进行判断并对应相应的输出(即实现不同游戏功能)\n****************************************************************************\nmain()包括了判断字符进行移动玩家所在地图的功能(未封装成方法!)\n****************************************************************************\nint main() {//最好通过一个游戏进程函数将main方法里边的各种方法封装, 通过不同状态执行不同方法\n    char key;           //接收用户输入\n    SetColor(2,0);      //设置控制台文本颜色(front color为绿色, background color为黑色)\n    SetConsoleTitle(\"笑傲江湖之精忠报国 C语言实现 BY 左手工匠\");    //设置控制台标题\n    PropInit();         //初始化测试人物\n    ShowWelcome();      //显示欢迎栏\n    Login();            //登陆, 登陆成功继续执行\n    ShowMap();          //显示地图\n    ShowInformation();  //显示信息栏\n    ShowMainMenu();     //显示菜单栏\n    while (1) {//死循环, 除非用户选择退出, 否则停止等待用户输入\n    fflush(stdin);\n    //接收用户输入(无回显)\n    key = getch();\n    fflush(stdin);\n    if(key == '1' || key == '2' || key == '3' || key == '4'){\n        GameProcess(key);//输入正常, 将值传递给GameProcess()来对应输出\n        continue;\n    }\n    else if(key == '5' || key == '6' ){\n        SetPosition(20, 12);\n        Clear(20 , 12, 7);\n        SetPosition(20 + 5, 12 + 2);\n        printf(\"放过我吧, 还没开发完呐!!!\\n\");\n    }\n    else if(key == '7') {\n        break;\n    }\n    else if(key == VK_UP || key == 72) {//X, Y为游戏坐标, 控制X, YS实现地图移动\n        Y--;            //输入上\n    }\n    else if(key == VK_RIGHT || key == 77) {\n        X++;            //输入右\n    }\n    else if(key == VK_DOWN || key == 80) {\n        Y++;            //输入下\n    }\n    else if(key == VK_LEFT || key == 75) {\n        X--;            //输入左\n    }\n    if(X > 7) {//移动到最边的话重新回到0, 如贪食蛇穿过地图边缘\n        X = 0;\n    }\n    if(X < 0) {\n        X = 7;\n    }\n    if(Y > 7) {\n        Y = 0;\n    }\n    if(Y < 0) {\n        Y = 7;\n    }\n    ShowMap();\n}\n    return 0;\n}\n~~~\n\n- 清空指定区域内所有字符 \n~~~\n/** 清除信息区内所有内容(给定坐标及清理的行数) */\nvoid Clear(int x, int y, int rowCount) {\n    for(int i = 0; i < rowCount; i ++) {\n        SetPosition(x + 1, y + i);\n        for(int j = 0; j < COL - 1; j ++)  {    //使用' '替换指定区域\n            printf(\" \");\n        }\n    }\n}\n~~~\n\n- 打印怪物的信息以及接收并判断玩家的输入的怪物编号, 玩家选择查看怪物信息时调用该方法\n~~~\n/** 显示当前地图的怪物********(功能略复杂些)*************/\nvoid ShowMonster() {\n    //给怪物各个等级对应相应称号\n    //例如：3级怪物，那么就显示这个怪物的描述为粗通皮毛\n    char *monsterlevelNames[] = {\"乳臭未干\", \"初出茅庐\", \"粗通皮毛\", \"青年才俊\", \"略有小成\", \"心领神会\", \"出类拔萃\", \"所向无敌\", \"天人合一\"};\n    Clear(MAXGIN_X,  INFORMATION_START_Y, 7);   //清空信息区的所有内容\n    int monsterCount;\n    // 记录整个游戏的怪物总数\n    monsterCount = sizeof(monsterArray) / sizeof(Monster);\n    //记录当前地图的怪数量 记得变量定义时赋初值!!! debug了好久...\n    int currMapMonsterCount = 0;\n    // 定义一个只有九个空间的一维数组, 用以记录怪物在怪物列表里的下标\n    int monsterIndex[9];\n    for(int i = 0; i < monsterCount; i++) {\n        // 关键!!! 满足怪物坐标与当前地图坐标相等 并且 该怪物的状态为存活的条件, 将怪物与怪物数组的下标记录并且当前地图怪物数量自增\n        if(monsterArray[i].coord.X == X && monsterArray[i].coord.Y == Y && monsterArray[i].state == 1) {\n            // 记录下标\n            monsterIndex[currMapMonsterCount] = i;\n            currMapMonsterCount++;\n            // 设定每个地图最多显示 9 个怪物\n            if(currMapMonsterCount == 9) {\n                break;\n            }\n        }\n    }\n\n    // 打印怪物\n    SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 1);\n    if(currMapMonsterCount == 0) {\n        SetColor(7, 0);//白字黑底\n        printf(\"这里冷冷清清的什么也没有, 少侠还是到别处看看吧, 呆着也没银子给你!\");\n        SetColor(2, 0);//恢复颜色\n        return;\n    }\n\n/*********以下语句为判定用户输入的编号来返回地图信息或进行打怪操作*******/\n    int pkMonsterId = 0;// 接收玩家输入的怪物编号, 定义在循环外部是因为循环外仍需使用进行判断是否打印地图信息\n    while(1){\n        pkMonsterId = -1;\n        Clear(MAXGIN_X,  INFORMATION_START_Y, 7);   //清空信息区的所有内容\n        SetPosition(MAXGIN_X + 20, INFORMATION_START_Y + 0);\n        printf(\"少侠, 这儿有怪物! 要为百姓除暴安良吗?\" );\n        SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 2);\n        for(int i = 0; i < currMapMonsterCount; i++) {\n            if(i % 3 == 0 && i != 0){//每行打印三个怪物\n                SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 2 + i / 3);\n            }\n            //打印怪物, 较为繁琐\n            //monsterIndex[i]即为该怪物列表中的怪物编号\n            SetColor(4, 0);//红字怪物\n            printf(\"%d.%s(%s)\\t  \", i + 1, monsterArray[monsterIndex[i]].name, monsterlevelNames[monsterArray[monsterIndex[i]].level - 1]);\n        }\n        SetColor(2, 0);//恢复颜色\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"少侠想攻击几号怪物呢? (按0返回)\");\n        scanf(\"%d\", &pkMonsterId);\n        if(pkMonsterId == 0) {//输入0, 退出循环来返回显示地图信息\n            break;\n        }\n        else if(pkMonsterId < 0 || pkMonsterId > currMapMonsterCount) {\n            //输入的怪物标号在当前地图不存在\n            SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n            //简易清屏\n            printf(\"                                                             \");\n            SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n            printf(\"少侠选错了吧, 怪物不存在呢!(按任意键重新输入)\");\n            char recoverKey = getch();\n            if(recoverKey){//停顿直到接收任意键后重新显示怪物\n                continue;\n            }\n        }\n        else {//编号对应地图所有的怪物时, 将怪物地址传入打怪方法\n            MonsterFight(&monsterArray[monsterIndex[pkMonsterId - 1]]);\n            break;\n        }\n    }\n    if(pkMonsterId == 0) {//输入0, 返回显示地图信息\n        ShowMapInfo();\n    }\n}\n~~~\n- 玩家与指定地图指定怪兽进行战斗\n~~~\n/** 选定怪物进行对战 */\nvoid MonsterFight(Monster *monster) {\n    SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n    printf(\"                                                             \");//简易清屏(偷懒)\n    SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n    srand(time(NULL));//以当前时间为种子\n    /* random函数的用法(只能0 - 32767之间)\n    * 随机一个a ~ b的数字, 即 rand() % (b - a + 1) + a; 例如0 ~ 5, 即rand() % 6;\n    */\n    int playerAttact = 0;\n    // 玩家的实际攻击力\n    playerAttact = rand() % (currPlayer->weapon.maxAttack - currPlayer->weapon.minAttack + 1) + currPlayer->weapon.minAttack;\n    int playerDeffence =0;\n    //玩家实际防御力\n    playerDeffence = rand() % (currPlayer->armor.maxDefence - currPlayer->armor.minDefence + 1) + currPlayer->armor.minDefence;\n    //怪物实际掉落的金钱\n    int monsterGold = 0;\n    monsterGold = rand() % (monster->maxMoney - monster->minMoney + 1) + monster->minMoney;\n    int pkRound = 0;    //记录战斗的轮次\n    while(1){//打斗循环, 任意一方死亡退出\n        //玩家血量变化\n        currPlayer->hp -= monster->attact - playerDeffence;\n        //怪物的血量变化\n        monster->hp -= playerAttact - monster->defence;\n        if(monster->hp <= 0) {//怪物的血量少于等于0时退出\n            break;\n        }\n        if(currPlayer->hp <= 0) {//玩家血量小于等于0时退出\n            break;\n        }\n        //以下为打印战斗详情\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"                                                                         \");//简易清屏(偷懒)\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        pkRound++;\n        //战斗详情使用白底红字\n        SetColor(4,7);\n        //该语句较长......\n        printf(\"第 %d 轮战斗详情:%s 对 %s 造成了 %d 伤害且受到 %s %d 的伤害\", pkRound, currPlayer->name, monster->name, playerAttact - monster->defence, monster->name, monster->attact - playerDeffence);\n        //放慢过程\n        usleep(1000 * 800);//1000毫秒*800\n        SetColor(2, 0);\n    }\n    SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n    printf(\"                                                                   \");//简易清屏(偷懒)\n    SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n    if(currPlayer->hp <= 0) {\n        //玩家死亡输入完任意键后返回\n        printf(\"江湖快讯: 大侠 %s 在与 %s 的对决中壮烈牺牲! (请按任意键返回)\", currPlayer->name, monster->name);\n        //重置人物的金币与血量\n        currPlayer->hp = 100;\n        currPlayer->gold = 100;\n        getch();\n        return;\n    }\n    //以下即为怪物死亡的情况\n    printf(\"%s 轻而易举的便被 %s 大侠收拾了, 同时掉落了 \", monster->name, currPlayer->name);\n    //将怪物的状态调整至死亡\n    monster->state = 0;\n    //设置金币的front color为黄色, background color为亮白色\n    SetColor(6, 15);\n    printf(\"%d 金币   \", monsterGold);\n    // 设置经验的front color为黄色, background color为亮白色\n    SetColor(1, 15);\n    printf(\"%d 经验  \", monster->exp);\n    SetColor(2, 0); //颜色恢复\n    //玩家获得金币与经验值的加成\n    currPlayer->gold += monsterGold;\n    currPlayer->exp += monster->exp;\n    getch();\n    ShowMonster();\n}\n~~~\n初始化游戏数据: 将地图, 玩家, 装备, 怪物置入, 测试各功能\n~~~\nPlayer *currPlayer;\nvoid PropInit() {//初始化游戏数据 (测试用数据)\n    currPlayer = &playArray[0];\n    currPlayer->weapon = propArray[8];\n    currPlayer->armor = propArray[4];\n    currPlayer->martial = martials[4];\n    Bag bag = {95001, 0, 8};\n    currPlayer->bag = bag;\n}\n~~~\n交易, 玩家购买指定道具\n~~~\n/** 交易\n  * 参数1: 玩家的地址\n  * 参数2: 商品的编号\n  * 返回交易是否成功, 0 失败, 1 成功\n  */\nint Trade(Player *player, int propsId) {\n    Prop *tradeProp = NULL;     //定义一个用于指向及交易商品的指针\n    for(int i = 0; i < sizeof(propArray) / sizeof(Prop); i++) {\n        if(propsId == propArray[i].id) {//找到该商品, 并让tradeProp指向它\n            tradeProp = propArray + i;  //即tradeProp = &propArray[i]\n            break;\n        }\n    }\n    //判断商品是否有库存\n    if(tradeProp->stock <= 0) {\n        Clear(MAXGIN_X, INFORMATION_END_Y - 1, 1);\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"地主家都没有余粮！商店都被买空啦！\");\n        return 0;\n    }\n    //判断玩家是否金币足够支付\n    if(currPlayer->gold < tradeProp->price) {\n        Clear(MAXGIN_X, INFORMATION_END_Y - 1, 1);\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"钱包都是瘪的，这可是个看钱的江湖！！!\");\n        return 0;\n    }\n    //判断玩家背包容量是否充足\n    if(currPlayer->bag.propsCount > currPlayer->bag.maxCount && currPlayer->bag.propsCount != 0) {\n        //玩家的背包道具数量大于最大容量并且背包道具数不为0则判定为失败\n        Clear(MAXGIN_X, INFORMATION_END_Y - 1, 1);\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"背包已满，交易失败！\");\n        return 0;\n    }\n    //满足交易条件，执行交易的业务操作\n    //1、商品库存-1\n    tradeProp->stock--;\n    //2、玩家金币-商品单价\n    player->gold -= tradeProp->price;\n\n    //*****************************玩家背包道具增加*******************************//\n    //判断玩家背包中是否已有该商品 !!!\n    int i;\n    for(i = 0; i < currPlayer->bag.propsCount; i++) {\n        if(propsId == currPlayer->bag.props[i].id) {\n            currPlayer->bag.props[i].stock++;\n            break;\n        }\n    }\n    //若为循环正常结束, i = currPlayer->bag.propsCount, 即为背包无此商品, 需要给背包添加该商品!!!\n    if(i == currPlayer->bag.propsCount) {\n        //向背包中创建一个商品-复制一份要交易的商品信息到背包中\n        currPlayer->bag.props[currPlayer->bag.propsCount].id = tradeProp->id;\n        currPlayer->bag.props[currPlayer->bag.propsCount].price = tradeProp->price;\n        currPlayer->bag.props[currPlayer->bag.propsCount].stock = 1;\n        strcpy(currPlayer->bag.props[currPlayer->bag.propsCount].name, tradeProp->name);\n        strcpy(currPlayer->bag.props[currPlayer->bag.propsCount].desc, tradeProp->desc);\n        currPlayer->bag.propsCount++;\n    }\n    //交易成功\n    return 1;\n}\n~~~\n- 打印商品列表, 玩家选择购买道具调用该方法\n~~~\n/** 展示游戏商品 */\nvoid ShowProps() {\n    //此方法应拆分为打印商品 以及用户输入并检验商品编号两个方法!!!!!!!!\n    /*******************************/\n    Clear(MAXGIN_X, INFORMATION_START_Y, 7);\n    SetPosition(MAXGIN_X + 5, INFORMATION_START_Y);\n    SetColor(8, 0);     //灰字黑底\n    printf(\"欢迎大侠 %s 来到 %s 童叟无欺的杂货铺, 瞧一瞧看一看可有需要的?\", currPlayer->name, mapArray[X][Y].name);\n    SetColor(6, 0);     //黄字黑底\n    SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 2);\n    int propCount = sizeof(propArray) / sizeof(Prop) >= 9 ? 9 : sizeof(propArray) / sizeof(Prop);\n    for(int i = 0; i < propCount; i++) {\n        if(i % 3 == 0) {//打印商品, 每行 3 个, 且只打印最多 9 个\n            SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 2 + i / 3);\n        }\n        printf(\"%-3d.%-10s(%-2d)%-4c\", propArray[i].id, propArray[i].name, propArray[i].stock, ' ');\n    }\n    SetColor(2, 0);//恢复颜色\n\n    int tradeId;//接收用户输入的商品编号\n    while(1) {\n        //用于判断输入编号是否正确(此判断未包括检验玩家金币及商品库存及玩家背包是否已满等状态)\n        Clear(MAXGIN_X, INFORMATION_END_Y - 1, 1);\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"大侠需要什么, 请输入编号立即购买(按 0 退出)\");\n        scanf(\"%d\", &tradeId);\n        if(tradeId == 0) {//输入0返回显示地图信息\n            ShowMapInfo();\n            break;\n        }\n        else if(tradeId < 0 || tradeId > 9) {//输入的商品编号错误的情况, 重新输入\n            Clear(MAXGIN_X, INFORMATION_END_Y - 1, 1);\n            SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n            printf(\"少侠选错了吧, 商品不存在呢!(按任意键重新输入)\");\n            char recoverKey = getch();\n            if(recoverKey){//停顿直到接收任意键后重新显示怪物\n                continue;\n            }\n        }\n        else {//输入在1 - 9的情况, 将编号传入交易函数\n            showTrade(Trade(currPlayer, tradeId), tradeId);//******调用交易方法, 展示交易信息方法******//\n            //以下为重新刷新商品列表, 应该封装为一个打印商品的方法, 该ShowProps()方法过于繁琐, 加入了打印以及检验两个功能\n            /********************************/\n            Clear(MAXGIN_X, INFORMATION_START_Y, 7);\n            SetPosition(MAXGIN_X + 5, INFORMATION_START_Y);\n            SetColor(8, 0);     //灰字黑底\n            printf(\"欢迎大侠 %s 来到 %s 童叟无欺的杂货铺, 瞧一瞧看一看可有需要的?\", currPlayer->name, mapArray[X][Y].name);\n            SetColor(6, 0);     //黄字黑底\n            SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 2);\n            int propCount = sizeof(propArray) / sizeof(Prop) >= 9 ? 9 : sizeof(propArray) / sizeof(Prop);\n            for(int i = 0; i < propCount; i++) {\n                if(i % 3 == 0) {//打印商品, 每行 3 个, 且只打印最多 9 个\n                    SetPosition(MAXGIN_X + 5, INFORMATION_START_Y + 2 + i / 3);\n                }\n                printf(\"%-3d.%-10s(%-2d)%-4c\", propArray[i].id, propArray[i].name, propArray[i].stock, ' ');\n            }\n            SetColor(2, 0);//恢复颜色\n            /********************************/\n            }\n        }\n}\n~~~\n- 返回交易结束后的信息\n~~~\n/** 接收Trade()返回的值, 判断交易是否成功 */\nvoid showTrade(int flag, int propId) {\n    if(flag == 0) {\n        ShowMapInfo();\n        return;\n    }\n    if(flag == 1) {\n        Clear(MAXGIN_X, INFORMATION_END_Y - 1, 1);\n        SetPosition(MAXGIN_X + 5, INFORMATION_END_Y - 1);\n        printf(\"交易成功, \");\n        SetColor(6, 0);     //打印装备为黑底黄字\n        printf(\"%s\", propArray[propId - 1].name);\n        SetColor(2, 0);     //恢复黑底绿字\n        printf(\" 已经加入你的背包, 赶紧瞧一瞧吧!(按任意键继续)\");\n        getch();            //暂停\n    }\n}\n~~~\n验证登陆信息\n~~~\n/** 玩家登陆(暂无注册) */\nvoid Login() {\n    while(1) {\n        char id[10];\n        char key[10];       //接收用户输入的id 和 passwd\n        SetColor(2, 0);\n        Clear(MAXGIN_X, MAPSART_START_Y, 4);\n        SetPosition(MAXGIN_X + 24, MAPSART_START_Y);\n        printf(\"请在下方输入您的用户名和密码\");\n        SetPosition(MAXGIN_X + 5, MAPSART_START_Y + 1);\n        printf(\"用户名: \");\n        scanf(\"%s\", id);\n        SetPosition(MAXGIN_X + 5, MAPSART_START_Y  + 2);\n        printf(\"密码(无回显哦回车确定): \");\n        for(int i = 0; 1; i++) {\n            key[i] = getch();//无回显输入密码\n            if(key[i] == 13) {\n                //接收到回车跳出循环\n                //将回车字符重置为空字符\n                key[i] = '\\0';\n                break;\n            }\n        }\n        //判断玩家输入的信息是否与玩家id, passwd匹配\n        if(strcmp(currPlayer->id, id) == 0 && strcmp(currPlayer->passwd, key) == 0) {\n            //只有玩家输入成功才跳出死循环\n            break;\n        }\n        else {\n            SetPosition(MAXGIN_X + 5, MAPSART_START_Y + 3);\n            SetColor(12, 0);    //浅红色字体\n            printf(\"用户名或密码错误, 请检查后再次输入!(按任意键继续)\");\n            getch();\n        }\n    }\n    //用户输入成功后\n    SetColor(12, 0);\n    SetPosition(MAXGIN_X, MAPSART_START_Y);\n    Clear(MAXGIN_X, MAPSART_START_Y, 4);\n    SetPosition(MAXGIN_X + 15, MAPSART_START_Y);\n    printf(\"欢迎 \");\n    SetColor(1, 0);      //蓝字显示玩家name\n    printf(\"%s\", currPlayer->name);\n    SetColor(2, 0);\n    printf(\" 成功登陆笑傲江湖的世界(按任意键继续)\");\n    getch();    //暂停\n}\n~~~\n## 拓展功能\n以下的功能为此DEMO适合拓展的有趣功能:\n- 玩家的背包容量: 初始设定只有9, 可以通过充值元宝等方式扩充背包最大容量\n- 注册功能, 玩家设定任意符合指定规则的用户名及密码, 并且在下次可以继续使用\n- NPC, 逻辑与怪物相似, 地图随机刷新NPC并且贩卖普通商店没有的道具\n- 打斗过程加入回复, 增益等功能(打斗前使用消耗品提升属性, 打斗过程回复血量, 内力)\n- 怪物指定时间刷新\n- 连接网络, 满足两个玩家在同一张地图进行, 怪物道具资源同步刷新, 并且玩家可以决斗(遥远的目标啊)\n\n## 最后的吐槽\n\n先说说为什么要写这个极小极小的DEMO吧, 寒假前半段在学数据结构, 时间较短, 仅仅实现了顺序表, 单链表, 循环链表等几个简单的数据结构的定义以及实现, 过程不算太美好: 虽然大二上讲过数据结构与算法, 但是非常的粗略, 对数据结构与算法的理解仅仅为有那么几种表, 有那么几种排序方式, 而且C是大一上学的, 早已忘得一干二净, 很多语法尤其是之前就不过关的指针的不熟悉, 应验了那句: 当C的指针指向你的时候, 菜鸡原形毕露! 被头指针头结点折腾的头皮发麻, 尽管磕磕绊绊用代码实现了, 但我深刻感受到了效率的低下, 进度十分缓慢, 遂觉得应该恶补以下C, 于是有了以上的DEMO\n\n前前后后一共花了十天, 四天的时间都是疯狂刷视频, 把指针, 结构体, 字符串, 数组这四个章节重点看了一到两遍, 然后六天把这个DEMO完成了, 跟着老九的视频, 每天看完示范再理解完敲代码实现, 慢慢的也完成了, 自己也没想到可以写出1000行的东西(可能是我注释比较多吧捂脸), 过程最难过的不是理解也不是一行一行敲出一个功能, 而是无穷无尽的BUG, 早期是用Clion + Cmake的环境, 第二天开始实现游戏的界面栏目并且改变控制台标题栏以及字体颜色时, 因为要在控制台检验, 但是发现Clion + Cmake不能调出Windows的Console, 一顿查阅亦未果, 因此使用了最早使用的Codeblocks(还是这个简单多了...), 嫌弃Cb丑陋UI的我又入坑了Atom, 用Atom码代码, Cb编译.....十分的奇葩, 但是也算是完成了\n\n总体来讲, 对我感触最深的东西应该就是封装以及设计了, 这次的初版的DEMO我总体时非常不满意的, 糟糕的代码, 凌乱的代码, 混乱的设计, 可能源于我过于追求速度, 也许我做出了和视频效果相似甚至更加花里胡哨的打印结果, 但是里面的东西差距时非常遥远的, 空有其表, 败絮其中. 这种代码在日后非常难以维护, 即使我加了非常多的代码, 缩进也尽量按照标准来, 但是我自己都很难找到一个方法在哪里, 非常难以修改, 修改了一个方法可能需要同时修改其他的很多地方, 或者是修改完出现各种各样的内存问题等等...我现在认为一个方法仅仅对于一个功能是非常重要的, 而且便于记忆以及修改的宏定义我也尝到了它的甜头, 还有对整体程序的逻辑设计, 在不考虑这些东西而仅仅根据几条需求如同大一考试对于问题对于解出来就完事儿了的态度去码代码, 码出来的程序可能是正常运行的, 但是接下来的维护呢, 况且随心所欲的写方法我现在感觉是非常可怕的, 乱码一时爽, 码完以后火葬场, 每次DEBUG的时间都与真实写代码的时间一样长了, 每次改完以后心里憔悴, 这都是不好好规划设计, 拿起手就是敲的后果, 正所谓: 代码千万条, 规范第一条, 代码不规范, 亲人两行泪!写完这个DEMO也让我更加深入理解了一些数据结构, 如同此DEMO中的玩家结构, 玩家中有背包, 背包中有道具, 道具中有类别对应不同属性, 武器对应攻击力, 防具对应防御力等等, 现在我可能会思考, 需要经常插入而又很少需要随机读取的类型会不使用链表更加好一些等等的问题, 看来这波不亏\n\n最后, 可能我不会再继续修改这个DEMO了, 要么也是重写了(实在太烂了...) 感谢这个DEMO, 感谢老九, 用这样一种方式让我认识到了上课所无法理解的思想, 让我对未来的代码有了期待, 但是这只是一个极小的开始, 这只是站在了一个小石子儿看世界, 要想看到真正的世界, 还需走的更远, 爬到更高的地方去眺望, 去欣赏, 去体味)","slug":"笑傲江湖DEMO","published":1,"updated":"2019-07-16T14:32:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dbbihx001usmjbtf6901jo","content":"<h1 style=\"text-align:center\">My first console game demo <h1>\n\n<p><img src=\"https://miao.su/images/2019/02/28/2019-02-2831b3de.png\" alt=\"2019-02-2831b3de.png\"></p>\n<a id=\"more\"></a>\n\n\n<p>这个demo简单的实现了用户输入方向键, 数字键达到在不同地图切换, 购买商品, 打怪升级等功能, 希望在后期能够实现更加丰富的功能并且能连接网络对战,<br>开发环境为Atom,CodeBlocks,MinGW</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><ol>\n<li>道具</li>\n<li>地图</li>\n<li>背包(背包包括道具类型)</li>\n<li>门派</li>\n<li>玩家(玩家包含背包以及门派数据类型)</li>\n<li>怪物</li>\n</ol>\n<h3 id=\"道具-Prop\"><a href=\"#道具-Prop\" class=\"headerlink\" title=\"道具 (Prop)\"></a>道具 (Prop)</h3><p><strong>属性字段</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">编号</td>\n<td align=\"center\">int id</td>\n</tr>\n<tr>\n<td align=\"center\">名称</td>\n<td align=\"center\">char name[30]</td>\n</tr>\n<tr>\n<td align=\"center\">价格</td>\n<td align=\"center\">double price</td>\n</tr>\n<tr>\n<td align=\"center\">等级</td>\n<td align=\"center\">int level</td>\n</tr>\n<tr>\n<td align=\"center\">库存</td>\n<td align=\"center\">int stock</td>\n</tr>\n<tr>\n<td align=\"center\">类别</td>\n<td align=\"center\">propType type(使用枚举)</td>\n</tr>\n<tr>\n<td align=\"center\">最小属性</td>\n<td align=\"center\">union(使用联合体)</td>\n</tr>\n<tr>\n<td align=\"center\">最大属性</td>\n<td align=\"center\">union(使用联合体)</td>\n</tr>\n<tr>\n<td align=\"center\">描述</td>\n<td align=\"center\">char desc[200]</td>\n</tr>\n</tbody></table>\n<p>枚举代码</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">_propType</span> &#123;</span></span><br><span class=\"line\">    Weapon,     <span class=\"regexp\">//</span>武器</span><br><span class=\"line\">    Armor,      <span class=\"regexp\">//</span>防具</span><br><span class=\"line\">    Con,        <span class=\"regexp\">//</span>消耗品</span><br><span class=\"line\">    Frag,       <span class=\"regexp\">//</span>碎片</span><br><span class=\"line\">&#125; Type;</span><br></pre></td></tr></table></figure>\n\n<p>联合体代码  (不同类别拥有不同属性类别)</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">    int minAttack;     <span class=\"regexp\">//</span>如果是武器类别, 则最 低/高 攻击力为</span><br><span class=\"line\">    int minDefence;    <span class=\"regexp\">//</span>如果是防具类别, 则最 低/高 防御力为</span><br><span class=\"line\">    int minPower;      <span class=\"regexp\">//</span>如果是消耗品类别, 则最 低/高 回复值为</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">要注意若定义枚举中使用 ; 分隔开, 则报错如下(这是我自己踩过的一个坑)</span><br><span class=\"line\">Expected <span class=\"string\">'= constant-expression'</span> <span class=\"keyword\">or</span> <span class=\"keyword\">end</span> <span class=\"keyword\">of</span> <span class=\"keyword\">enumerator</span> definition</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"地图-Map\"><a href=\"#地图-Map\" class=\"headerlink\" title=\"地图(Map)\"></a>地图(Map)</h3><ul>\n<li>该DEMO的地图大小为8 * 8</li>\n<li>后期增加地图进入的等级限制</li>\n</ul>\n<p><strong>属性字段</strong> </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">编号</td>\n<td align=\"center\">int id</td>\n</tr>\n<tr>\n<td align=\"center\">名称</td>\n<td align=\"center\">char name[20]</td>\n</tr>\n<tr>\n<td align=\"center\">进入地图的最低等级</td>\n<td align=\"center\">minLevel</td>\n</tr>\n<tr>\n<td align=\"center\">坐标结构</td>\n<td align=\"center\">COORD coord</td>\n</tr>\n<tr>\n<td align=\"center\">地图描述</td>\n<td align=\"center\">desc[500]</td>\n</tr>\n<tr>\n<td align=\"center\"><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">地图的坐标使用window.h头文件下的COORD结构, 使用方式为coord<span class=\"selector-class\">.X</span> = <span class=\"number\">0</span>, coord<span class=\"selector-class\">.Y</span> = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"背包-Bag\"><a href=\"#背包-Bag\" class=\"headerlink\" title=\"背包 (Bag)\"></a>背包 (Bag)</h3><ul>\n<li>背包类型是玩家的一个属性</li>\n<li>后期改进实现人民币玩家可以提升背包容量上限</li>\n</ul>\n<p><strong>属性字段</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">所属玩家ID</td>\n<td align=\"center\">int playId</td>\n</tr>\n<tr>\n<td align=\"center\">当前的道具数量</td>\n<td align=\"center\">int propsCount</td>\n</tr>\n<tr>\n<td align=\"center\">背包最大容量</td>\n<td align=\"center\">maxCount</td>\n</tr>\n<tr>\n<td align=\"center\">道具数组</td>\n<td align=\"center\">Prop props</td>\n</tr>\n</tbody></table>\n<h3 id=\"门派-Martial\"><a href=\"#门派-Martial\" class=\"headerlink\" title=\"门派 (Martial)\"></a>门派 (Martial)</h3><ul>\n<li>门派为玩家的一个属性</li>\n<li>后期改进实现人名币玩家解锁更多帮派功能</li>\n</ul>\n<p><strong>属性字段</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">编号</td>\n<td align=\"center\">int id</td>\n</tr>\n<tr>\n<td align=\"center\">名称</td>\n<td align=\"center\">char name[20]</td>\n</tr>\n<tr>\n<td align=\"center\">门派类型</td>\n<td align=\"center\">char type[10]</td>\n</tr>\n<tr>\n<td align=\"center\">门派总部坐标结构</td>\n<td align=\"center\">COORD hqCoord</td>\n</tr>\n<tr>\n<td align=\"center\">是否对玩家开放</td>\n<td align=\"center\">int isOpen</td>\n</tr>\n<tr>\n<td align=\"center\">门派描述</td>\n<td align=\"center\">char desc[1000]</td>\n</tr>\n</tbody></table>\n<h3 id=\"玩家-Player\"><a href=\"#玩家-Player\" class=\"headerlink\" title=\"玩家 (Player)\"></a>玩家 (Player)</h3><p><strong>属性字段</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">名称</td>\n<td align=\"center\">char name[30]</td>\n</tr>\n<tr>\n<td align=\"center\">编号</td>\n<td align=\"center\">id[10]</td>\n</tr>\n<tr>\n<td align=\"center\">密码</td>\n<td align=\"center\">char passwd[30]</td>\n</tr>\n<tr>\n<td align=\"center\">等级</td>\n<td align=\"center\">int level</td>\n</tr>\n<tr>\n<td align=\"center\">经验值</td>\n<td align=\"center\">int exp</td>\n</tr>\n<tr>\n<td align=\"center\">血量</td>\n<td align=\"center\">int hp</td>\n</tr>\n<tr>\n<td align=\"center\">内力</td>\n<td align=\"center\">int mp</td>\n</tr>\n<tr>\n<td align=\"center\">金币</td>\n<td align=\"center\">int gold</td>\n</tr>\n<tr>\n<td align=\"center\">门派结构</td>\n<td align=\"center\">Martial martial</td>\n</tr>\n<tr>\n<td align=\"center\">武器道具</td>\n<td align=\"center\">Prop weapon</td>\n</tr>\n<tr>\n<td align=\"center\">防具道具</td>\n<td align=\"center\">Prop armor</td>\n</tr>\n<tr>\n<td align=\"center\">玩家当前坐标</td>\n<td align=\"center\">COORD coord</td>\n</tr>\n<tr>\n<td align=\"center\">背包结构</td>\n<td align=\"center\">Bag bag</td>\n</tr>\n</tbody></table>\n<h3 id=\"怪物-Monster\"><a href=\"#怪物-Monster\" class=\"headerlink\" title=\"怪物 (Monster)\"></a>怪物 (Monster)</h3><ul>\n<li>后期加入怪物掉落装备功能</li>\n</ul>\n<p><strong>属性字段</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">编号</td>\n<td align=\"center\">int id</td>\n</tr>\n<tr>\n<td align=\"center\">名称</td>\n<td align=\"center\">char name[20]</td>\n</tr>\n<tr>\n<td align=\"center\">等级</td>\n<td align=\"center\">int level</td>\n</tr>\n<tr>\n<td align=\"center\">血量</td>\n<td align=\"center\">int hp</td>\n</tr>\n<tr>\n<td align=\"center\">攻击力</td>\n<td align=\"center\">int attact</td>\n</tr>\n<tr>\n<td align=\"center\">防御力</td>\n<td align=\"center\">int defence</td>\n</tr>\n<tr>\n<td align=\"center\">掉落的最小金币</td>\n<td align=\"center\">int minMoney</td>\n</tr>\n<tr>\n<td align=\"center\">掉落的最大金币</td>\n<td align=\"center\">int maxMoney</td>\n</tr>\n<tr>\n<td align=\"center\">玩家能够获取的最大经验</td>\n<td align=\"center\">int exp</td>\n</tr>\n<tr>\n<td align=\"center\">怪物的状态(0死1活)</td>\n<td align=\"center\">int state</td>\n</tr>\n<tr>\n<td align=\"center\">怪物的坐标</td>\n<td align=\"center\">COORD coord</td>\n</tr>\n<tr>\n<td align=\"center\">***</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">## 功能实现</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p><strong>通过系统函数辅助实现的方法, 以下方法在GameLib源文件中</strong></p>\n<ol>\n<li>更改控制台标题(SetTitle)</li>\n<li>更改控制台内字体(SetColor)</li>\n<li>设置控制台内光标的位置(SetPosition)</li>\n</ol>\n<h3 id=\"更改控制台标题-SetTitle\"><a href=\"#更改控制台标题-SetTitle\" class=\"headerlink\" title=\"更改控制台标题(SetTitle)\"></a>更改控制台标题(SetTitle)</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 设置控制台的标题 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetTitle</span><span class=\"params\">(<span class=\"keyword\">char</span> *title)</span> </span>&#123;</span><br><span class=\"line\">    SetConsoleTitle(title);     <span class=\"comment\">//调用windows.h头文件下的系统函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改控制台内字体-SetColor\"><a href=\"#更改控制台内字体-SetColor\" class=\"headerlink\" title=\"更改控制台内字体(SetColor)\"></a>更改控制台内字体(SetColor)</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 设置控制台的颜色</span></span><br><span class=\"line\"><span class=\"comment\"> * 0-黑色,   1-蓝色,   2-绿色,    3-浅绿色,  4-红色,</span></span><br><span class=\"line\"><span class=\"comment\"> * 5-紫色,   6-黄色,   7-白色,    8-灰色,   9-淡蓝色,</span></span><br><span class=\"line\"><span class=\"comment\"> * 10-淡绿色,  11-淡浅绿色   12-淡红色   13-淡紫色</span></span><br><span class=\"line\"><span class=\"comment\"> * 14-淡黄色   15-亮白色</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetColor</span><span class=\"params\">(<span class=\"keyword\">int</span> ForeColor, <span class=\"keyword\">int</span> BackColor)</span> </span>&#123;<span class=\"comment\">//分别设置前景色与背景色</span></span><br><span class=\"line\">     <span class=\"comment\">//HANDLE: 句柄, GetStdHandle(STD_OUTPUT_HANDLE)获得标准输出流的句柄, 均为windows.h下的系统函数</span></span><br><span class=\"line\">     HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);       <span class=\"comment\">//获取当前窗口句柄</span></span><br><span class=\"line\">     SetConsoleTextAttribute(handle, ForeColor + BackColor * <span class=\"number\">0x10</span>);<span class=\"comment\">//设置颜色</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//句柄(HANDLE)补充:</span></span><br><span class=\"line\">    <span class=\"comment\">//WINDOWS程序中并不是用物理地址来标识一个内存块，文件，任务或动态装入模块的。</span></span><br><span class=\"line\">    <span class=\"comment\">//相反，WINDOWS API给这些项目分配确定的句柄并将句柄返回给应用程序，</span></span><br><span class=\"line\">    <span class=\"comment\">//然后通过句柄来进行操作(句柄不是指针, 是32或64位的无符号整型)</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设置控制台内光标的位置-SetPosition\"><a href=\"#设置控制台内光标的位置-SetPosition\" class=\"headerlink\" title=\"设置控制台内光标的位置(SetPosition)\"></a>设置控制台内光标的位置(SetPosition)</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetPosition</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">     HANDLE winHandle = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class=\"line\">     COORD pos = &#123;x, y&#125;;</span><br><span class=\"line\">     <span class=\"comment\">//SetConsoleCursorPosition()为windows.h下系统函数</span></span><br><span class=\"line\">     SetConsoleCursorPosition(winHandle, pos);      <span class=\"comment\">//设置光标位置</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>以下方法为自己定义实现游戏主要逻辑功能中比较重要的几个, 在Game源文件中</strong></p>\n<ol>\n<li><strong>GameProcess():</strong> 接收并判断用户的输入, 返回游戏的各个功能(例如用户输入方向键将会移动玩家的所在地图,输入1会显示玩家的个人信息窗口等等)这是游戏最重要的一个方法, 决定了游戏的逻辑实现, 本人水平较差, 当初没有想到将所有的操作均封装到此方法来, 因此使得判断用户输入包括方向键的接收为一个方法并且放入于main()中, 导致了维护困难, 代码不清晰等等问题 </li>\n<li><strong>Clear():</strong> 功能为清理指定区域内的所有字符, 用’\\0’替代, 达到刷新屏幕的功能, 由于清屏操作需要使用的次数极多因此封装成方法</li>\n<li><strong>ShowMonster():</strong> 该方法为显示当前地图所有怪物的信息: 等级名称, 但是我却在一个方法包含了接收用户输入导致方法过于复杂难以复用维护, 而且此方法打印怪物使用指针以及辅助数组较难理解</li>\n<li><strong>MonsterFight():</strong> 接收用户输入的怪物编号, 让玩家与怪物进行战斗, 以当前时间为种子, 攻击力防御力取范围该范围内的随机数, 战斗后返回判断打印不同情况的结果 </li>\n<li><strong>PropInit():</strong> 初始化游戏玩家数据, 用于测试功能 </li>\n<li><strong>Trade():</strong> 交易方法, 接收游戏玩家编号与商品编号, 重点为判断无法交易的情况以及对背包物品的添加(背包已有该类别商品/背包暂无此类别商品) </li>\n<li><strong>ShowProps():</strong> 显示商城的信息, 此方法与ShowMonster()类似,  同样我没考虑到方法的复用以及维护, 将Show 和 接收用户的输入 两个方法写在一个方法里了</li>\n<li><strong>showTrade():</strong> 接收Trade()返回的值, 对应交易成功与失败分别执行不同操作</li>\n<li><strong>Login():</strong> 登陆方法, 接收用户输入的用户名以及密码(无回显)进行判断以达到登陆功能</li>\n</ol>\n<h4 id=\"以下为主要方法的源代码\"><a href=\"#以下为主要方法的源代码\" class=\"headerlink\" title=\"以下为主要方法的源代码\"></a>以下为主要方法的源代码</h4><ul>\n<li><p>一些宏定义, 例如游戏窗口的各个部分的行数等等, 在移动光标时使用频率极高</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> COL 78                <span class=\"comment\">//游戏的界面的总宽度</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXGIN_X 20           <span class=\"comment\">//游戏界面与控制台的左边距</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ENDINFO 78            <span class=\"comment\">//各个框架结束'|'的列数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAPSART_START_Y 3     <span class=\"comment\">//游戏地图开始的行</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAPSART_END_Y 11      <span class=\"comment\">//游戏地图结束行</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INFORMATION_START_Y 12<span class=\"comment\">//游戏信息开始行</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INFORMATION_END_Y 19  <span class=\"comment\">//游戏信息结束行</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAINMENUE_START_Y 20  <span class=\"comment\">//游戏主菜单开始行</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAINMENUE_END_Y 28    <span class=\"comment\">//游戏主菜单结束行</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SEP <span class=\"meta-string\">\"*******************************************************************************\"</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>游戏主体的逻辑实现</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接收main()传递的<span class=\"built_in\">key</span>, 分别执行不同的功能</span><br><span class=\"line\"><span class=\"comment\">/** 执行游戏主菜单功能 */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> GameProcess(<span class=\"built_in\">char</span> <span class=\"built_in\">key</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"built_in\">key</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'1'</span>: ShowPlayerInfo();<span class=\"comment\">//显示玩家个人信息</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'2'</span>: ShowMonster();<span class=\"comment\">//显示当前地图的怪物(内有打怪)</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'3'</span>: Move(currPlayer-&gt;martial.hqCoord.X, currPlayer-&gt;martial.hqCoord.Y);<span class=\"comment\">//移动到玩家的帮派地图中</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'4'</span>: ShowProps();<span class=\"comment\">//展示游戏商品</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span> : printf(<span class=\"string\">\"少侠究竟想要作甚?\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">以下为游戏主逻辑, 死循环中对用户输入进行判断并对应相应的输出(即实现不同游戏功能)</span><br><span class=\"line\">****************************************************************************</span><br><span class=\"line\">main()包括了判断字符进行移动玩家所在地图的功能(未封装成方法!)</span><br><span class=\"line\">****************************************************************************</span><br><span class=\"line\"><span class=\"built_in\">int</span> main() &#123;<span class=\"comment\">//最好通过一个游戏进程函数将main方法里边的各种方法封装, 通过不同状态执行不同方法</span></span><br><span class=\"line\">    <span class=\"built_in\">char</span> <span class=\"built_in\">key</span>;           <span class=\"comment\">//接收用户输入</span></span><br><span class=\"line\">    SetColor(<span class=\"number\">2</span>,<span class=\"number\">0</span>);      <span class=\"comment\">//设置控制台文本颜色(front color为绿色, background color为黑色)</span></span><br><span class=\"line\">    SetConsoleTitle(<span class=\"string\">\"笑傲江湖之精忠报国 C语言实现 BY 左手工匠\"</span>);    <span class=\"comment\">//设置控制台标题</span></span><br><span class=\"line\">    PropInit();         <span class=\"comment\">//初始化测试人物</span></span><br><span class=\"line\">    ShowWelcome();      <span class=\"comment\">//显示欢迎栏</span></span><br><span class=\"line\">    Login();            <span class=\"comment\">//登陆, 登陆成功继续执行</span></span><br><span class=\"line\">    ShowMap();          <span class=\"comment\">//显示地图</span></span><br><span class=\"line\">    ShowInformation();  <span class=\"comment\">//显示信息栏</span></span><br><span class=\"line\">    ShowMainMenu();     <span class=\"comment\">//显示菜单栏</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;<span class=\"comment\">//死循环, 除非用户选择退出, 否则停止等待用户输入</span></span><br><span class=\"line\">    fflush(stdin);</span><br><span class=\"line\">    <span class=\"comment\">//接收用户输入(无回显)</span></span><br><span class=\"line\">    <span class=\"built_in\">key</span> = getch();</span><br><span class=\"line\">    fflush(stdin);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == <span class=\"string\">'1'</span> || <span class=\"built_in\">key</span> == <span class=\"string\">'2'</span> || <span class=\"built_in\">key</span> == <span class=\"string\">'3'</span> || <span class=\"built_in\">key</span> == <span class=\"string\">'4'</span>)&#123;</span><br><span class=\"line\">        GameProcess(<span class=\"built_in\">key</span>);<span class=\"comment\">//输入正常, 将值传递给GameProcess()来对应输出</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == <span class=\"string\">'5'</span> || <span class=\"built_in\">key</span> == <span class=\"string\">'6'</span> )&#123;</span><br><span class=\"line\">        SetPosition(<span class=\"number\">20</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">        Clear(<span class=\"number\">20</span> , <span class=\"number\">12</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">        SetPosition(<span class=\"number\">20</span> + <span class=\"number\">5</span>, <span class=\"number\">12</span> + <span class=\"number\">2</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"放过我吧, 还没开发完呐!!!\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == <span class=\"string\">'7'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == VK_UP || <span class=\"built_in\">key</span> == <span class=\"number\">72</span>) &#123;<span class=\"comment\">//X, Y为游戏坐标, 控制X, YS实现地图移动</span></span><br><span class=\"line\">        Y--;            <span class=\"comment\">//输入上</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == VK_RIGHT || <span class=\"built_in\">key</span> == <span class=\"number\">77</span>) &#123;</span><br><span class=\"line\">        X++;            <span class=\"comment\">//输入右</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == VK_DOWN || <span class=\"built_in\">key</span> == <span class=\"number\">80</span>) &#123;</span><br><span class=\"line\">        Y++;            <span class=\"comment\">//输入下</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == VK_LEFT || <span class=\"built_in\">key</span> == <span class=\"number\">75</span>) &#123;</span><br><span class=\"line\">        X--;            <span class=\"comment\">//输入左</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(X &gt; <span class=\"number\">7</span>) &#123;<span class=\"comment\">//移动到最边的话重新回到0, 如贪食蛇穿过地图边缘</span></span><br><span class=\"line\">        X = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(X &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        X = <span class=\"number\">7</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Y &gt; <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">        Y = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Y &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Y = <span class=\"number\">7</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ShowMap();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>清空指定区域内所有字符 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 清除信息区内所有内容(给定坐标及清理的行数) */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Clear</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> rowCount)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rowCount; i ++) &#123;</span><br><span class=\"line\">        SetPosition(x + <span class=\"number\">1</span>, y + i);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; COL - <span class=\"number\">1</span>; j ++)  &#123;    <span class=\"comment\">//使用' '替换指定区域</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打印怪物的信息以及接收并判断玩家的输入的怪物编号, 玩家选择查看怪物信息时调用该方法</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 显示当前地图的怪物********(功能略复杂些)*************/</span></span><br><span class=\"line\">void ShowMonster() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//给怪物各个等级对应相应称号</span></span><br><span class=\"line\">    <span class=\"comment\">//例如：3级怪物，那么就显示这个怪物的描述为粗通皮毛</span></span><br><span class=\"line\">    char *monsterlevelNames[] = &#123;<span class=\"string\">\"乳臭未干\"</span>, <span class=\"string\">\"初出茅庐\"</span>, <span class=\"string\">\"粗通皮毛\"</span>, <span class=\"string\">\"青年才俊\"</span>, <span class=\"string\">\"略有小成\"</span>, <span class=\"string\">\"心领神会\"</span>, <span class=\"string\">\"出类拔萃\"</span>, <span class=\"string\">\"所向无敌\"</span>, <span class=\"string\">\"天人合一\"</span>&#125;;</span><br><span class=\"line\">    Clear(MAXGIN_X,  INFORMATION_START_Y, <span class=\"number\">7</span>);   <span class=\"comment\">//清空信息区的所有内容</span></span><br><span class=\"line\">    int monsterCount;</span><br><span class=\"line\">    <span class=\"comment\">// 记录整个游戏的怪物总数</span></span><br><span class=\"line\">    monsterCount = sizeof(monsterArray) / sizeof(Monster);</span><br><span class=\"line\">    <span class=\"comment\">//记录当前地图的怪数量 记得变量定义时赋初值!!! debug了好久...</span></span><br><span class=\"line\">    int currMapMonsterCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个只有九个空间的一维数组, 用以记录怪物在怪物列表里的下标</span></span><br><span class=\"line\">    int monsterIndex[<span class=\"number\">9</span>];</span><br><span class=\"line\">    for(int i = <span class=\"number\">0</span>; i &lt; monsterCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 关键!!! 满足怪物坐标与当前地图坐标相等 并且 该怪物的状态为存活的条件, 将怪物与怪物数组的下标记录并且当前地图怪物数量自增</span></span><br><span class=\"line\">        if(monsterArray[i].coord.X == X &amp;&amp; monsterArray[i].coord.Y == Y &amp;&amp; monsterArray[i].<span class=\"section\">state</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 记录下标</span></span><br><span class=\"line\">            monsterIndex[currMapMonsterCount] = i;</span><br><span class=\"line\">            currMapMonsterCount++;</span><br><span class=\"line\">            <span class=\"comment\">// 设定每个地图最多显示 9 个怪物</span></span><br><span class=\"line\">            if(currMapMonsterCount == <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打印怪物</span></span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">1</span>);</span><br><span class=\"line\">    if(currMapMonsterCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        SetColor(<span class=\"number\">7</span>, <span class=\"number\">0</span>);<span class=\"comment\">//白字黑底</span></span><br><span class=\"line\">        printf(<span class=\"string\">\"这里冷冷清清的什么也没有, 少侠还是到别处看看吧, 呆着也没银子给你!\"</span>);</span><br><span class=\"line\">        SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);<span class=\"comment\">//恢复颜色</span></span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*********以下语句为判定用户输入的编号来返回地图信息或进行打怪操作*******/</span></span><br><span class=\"line\">    int pkMonsterId = <span class=\"number\">0</span>;<span class=\"comment\">// 接收玩家输入的怪物编号, 定义在循环外部是因为循环外仍需使用进行判断是否打印地图信息</span></span><br><span class=\"line\">    while(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        pkMonsterId = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        Clear(MAXGIN_X,  INFORMATION_START_Y, <span class=\"number\">7</span>);   <span class=\"comment\">//清空信息区的所有内容</span></span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">20</span>, INFORMATION_START_Y + <span class=\"number\">0</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"少侠, 这儿有怪物! 要为百姓除暴安良吗?\"</span> );</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">2</span>);</span><br><span class=\"line\">        for(int i = <span class=\"number\">0</span>; i &lt; currMapMonsterCount; i++) &#123;</span><br><span class=\"line\">            if(i % <span class=\"number\">3</span> == <span class=\"number\">0</span> &amp;&amp; i != <span class=\"number\">0</span>)&#123;<span class=\"comment\">//每行打印三个怪物</span></span><br><span class=\"line\">                SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">2</span> + i / <span class=\"number\">3</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//打印怪物, 较为繁琐</span></span><br><span class=\"line\">            <span class=\"comment\">//monsterIndex[i]即为该怪物列表中的怪物编号</span></span><br><span class=\"line\">            SetColor(<span class=\"number\">4</span>, <span class=\"number\">0</span>);<span class=\"comment\">//红字怪物</span></span><br><span class=\"line\">            printf(<span class=\"string\">\"%d.%s(%s)<span class=\"subst\">\\t</span>  \"</span>, i + <span class=\"number\">1</span>, monsterArray[monsterIndex[i]].name, monsterlevelNames[monsterArray[monsterIndex[i]].level - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);<span class=\"comment\">//恢复颜色</span></span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"少侠想攻击几号怪物呢? (按0返回)\"</span>);</span><br><span class=\"line\">        scanf(<span class=\"string\">\"%d\"</span>, &amp;pkMonsterId);</span><br><span class=\"line\">        if(pkMonsterId == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//输入0, 退出循环来返回显示地图信息</span></span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if(pkMonsterId &lt; <span class=\"number\">0</span> || pkMonsterId &gt; currMapMonsterCount) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//输入的怪物标号在当前地图不存在</span></span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">//简易清屏</span></span><br><span class=\"line\">            printf(<span class=\"string\">\"                                                             \"</span>);</span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">            printf(<span class=\"string\">\"少侠选错了吧, 怪物不存在呢!(按任意键重新输入)\"</span>);</span><br><span class=\"line\">            char recoverKey = getch();</span><br><span class=\"line\">            if(recoverKey)&#123;<span class=\"comment\">//停顿直到接收任意键后重新显示怪物</span></span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;<span class=\"comment\">//编号对应地图所有的怪物时, 将怪物地址传入打怪方法</span></span><br><span class=\"line\">            MonsterFight(&amp;monsterArray[monsterIndex[pkMonsterId - <span class=\"number\">1</span>]]);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(pkMonsterId == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//输入0, 返回显示地图信息</span></span><br><span class=\"line\">        ShowMapInfo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>玩家与指定地图指定怪兽进行战斗</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 选定怪物进行对战 */</span></span><br><span class=\"line\">void MonsterFight(Monster *monster) &#123;</span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    printf(<span class=\"string\">\"                                                             \"</span>);<span class=\"comment\">//简易清屏(偷懒)</span></span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    srand(<span class=\"built_in\">time</span>(NULL));<span class=\"comment\">//以当前时间为种子</span></span><br><span class=\"line\">    <span class=\"comment\">/* random函数的用法(只能0 - 32767之间)</span></span><br><span class=\"line\"><span class=\"comment\">    * 随机一个a ~ b的数字, 即 rand() % (b - a + 1) + a; 例如0 ~ 5, 即rand() % 6;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    int playerAttact = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 玩家的实际攻击力</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">playerAttact</span> = rand() % (currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">weapon</span>.maxAttack - currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">weapon</span>.minAttack + 1) + currPlayer-&gt;</span>weapon.minAttack;</span><br><span class=\"line\">    int playerDeffence =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//玩家实际防御力</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">playerDeffence</span> = rand() % (currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">armor</span>.maxDefence - currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">armor</span>.minDefence + 1) + currPlayer-&gt;</span>armor.minDefence;</span><br><span class=\"line\">    <span class=\"comment\">//怪物实际掉落的金钱</span></span><br><span class=\"line\">    int monsterGold = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">monsterGold</span> = rand() % (monster-&gt;</span><span class=\"function\"><span class=\"title\">maxMoney</span> - monster-&gt;</span><span class=\"function\"><span class=\"title\">minMoney</span> + 1) + monster-&gt;</span>minMoney;</span><br><span class=\"line\">    int pkRound = <span class=\"number\">0</span>;    <span class=\"comment\">//记录战斗的轮次</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;<span class=\"comment\">//打斗循环, 任意一方死亡退出</span></span><br><span class=\"line\">        <span class=\"comment\">//玩家血量变化</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span><span class=\"function\"><span class=\"title\">hp</span> -= monster-&gt;</span>attact - playerDeffence;</span><br><span class=\"line\">        <span class=\"comment\">//怪物的血量变化</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">monster</span>-&gt;</span><span class=\"function\"><span class=\"title\">hp</span> -= playerAttact - monster-&gt;</span>defence;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">if</span>(monster-&gt;</span>hp &lt;= <span class=\"number\">0</span>) &#123;<span class=\"comment\">//怪物的血量少于等于0时退出</span></span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">if</span>(currPlayer-&gt;</span>hp &lt;= <span class=\"number\">0</span>) &#123;<span class=\"comment\">//玩家血量小于等于0时退出</span></span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//以下为打印战斗详情</span></span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"                                                                         \"</span>);<span class=\"comment\">//简易清屏(偷懒)</span></span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        pkRound++;</span><br><span class=\"line\">        <span class=\"comment\">//战斗详情使用白底红字</span></span><br><span class=\"line\">        SetColor(<span class=\"number\">4</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\">        <span class=\"comment\">//该语句较长......</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">printf</span>(\"第 %d 轮战斗详情:%s 对 %s 造成了 %d 伤害且受到 %s %d 的伤害\", pkRound, currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">name</span>, monster-&gt;</span><span class=\"function\"><span class=\"title\">name</span>, playerAttact - monster-&gt;</span><span class=\"function\"><span class=\"title\">defence</span>, monster-&gt;</span><span class=\"function\"><span class=\"title\">name</span>, monster-&gt;</span>attact - playerDeffence);</span><br><span class=\"line\">        <span class=\"comment\">//放慢过程</span></span><br><span class=\"line\">        usleep(<span class=\"number\">1000</span> * <span class=\"number\">800</span>);<span class=\"comment\">//1000毫秒*800</span></span><br><span class=\"line\">        SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    printf(<span class=\"string\">\"                                                                   \"</span>);<span class=\"comment\">//简易清屏(偷懒)</span></span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span>(currPlayer-&gt;</span>hp &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//玩家死亡输入完任意键后返回</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">printf</span>(\"江湖快讯: 大侠 %s 在与 %s 的对决中壮烈牺牲! (请按任意键返回)\", currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">name</span>, monster-&gt;</span><span class=\"keyword\">name</span>);</span><br><span class=\"line\">        <span class=\"comment\">//重置人物的金币与血量</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>hp = <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>gold = <span class=\"number\">100</span>;</span><br><span class=\"line\">        getch();</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//以下即为怪物死亡的情况</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">printf</span>(\"%s 轻而易举的便被 %s 大侠收拾了, 同时掉落了 \", monster-&gt;</span><span class=\"function\"><span class=\"title\">name</span>, currPlayer-&gt;</span><span class=\"keyword\">name</span>);</span><br><span class=\"line\">    <span class=\"comment\">//将怪物的状态调整至死亡</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">monster</span>-&gt;</span>state = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//设置金币的front color为黄色, background color为亮白色</span></span><br><span class=\"line\">    SetColor(<span class=\"number\">6</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">    printf(<span class=\"string\">\"%d 金币   \"</span>, monsterGold);</span><br><span class=\"line\">    <span class=\"comment\">// 设置经验的front color为黄色, background color为亮白色</span></span><br><span class=\"line\">    SetColor(<span class=\"number\">1</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">printf</span>(\"%d 经验  \", monster-&gt;</span><span class=\"built_in\">exp</span>);</span><br><span class=\"line\">    SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>); <span class=\"comment\">//颜色恢复</span></span><br><span class=\"line\">    <span class=\"comment\">//玩家获得金币与经验值的加成</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>gold += monsterGold;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span><span class=\"function\"><span class=\"title\">exp</span> += monster-&gt;</span><span class=\"built_in\">exp</span>;</span><br><span class=\"line\">    getch();</span><br><span class=\"line\">    ShowMonster();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>初始化游戏数据: 将地图, 玩家, 装备, 怪物置入, 测试各功能</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Player *currPlayer;</span><br><span class=\"line\">void PropInit() &#123;<span class=\"comment\">//初始化游戏数据 (测试用数据)</span></span><br><span class=\"line\">    currPlayer = &amp;playArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>weapon = propArray[<span class=\"number\">8</span>];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>armor = propArray[<span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>martial = martials[<span class=\"number\">4</span>];</span><br><span class=\"line\">    Bag bag = &#123;<span class=\"number\">95001</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>bag = bag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>交易, 玩家购买指定道具</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 交易</span></span><br><span class=\"line\"><span class=\"comment\">  * 参数1: 玩家的地址</span></span><br><span class=\"line\"><span class=\"comment\">  * 参数2: 商品的编号</span></span><br><span class=\"line\"><span class=\"comment\">  * 返回交易是否成功, 0 失败, 1 成功</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">int Trade(Player *player, int propsId) &#123;</span><br><span class=\"line\">    Prop *tradeProp = NULL;     <span class=\"comment\">//定义一个用于指向及交易商品的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(int i = <span class=\"number\">0</span>; i &lt; sizeof(propArray) / sizeof(Prop); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(propsId == propArray[i].id) &#123;<span class=\"comment\">//找到该商品, 并让tradeProp指向它</span></span><br><span class=\"line\">            tradeProp = propArray + i;  <span class=\"comment\">//即tradeProp = &amp;propArray[i]</span></span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断商品是否有库存</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span>(tradeProp-&gt;</span>stock &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Clear(MAXGIN_X, INFORMATION_END_Y - <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"地主家都没有余粮！商店都被买空啦！\"</span>);</span><br><span class=\"line\">        return <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断玩家是否金币足够支付</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span>(currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">gold</span> &lt; tradeProp-&gt;</span>price) &#123;</span><br><span class=\"line\">        Clear(MAXGIN_X, INFORMATION_END_Y - <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"钱包都是瘪的，这可是个看钱的江湖！！!\"</span>);</span><br><span class=\"line\">        return <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断玩家背包容量是否充足</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span>(currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.propsCount &gt; currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.maxCount &amp;&amp; currPlayer-&gt;</span>bag.propsCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//玩家的背包道具数量大于最大容量并且背包道具数不为0则判定为失败</span></span><br><span class=\"line\">        Clear(MAXGIN_X, INFORMATION_END_Y - <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"背包已满，交易失败！\"</span>);</span><br><span class=\"line\">        return <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//满足交易条件，执行交易的业务操作</span></span><br><span class=\"line\">    <span class=\"comment\">//1、商品库存-1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">tradeProp</span>-&gt;</span>stock--;</span><br><span class=\"line\">    <span class=\"comment\">//2、玩家金币-商品单价</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">player</span>-&gt;</span><span class=\"function\"><span class=\"title\">gold</span> -= tradeProp-&gt;</span>price;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//*****************************玩家背包道具增加*******************************//</span></span><br><span class=\"line\">    <span class=\"comment\">//判断玩家背包中是否已有该商品 !!!</span></span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">for</span>(i = 0; i &lt; currPlayer-&gt;</span>bag.propsCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">if</span>(propsId == currPlayer-&gt;</span>bag.props[i].id) &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>bag.props[i].stock++;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//若为循环正常结束, i = currPlayer-&gt;bag.propsCount, 即为背包无此商品, 需要给背包添加该商品!!!</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span>(i == currPlayer-&gt;</span>bag.propsCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//向背包中创建一个商品-复制一份要交易的商品信息到背包中</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.props[currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.propsCount].id = tradeProp-&gt;</span>id;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.props[currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.propsCount].price = tradeProp-&gt;</span>price;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.props[currPlayer-&gt;</span>bag.propsCount].stock = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">strcpy</span>(currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.props[currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.propsCount].<span class=\"keyword\">name</span>, tradeProp-&gt;</span><span class=\"keyword\">name</span>);</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">strcpy</span>(currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.props[currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.propsCount].desc, tradeProp-&gt;</span>desc);</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>bag.propsCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//交易成功</span></span><br><span class=\"line\">    return <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>打印商品列表, 玩家选择购买道具调用该方法</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 展示游戏商品 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ShowProps</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//此方法应拆分为打印商品 以及用户输入并检验商品编号两个方法!!!!!!!!</span></span><br><span class=\"line\">    <span class=\"comment\">/*******************************/</span></span><br><span class=\"line\">    Clear(MAXGIN_X, INFORMATION_START_Y, <span class=\"number\">7</span>);</span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y);</span><br><span class=\"line\">    SetColor(<span class=\"number\">8</span>, <span class=\"number\">0</span>);     <span class=\"comment\">//灰字黑底</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"欢迎大侠 %s 来到 %s 童叟无欺的杂货铺, 瞧一瞧看一看可有需要的?\"</span>, currPlayer-&gt;name, mapArray[X][Y].name);</span><br><span class=\"line\">    SetColor(<span class=\"number\">6</span>, <span class=\"number\">0</span>);     <span class=\"comment\">//黄字黑底</span></span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> propCount = <span class=\"keyword\">sizeof</span>(propArray) / <span class=\"keyword\">sizeof</span>(Prop) &gt;= <span class=\"number\">9</span> ? <span class=\"number\">9</span> : <span class=\"keyword\">sizeof</span>(propArray) / <span class=\"keyword\">sizeof</span>(Prop);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; propCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i % <span class=\"number\">3</span> == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//打印商品, 每行 3 个, 且只打印最多 9 个</span></span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">2</span> + i / <span class=\"number\">3</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%-3d.%-10s(%-2d)%-4c\"</span>, propArray[i].id, propArray[i].name, propArray[i].stock, <span class=\"string\">' '</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);<span class=\"comment\">//恢复颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tradeId;<span class=\"comment\">//接收用户输入的商品编号</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于判断输入编号是否正确(此判断未包括检验玩家金币及商品库存及玩家背包是否已满等状态)</span></span><br><span class=\"line\">        Clear(MAXGIN_X, INFORMATION_END_Y - <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"大侠需要什么, 请输入编号立即购买(按 0 退出)\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;tradeId);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tradeId == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//输入0返回显示地图信息</span></span><br><span class=\"line\">            ShowMapInfo();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tradeId &lt; <span class=\"number\">0</span> || tradeId &gt; <span class=\"number\">9</span>) &#123;<span class=\"comment\">//输入的商品编号错误的情况, 重新输入</span></span><br><span class=\"line\">            Clear(MAXGIN_X, INFORMATION_END_Y - <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"少侠选错了吧, 商品不存在呢!(按任意键重新输入)\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">char</span> recoverKey = getch();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(recoverKey)&#123;<span class=\"comment\">//停顿直到接收任意键后重新显示怪物</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//输入在1 - 9的情况, 将编号传入交易函数</span></span><br><span class=\"line\">            showTrade(Trade(currPlayer, tradeId), tradeId);<span class=\"comment\">//******调用交易方法, 展示交易信息方法******//</span></span><br><span class=\"line\">            <span class=\"comment\">//以下为重新刷新商品列表, 应该封装为一个打印商品的方法, 该ShowProps()方法过于繁琐, 加入了打印以及检验两个功能</span></span><br><span class=\"line\">            <span class=\"comment\">/********************************/</span></span><br><span class=\"line\">            Clear(MAXGIN_X, INFORMATION_START_Y, <span class=\"number\">7</span>);</span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y);</span><br><span class=\"line\">            SetColor(<span class=\"number\">8</span>, <span class=\"number\">0</span>);     <span class=\"comment\">//灰字黑底</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"欢迎大侠 %s 来到 %s 童叟无欺的杂货铺, 瞧一瞧看一看可有需要的?\"</span>, currPlayer-&gt;name, mapArray[X][Y].name);</span><br><span class=\"line\">            SetColor(<span class=\"number\">6</span>, <span class=\"number\">0</span>);     <span class=\"comment\">//黄字黑底</span></span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> propCount = <span class=\"keyword\">sizeof</span>(propArray) / <span class=\"keyword\">sizeof</span>(Prop) &gt;= <span class=\"number\">9</span> ? <span class=\"number\">9</span> : <span class=\"keyword\">sizeof</span>(propArray) / <span class=\"keyword\">sizeof</span>(Prop);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; propCount; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i % <span class=\"number\">3</span> == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//打印商品, 每行 3 个, 且只打印最多 9 个</span></span><br><span class=\"line\">                    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">2</span> + i / <span class=\"number\">3</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%-3d.%-10s(%-2d)%-4c\"</span>, propArray[i].id, propArray[i].name, propArray[i].stock, <span class=\"string\">' '</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);<span class=\"comment\">//恢复颜色</span></span><br><span class=\"line\">            <span class=\"comment\">/********************************/</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回交易结束后的信息</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 接收Trade()返回的值, 判断交易是否成功 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">void</span> <span class=\"selector-tag\">showTrade</span>(int flag, int propId) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span>(flag == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">ShowMapInfo</span>();</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span>(flag == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">Clear</span>(MAXGIN_X, INFORMATION_END_Y - <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"selector-tag\">SetPosition</span>(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"selector-tag\">printf</span>(<span class=\"string\">\"交易成功, \"</span>);</span><br><span class=\"line\">        <span class=\"selector-tag\">SetColor</span>(<span class=\"number\">6</span>, <span class=\"number\">0</span>);     <span class=\"comment\">//打印装备为黑底黄字</span></span><br><span class=\"line\">        <span class=\"selector-tag\">printf</span>(<span class=\"string\">\"%s\"</span>, propArray[propId - <span class=\"number\">1</span>].name);</span><br><span class=\"line\">        <span class=\"selector-tag\">SetColor</span>(<span class=\"number\">2</span>, <span class=\"number\">0</span>);     <span class=\"comment\">//恢复黑底绿字</span></span><br><span class=\"line\">        <span class=\"selector-tag\">printf</span>(<span class=\"string\">\" 已经加入你的背包, 赶紧瞧一瞧吧!(按任意键继续)\"</span>);</span><br><span class=\"line\">        <span class=\"selector-tag\">getch</span>();            <span class=\"comment\">//暂停</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>验证登陆信息</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 玩家登陆(暂无注册) */</span></span><br><span class=\"line\">void Login() &#123;</span><br><span class=\"line\">    while(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        char id[<span class=\"number\">10</span>];</span><br><span class=\"line\">        char <span class=\"type\">key</span>[<span class=\"number\">10</span>];       <span class=\"comment\">//接收用户输入的id 和 passwd</span></span><br><span class=\"line\">        SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        Clear(MAXGIN_X, MAPSART_START_Y, <span class=\"number\">4</span>);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">24</span>, MAPSART_START_Y);</span><br><span class=\"line\">        printf(<span class=\"string\">\"请在下方输入您的用户名和密码\"</span>);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, MAPSART_START_Y + <span class=\"number\">1</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"用户名: \"</span>);</span><br><span class=\"line\">        scanf(<span class=\"string\">\"%s\"</span>, id);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, MAPSART_START_Y  + <span class=\"number\">2</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"密码(无回显哦回车确定): \"</span>);</span><br><span class=\"line\">        for(int i = <span class=\"number\">0</span>; <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">key</span>[i] = getch();<span class=\"comment\">//无回显输入密码</span></span><br><span class=\"line\">            if(<span class=\"type\">key</span>[i] == <span class=\"number\">13</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//接收到回车跳出循环</span></span><br><span class=\"line\">                <span class=\"comment\">//将回车字符重置为空字符</span></span><br><span class=\"line\">                <span class=\"type\">key</span>[i] = '\\<span class=\"number\">0</span>';</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断玩家输入的信息是否与玩家id, passwd匹配</span></span><br><span class=\"line\">        if(strcmp(currPlayer-&gt;id, id) == <span class=\"number\">0</span> &amp;&amp; strcmp(currPlayer-&gt;passwd, <span class=\"type\">key</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//只有玩家输入成功才跳出死循环</span></span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, MAPSART_START_Y + <span class=\"number\">3</span>);</span><br><span class=\"line\">            SetColor(<span class=\"number\">12</span>, <span class=\"number\">0</span>);    <span class=\"comment\">//浅红色字体</span></span><br><span class=\"line\">            printf(<span class=\"string\">\"用户名或密码错误, 请检查后再次输入!(按任意键继续)\"</span>);</span><br><span class=\"line\">            getch();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//用户输入成功后</span></span><br><span class=\"line\">    SetColor(<span class=\"number\">12</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    SetPosition(MAXGIN_X, MAPSART_START_Y);</span><br><span class=\"line\">    Clear(MAXGIN_X, MAPSART_START_Y, <span class=\"number\">4</span>);</span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">15</span>, MAPSART_START_Y);</span><br><span class=\"line\">    printf(<span class=\"string\">\"欢迎 \"</span>);</span><br><span class=\"line\">    SetColor(<span class=\"number\">1</span>, <span class=\"number\">0</span>);      <span class=\"comment\">//蓝字显示玩家name</span></span><br><span class=\"line\">    printf(<span class=\"string\">\"%s\"</span>, currPlayer-&gt;name);</span><br><span class=\"line\">    SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    printf(<span class=\"string\">\" 成功登陆笑傲江湖的世界(按任意键继续)\"</span>);</span><br><span class=\"line\">    getch();    <span class=\"comment\">//暂停</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"拓展功能\"><a href=\"#拓展功能\" class=\"headerlink\" title=\"拓展功能\"></a>拓展功能</h2><p>以下的功能为此DEMO适合拓展的有趣功能:</p>\n<ul>\n<li>玩家的背包容量: 初始设定只有9, 可以通过充值元宝等方式扩充背包最大容量</li>\n<li>注册功能, 玩家设定任意符合指定规则的用户名及密码, 并且在下次可以继续使用</li>\n<li>NPC, 逻辑与怪物相似, 地图随机刷新NPC并且贩卖普通商店没有的道具</li>\n<li>打斗过程加入回复, 增益等功能(打斗前使用消耗品提升属性, 打斗过程回复血量, 内力)</li>\n<li>怪物指定时间刷新</li>\n<li>连接网络, 满足两个玩家在同一张地图进行, 怪物道具资源同步刷新, 并且玩家可以决斗(遥远的目标啊)</li>\n</ul>\n<h2 id=\"最后的吐槽\"><a href=\"#最后的吐槽\" class=\"headerlink\" title=\"最后的吐槽\"></a>最后的吐槽</h2><p>先说说为什么要写这个极小极小的DEMO吧, 寒假前半段在学数据结构, 时间较短, 仅仅实现了顺序表, 单链表, 循环链表等几个简单的数据结构的定义以及实现, 过程不算太美好: 虽然大二上讲过数据结构与算法, 但是非常的粗略, 对数据结构与算法的理解仅仅为有那么几种表, 有那么几种排序方式, 而且C是大一上学的, 早已忘得一干二净, 很多语法尤其是之前就不过关的指针的不熟悉, 应验了那句: 当C的指针指向你的时候, 菜鸡原形毕露! 被头指针头结点折腾的头皮发麻, 尽管磕磕绊绊用代码实现了, 但我深刻感受到了效率的低下, 进度十分缓慢, 遂觉得应该恶补以下C, 于是有了以上的DEMO</p>\n<p>前前后后一共花了十天, 四天的时间都是疯狂刷视频, 把指针, 结构体, 字符串, 数组这四个章节重点看了一到两遍, 然后六天把这个DEMO完成了, 跟着老九的视频, 每天看完示范再理解完敲代码实现, 慢慢的也完成了, 自己也没想到可以写出1000行的东西(可能是我注释比较多吧捂脸), 过程最难过的不是理解也不是一行一行敲出一个功能, 而是无穷无尽的BUG, 早期是用Clion + Cmake的环境, 第二天开始实现游戏的界面栏目并且改变控制台标题栏以及字体颜色时, 因为要在控制台检验, 但是发现Clion + Cmake不能调出Windows的Console, 一顿查阅亦未果, 因此使用了最早使用的Codeblocks(还是这个简单多了…), 嫌弃Cb丑陋UI的我又入坑了Atom, 用Atom码代码, Cb编译…..十分的奇葩, 但是也算是完成了</p>\n<p>总体来讲, 对我感触最深的东西应该就是封装以及设计了, 这次的初版的DEMO我总体时非常不满意的, 糟糕的代码, 凌乱的代码, 混乱的设计, 可能源于我过于追求速度, 也许我做出了和视频效果相似甚至更加花里胡哨的打印结果, 但是里面的东西差距时非常遥远的, 空有其表, 败絮其中. 这种代码在日后非常难以维护, 即使我加了非常多的代码, 缩进也尽量按照标准来, 但是我自己都很难找到一个方法在哪里, 非常难以修改, 修改了一个方法可能需要同时修改其他的很多地方, 或者是修改完出现各种各样的内存问题等等…我现在认为一个方法仅仅对于一个功能是非常重要的, 而且便于记忆以及修改的宏定义我也尝到了它的甜头, 还有对整体程序的逻辑设计, 在不考虑这些东西而仅仅根据几条需求如同大一考试对于问题对于解出来就完事儿了的态度去码代码, 码出来的程序可能是正常运行的, 但是接下来的维护呢, 况且随心所欲的写方法我现在感觉是非常可怕的, 乱码一时爽, 码完以后火葬场, 每次DEBUG的时间都与真实写代码的时间一样长了, 每次改完以后心里憔悴, 这都是不好好规划设计, 拿起手就是敲的后果, 正所谓: 代码千万条, 规范第一条, 代码不规范, 亲人两行泪!写完这个DEMO也让我更加深入理解了一些数据结构, 如同此DEMO中的玩家结构, 玩家中有背包, 背包中有道具, 道具中有类别对应不同属性, 武器对应攻击力, 防具对应防御力等等, 现在我可能会思考, 需要经常插入而又很少需要随机读取的类型会不使用链表更加好一些等等的问题, 看来这波不亏</p>\n<p>最后, 可能我不会再继续修改这个DEMO了, 要么也是重写了(实在太烂了…) 感谢这个DEMO, 感谢老九, 用这样一种方式让我认识到了上课所无法理解的思想, 让我对未来的代码有了期待, 但是这只是一个极小的开始, 这只是站在了一个小石子儿看世界, 要想看到真正的世界, 还需走的更远, 爬到更高的地方去眺望, 去欣赏, 去体味)</p>\n</h1></h1>","site":{"data":{}},"excerpt":"<h1 style=\"text-align:center\">My first console game demo <h1>\n\n<p><img src=\"https://miao.su/images/2019/02/28/2019-02-2831b3de.png\" alt=\"2019-02-2831b3de.png\"></p>","more":"<p>这个demo简单的实现了用户输入方向键, 数字键达到在不同地图切换, 购买商品, 打怪升级等功能, 希望在后期能够实现更加丰富的功能并且能连接网络对战,<br>开发环境为Atom,CodeBlocks,MinGW</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><ol>\n<li>道具</li>\n<li>地图</li>\n<li>背包(背包包括道具类型)</li>\n<li>门派</li>\n<li>玩家(玩家包含背包以及门派数据类型)</li>\n<li>怪物</li>\n</ol>\n<h3 id=\"道具-Prop\"><a href=\"#道具-Prop\" class=\"headerlink\" title=\"道具 (Prop)\"></a>道具 (Prop)</h3><p><strong>属性字段</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">编号</td>\n<td align=\"center\">int id</td>\n</tr>\n<tr>\n<td align=\"center\">名称</td>\n<td align=\"center\">char name[30]</td>\n</tr>\n<tr>\n<td align=\"center\">价格</td>\n<td align=\"center\">double price</td>\n</tr>\n<tr>\n<td align=\"center\">等级</td>\n<td align=\"center\">int level</td>\n</tr>\n<tr>\n<td align=\"center\">库存</td>\n<td align=\"center\">int stock</td>\n</tr>\n<tr>\n<td align=\"center\">类别</td>\n<td align=\"center\">propType type(使用枚举)</td>\n</tr>\n<tr>\n<td align=\"center\">最小属性</td>\n<td align=\"center\">union(使用联合体)</td>\n</tr>\n<tr>\n<td align=\"center\">最大属性</td>\n<td align=\"center\">union(使用联合体)</td>\n</tr>\n<tr>\n<td align=\"center\">描述</td>\n<td align=\"center\">char desc[200]</td>\n</tr>\n</tbody></table>\n<p>枚举代码</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">_propType</span> &#123;</span></span><br><span class=\"line\">    Weapon,     <span class=\"regexp\">//</span>武器</span><br><span class=\"line\">    Armor,      <span class=\"regexp\">//</span>防具</span><br><span class=\"line\">    Con,        <span class=\"regexp\">//</span>消耗品</span><br><span class=\"line\">    Frag,       <span class=\"regexp\">//</span>碎片</span><br><span class=\"line\">&#125; Type;</span><br></pre></td></tr></table></figure>\n\n<p>联合体代码  (不同类别拥有不同属性类别)</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">    int minAttack;     <span class=\"regexp\">//</span>如果是武器类别, 则最 低/高 攻击力为</span><br><span class=\"line\">    int minDefence;    <span class=\"regexp\">//</span>如果是防具类别, 则最 低/高 防御力为</span><br><span class=\"line\">    int minPower;      <span class=\"regexp\">//</span>如果是消耗品类别, 则最 低/高 回复值为</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">要注意若定义枚举中使用 ; 分隔开, 则报错如下(这是我自己踩过的一个坑)</span><br><span class=\"line\">Expected <span class=\"string\">'= constant-expression'</span> <span class=\"keyword\">or</span> <span class=\"keyword\">end</span> <span class=\"keyword\">of</span> <span class=\"keyword\">enumerator</span> definition</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"地图-Map\"><a href=\"#地图-Map\" class=\"headerlink\" title=\"地图(Map)\"></a>地图(Map)</h3><ul>\n<li>该DEMO的地图大小为8 * 8</li>\n<li>后期增加地图进入的等级限制</li>\n</ul>\n<p><strong>属性字段</strong> </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">编号</td>\n<td align=\"center\">int id</td>\n</tr>\n<tr>\n<td align=\"center\">名称</td>\n<td align=\"center\">char name[20]</td>\n</tr>\n<tr>\n<td align=\"center\">进入地图的最低等级</td>\n<td align=\"center\">minLevel</td>\n</tr>\n<tr>\n<td align=\"center\">坐标结构</td>\n<td align=\"center\">COORD coord</td>\n</tr>\n<tr>\n<td align=\"center\">地图描述</td>\n<td align=\"center\">desc[500]</td>\n</tr>\n<tr>\n<td align=\"center\"><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">地图的坐标使用window.h头文件下的COORD结构, 使用方式为coord<span class=\"selector-class\">.X</span> = <span class=\"number\">0</span>, coord<span class=\"selector-class\">.Y</span> = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"背包-Bag\"><a href=\"#背包-Bag\" class=\"headerlink\" title=\"背包 (Bag)\"></a>背包 (Bag)</h3><ul>\n<li>背包类型是玩家的一个属性</li>\n<li>后期改进实现人民币玩家可以提升背包容量上限</li>\n</ul>\n<p><strong>属性字段</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">所属玩家ID</td>\n<td align=\"center\">int playId</td>\n</tr>\n<tr>\n<td align=\"center\">当前的道具数量</td>\n<td align=\"center\">int propsCount</td>\n</tr>\n<tr>\n<td align=\"center\">背包最大容量</td>\n<td align=\"center\">maxCount</td>\n</tr>\n<tr>\n<td align=\"center\">道具数组</td>\n<td align=\"center\">Prop props</td>\n</tr>\n</tbody></table>\n<h3 id=\"门派-Martial\"><a href=\"#门派-Martial\" class=\"headerlink\" title=\"门派 (Martial)\"></a>门派 (Martial)</h3><ul>\n<li>门派为玩家的一个属性</li>\n<li>后期改进实现人名币玩家解锁更多帮派功能</li>\n</ul>\n<p><strong>属性字段</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">编号</td>\n<td align=\"center\">int id</td>\n</tr>\n<tr>\n<td align=\"center\">名称</td>\n<td align=\"center\">char name[20]</td>\n</tr>\n<tr>\n<td align=\"center\">门派类型</td>\n<td align=\"center\">char type[10]</td>\n</tr>\n<tr>\n<td align=\"center\">门派总部坐标结构</td>\n<td align=\"center\">COORD hqCoord</td>\n</tr>\n<tr>\n<td align=\"center\">是否对玩家开放</td>\n<td align=\"center\">int isOpen</td>\n</tr>\n<tr>\n<td align=\"center\">门派描述</td>\n<td align=\"center\">char desc[1000]</td>\n</tr>\n</tbody></table>\n<h3 id=\"玩家-Player\"><a href=\"#玩家-Player\" class=\"headerlink\" title=\"玩家 (Player)\"></a>玩家 (Player)</h3><p><strong>属性字段</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">名称</td>\n<td align=\"center\">char name[30]</td>\n</tr>\n<tr>\n<td align=\"center\">编号</td>\n<td align=\"center\">id[10]</td>\n</tr>\n<tr>\n<td align=\"center\">密码</td>\n<td align=\"center\">char passwd[30]</td>\n</tr>\n<tr>\n<td align=\"center\">等级</td>\n<td align=\"center\">int level</td>\n</tr>\n<tr>\n<td align=\"center\">经验值</td>\n<td align=\"center\">int exp</td>\n</tr>\n<tr>\n<td align=\"center\">血量</td>\n<td align=\"center\">int hp</td>\n</tr>\n<tr>\n<td align=\"center\">内力</td>\n<td align=\"center\">int mp</td>\n</tr>\n<tr>\n<td align=\"center\">金币</td>\n<td align=\"center\">int gold</td>\n</tr>\n<tr>\n<td align=\"center\">门派结构</td>\n<td align=\"center\">Martial martial</td>\n</tr>\n<tr>\n<td align=\"center\">武器道具</td>\n<td align=\"center\">Prop weapon</td>\n</tr>\n<tr>\n<td align=\"center\">防具道具</td>\n<td align=\"center\">Prop armor</td>\n</tr>\n<tr>\n<td align=\"center\">玩家当前坐标</td>\n<td align=\"center\">COORD coord</td>\n</tr>\n<tr>\n<td align=\"center\">背包结构</td>\n<td align=\"center\">Bag bag</td>\n</tr>\n</tbody></table>\n<h3 id=\"怪物-Monster\"><a href=\"#怪物-Monster\" class=\"headerlink\" title=\"怪物 (Monster)\"></a>怪物 (Monster)</h3><ul>\n<li>后期加入怪物掉落装备功能</li>\n</ul>\n<p><strong>属性字段</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">编号</td>\n<td align=\"center\">int id</td>\n</tr>\n<tr>\n<td align=\"center\">名称</td>\n<td align=\"center\">char name[20]</td>\n</tr>\n<tr>\n<td align=\"center\">等级</td>\n<td align=\"center\">int level</td>\n</tr>\n<tr>\n<td align=\"center\">血量</td>\n<td align=\"center\">int hp</td>\n</tr>\n<tr>\n<td align=\"center\">攻击力</td>\n<td align=\"center\">int attact</td>\n</tr>\n<tr>\n<td align=\"center\">防御力</td>\n<td align=\"center\">int defence</td>\n</tr>\n<tr>\n<td align=\"center\">掉落的最小金币</td>\n<td align=\"center\">int minMoney</td>\n</tr>\n<tr>\n<td align=\"center\">掉落的最大金币</td>\n<td align=\"center\">int maxMoney</td>\n</tr>\n<tr>\n<td align=\"center\">玩家能够获取的最大经验</td>\n<td align=\"center\">int exp</td>\n</tr>\n<tr>\n<td align=\"center\">怪物的状态(0死1活)</td>\n<td align=\"center\">int state</td>\n</tr>\n<tr>\n<td align=\"center\">怪物的坐标</td>\n<td align=\"center\">COORD coord</td>\n</tr>\n<tr>\n<td align=\"center\">***</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">## 功能实现</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p><strong>通过系统函数辅助实现的方法, 以下方法在GameLib源文件中</strong></p>\n<ol>\n<li>更改控制台标题(SetTitle)</li>\n<li>更改控制台内字体(SetColor)</li>\n<li>设置控制台内光标的位置(SetPosition)</li>\n</ol>\n<h3 id=\"更改控制台标题-SetTitle\"><a href=\"#更改控制台标题-SetTitle\" class=\"headerlink\" title=\"更改控制台标题(SetTitle)\"></a>更改控制台标题(SetTitle)</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 设置控制台的标题 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetTitle</span><span class=\"params\">(<span class=\"keyword\">char</span> *title)</span> </span>&#123;</span><br><span class=\"line\">    SetConsoleTitle(title);     <span class=\"comment\">//调用windows.h头文件下的系统函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改控制台内字体-SetColor\"><a href=\"#更改控制台内字体-SetColor\" class=\"headerlink\" title=\"更改控制台内字体(SetColor)\"></a>更改控制台内字体(SetColor)</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 设置控制台的颜色</span></span><br><span class=\"line\"><span class=\"comment\"> * 0-黑色,   1-蓝色,   2-绿色,    3-浅绿色,  4-红色,</span></span><br><span class=\"line\"><span class=\"comment\"> * 5-紫色,   6-黄色,   7-白色,    8-灰色,   9-淡蓝色,</span></span><br><span class=\"line\"><span class=\"comment\"> * 10-淡绿色,  11-淡浅绿色   12-淡红色   13-淡紫色</span></span><br><span class=\"line\"><span class=\"comment\"> * 14-淡黄色   15-亮白色</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetColor</span><span class=\"params\">(<span class=\"keyword\">int</span> ForeColor, <span class=\"keyword\">int</span> BackColor)</span> </span>&#123;<span class=\"comment\">//分别设置前景色与背景色</span></span><br><span class=\"line\">     <span class=\"comment\">//HANDLE: 句柄, GetStdHandle(STD_OUTPUT_HANDLE)获得标准输出流的句柄, 均为windows.h下的系统函数</span></span><br><span class=\"line\">     HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);       <span class=\"comment\">//获取当前窗口句柄</span></span><br><span class=\"line\">     SetConsoleTextAttribute(handle, ForeColor + BackColor * <span class=\"number\">0x10</span>);<span class=\"comment\">//设置颜色</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//句柄(HANDLE)补充:</span></span><br><span class=\"line\">    <span class=\"comment\">//WINDOWS程序中并不是用物理地址来标识一个内存块，文件，任务或动态装入模块的。</span></span><br><span class=\"line\">    <span class=\"comment\">//相反，WINDOWS API给这些项目分配确定的句柄并将句柄返回给应用程序，</span></span><br><span class=\"line\">    <span class=\"comment\">//然后通过句柄来进行操作(句柄不是指针, 是32或64位的无符号整型)</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设置控制台内光标的位置-SetPosition\"><a href=\"#设置控制台内光标的位置-SetPosition\" class=\"headerlink\" title=\"设置控制台内光标的位置(SetPosition)\"></a>设置控制台内光标的位置(SetPosition)</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetPosition</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">     HANDLE winHandle = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class=\"line\">     COORD pos = &#123;x, y&#125;;</span><br><span class=\"line\">     <span class=\"comment\">//SetConsoleCursorPosition()为windows.h下系统函数</span></span><br><span class=\"line\">     SetConsoleCursorPosition(winHandle, pos);      <span class=\"comment\">//设置光标位置</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>以下方法为自己定义实现游戏主要逻辑功能中比较重要的几个, 在Game源文件中</strong></p>\n<ol>\n<li><strong>GameProcess():</strong> 接收并判断用户的输入, 返回游戏的各个功能(例如用户输入方向键将会移动玩家的所在地图,输入1会显示玩家的个人信息窗口等等)这是游戏最重要的一个方法, 决定了游戏的逻辑实现, 本人水平较差, 当初没有想到将所有的操作均封装到此方法来, 因此使得判断用户输入包括方向键的接收为一个方法并且放入于main()中, 导致了维护困难, 代码不清晰等等问题 </li>\n<li><strong>Clear():</strong> 功能为清理指定区域内的所有字符, 用’\\0’替代, 达到刷新屏幕的功能, 由于清屏操作需要使用的次数极多因此封装成方法</li>\n<li><strong>ShowMonster():</strong> 该方法为显示当前地图所有怪物的信息: 等级名称, 但是我却在一个方法包含了接收用户输入导致方法过于复杂难以复用维护, 而且此方法打印怪物使用指针以及辅助数组较难理解</li>\n<li><strong>MonsterFight():</strong> 接收用户输入的怪物编号, 让玩家与怪物进行战斗, 以当前时间为种子, 攻击力防御力取范围该范围内的随机数, 战斗后返回判断打印不同情况的结果 </li>\n<li><strong>PropInit():</strong> 初始化游戏玩家数据, 用于测试功能 </li>\n<li><strong>Trade():</strong> 交易方法, 接收游戏玩家编号与商品编号, 重点为判断无法交易的情况以及对背包物品的添加(背包已有该类别商品/背包暂无此类别商品) </li>\n<li><strong>ShowProps():</strong> 显示商城的信息, 此方法与ShowMonster()类似,  同样我没考虑到方法的复用以及维护, 将Show 和 接收用户的输入 两个方法写在一个方法里了</li>\n<li><strong>showTrade():</strong> 接收Trade()返回的值, 对应交易成功与失败分别执行不同操作</li>\n<li><strong>Login():</strong> 登陆方法, 接收用户输入的用户名以及密码(无回显)进行判断以达到登陆功能</li>\n</ol>\n<h4 id=\"以下为主要方法的源代码\"><a href=\"#以下为主要方法的源代码\" class=\"headerlink\" title=\"以下为主要方法的源代码\"></a>以下为主要方法的源代码</h4><ul>\n<li><p>一些宏定义, 例如游戏窗口的各个部分的行数等等, 在移动光标时使用频率极高</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> COL 78                <span class=\"comment\">//游戏的界面的总宽度</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXGIN_X 20           <span class=\"comment\">//游戏界面与控制台的左边距</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ENDINFO 78            <span class=\"comment\">//各个框架结束'|'的列数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAPSART_START_Y 3     <span class=\"comment\">//游戏地图开始的行</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAPSART_END_Y 11      <span class=\"comment\">//游戏地图结束行</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INFORMATION_START_Y 12<span class=\"comment\">//游戏信息开始行</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INFORMATION_END_Y 19  <span class=\"comment\">//游戏信息结束行</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAINMENUE_START_Y 20  <span class=\"comment\">//游戏主菜单开始行</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAINMENUE_END_Y 28    <span class=\"comment\">//游戏主菜单结束行</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SEP <span class=\"meta-string\">\"*******************************************************************************\"</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>游戏主体的逻辑实现</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接收main()传递的<span class=\"built_in\">key</span>, 分别执行不同的功能</span><br><span class=\"line\"><span class=\"comment\">/** 执行游戏主菜单功能 */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> GameProcess(<span class=\"built_in\">char</span> <span class=\"built_in\">key</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"built_in\">key</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'1'</span>: ShowPlayerInfo();<span class=\"comment\">//显示玩家个人信息</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'2'</span>: ShowMonster();<span class=\"comment\">//显示当前地图的怪物(内有打怪)</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'3'</span>: Move(currPlayer-&gt;martial.hqCoord.X, currPlayer-&gt;martial.hqCoord.Y);<span class=\"comment\">//移动到玩家的帮派地图中</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'4'</span>: ShowProps();<span class=\"comment\">//展示游戏商品</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span> : printf(<span class=\"string\">\"少侠究竟想要作甚?\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">以下为游戏主逻辑, 死循环中对用户输入进行判断并对应相应的输出(即实现不同游戏功能)</span><br><span class=\"line\">****************************************************************************</span><br><span class=\"line\">main()包括了判断字符进行移动玩家所在地图的功能(未封装成方法!)</span><br><span class=\"line\">****************************************************************************</span><br><span class=\"line\"><span class=\"built_in\">int</span> main() &#123;<span class=\"comment\">//最好通过一个游戏进程函数将main方法里边的各种方法封装, 通过不同状态执行不同方法</span></span><br><span class=\"line\">    <span class=\"built_in\">char</span> <span class=\"built_in\">key</span>;           <span class=\"comment\">//接收用户输入</span></span><br><span class=\"line\">    SetColor(<span class=\"number\">2</span>,<span class=\"number\">0</span>);      <span class=\"comment\">//设置控制台文本颜色(front color为绿色, background color为黑色)</span></span><br><span class=\"line\">    SetConsoleTitle(<span class=\"string\">\"笑傲江湖之精忠报国 C语言实现 BY 左手工匠\"</span>);    <span class=\"comment\">//设置控制台标题</span></span><br><span class=\"line\">    PropInit();         <span class=\"comment\">//初始化测试人物</span></span><br><span class=\"line\">    ShowWelcome();      <span class=\"comment\">//显示欢迎栏</span></span><br><span class=\"line\">    Login();            <span class=\"comment\">//登陆, 登陆成功继续执行</span></span><br><span class=\"line\">    ShowMap();          <span class=\"comment\">//显示地图</span></span><br><span class=\"line\">    ShowInformation();  <span class=\"comment\">//显示信息栏</span></span><br><span class=\"line\">    ShowMainMenu();     <span class=\"comment\">//显示菜单栏</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;<span class=\"comment\">//死循环, 除非用户选择退出, 否则停止等待用户输入</span></span><br><span class=\"line\">    fflush(stdin);</span><br><span class=\"line\">    <span class=\"comment\">//接收用户输入(无回显)</span></span><br><span class=\"line\">    <span class=\"built_in\">key</span> = getch();</span><br><span class=\"line\">    fflush(stdin);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == <span class=\"string\">'1'</span> || <span class=\"built_in\">key</span> == <span class=\"string\">'2'</span> || <span class=\"built_in\">key</span> == <span class=\"string\">'3'</span> || <span class=\"built_in\">key</span> == <span class=\"string\">'4'</span>)&#123;</span><br><span class=\"line\">        GameProcess(<span class=\"built_in\">key</span>);<span class=\"comment\">//输入正常, 将值传递给GameProcess()来对应输出</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == <span class=\"string\">'5'</span> || <span class=\"built_in\">key</span> == <span class=\"string\">'6'</span> )&#123;</span><br><span class=\"line\">        SetPosition(<span class=\"number\">20</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">        Clear(<span class=\"number\">20</span> , <span class=\"number\">12</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">        SetPosition(<span class=\"number\">20</span> + <span class=\"number\">5</span>, <span class=\"number\">12</span> + <span class=\"number\">2</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"放过我吧, 还没开发完呐!!!\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == <span class=\"string\">'7'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == VK_UP || <span class=\"built_in\">key</span> == <span class=\"number\">72</span>) &#123;<span class=\"comment\">//X, Y为游戏坐标, 控制X, YS实现地图移动</span></span><br><span class=\"line\">        Y--;            <span class=\"comment\">//输入上</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == VK_RIGHT || <span class=\"built_in\">key</span> == <span class=\"number\">77</span>) &#123;</span><br><span class=\"line\">        X++;            <span class=\"comment\">//输入右</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == VK_DOWN || <span class=\"built_in\">key</span> == <span class=\"number\">80</span>) &#123;</span><br><span class=\"line\">        Y++;            <span class=\"comment\">//输入下</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> == VK_LEFT || <span class=\"built_in\">key</span> == <span class=\"number\">75</span>) &#123;</span><br><span class=\"line\">        X--;            <span class=\"comment\">//输入左</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(X &gt; <span class=\"number\">7</span>) &#123;<span class=\"comment\">//移动到最边的话重新回到0, 如贪食蛇穿过地图边缘</span></span><br><span class=\"line\">        X = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(X &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        X = <span class=\"number\">7</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Y &gt; <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">        Y = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Y &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Y = <span class=\"number\">7</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ShowMap();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>清空指定区域内所有字符 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 清除信息区内所有内容(给定坐标及清理的行数) */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Clear</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> rowCount)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rowCount; i ++) &#123;</span><br><span class=\"line\">        SetPosition(x + <span class=\"number\">1</span>, y + i);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; COL - <span class=\"number\">1</span>; j ++)  &#123;    <span class=\"comment\">//使用' '替换指定区域</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打印怪物的信息以及接收并判断玩家的输入的怪物编号, 玩家选择查看怪物信息时调用该方法</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 显示当前地图的怪物********(功能略复杂些)*************/</span></span><br><span class=\"line\">void ShowMonster() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//给怪物各个等级对应相应称号</span></span><br><span class=\"line\">    <span class=\"comment\">//例如：3级怪物，那么就显示这个怪物的描述为粗通皮毛</span></span><br><span class=\"line\">    char *monsterlevelNames[] = &#123;<span class=\"string\">\"乳臭未干\"</span>, <span class=\"string\">\"初出茅庐\"</span>, <span class=\"string\">\"粗通皮毛\"</span>, <span class=\"string\">\"青年才俊\"</span>, <span class=\"string\">\"略有小成\"</span>, <span class=\"string\">\"心领神会\"</span>, <span class=\"string\">\"出类拔萃\"</span>, <span class=\"string\">\"所向无敌\"</span>, <span class=\"string\">\"天人合一\"</span>&#125;;</span><br><span class=\"line\">    Clear(MAXGIN_X,  INFORMATION_START_Y, <span class=\"number\">7</span>);   <span class=\"comment\">//清空信息区的所有内容</span></span><br><span class=\"line\">    int monsterCount;</span><br><span class=\"line\">    <span class=\"comment\">// 记录整个游戏的怪物总数</span></span><br><span class=\"line\">    monsterCount = sizeof(monsterArray) / sizeof(Monster);</span><br><span class=\"line\">    <span class=\"comment\">//记录当前地图的怪数量 记得变量定义时赋初值!!! debug了好久...</span></span><br><span class=\"line\">    int currMapMonsterCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个只有九个空间的一维数组, 用以记录怪物在怪物列表里的下标</span></span><br><span class=\"line\">    int monsterIndex[<span class=\"number\">9</span>];</span><br><span class=\"line\">    for(int i = <span class=\"number\">0</span>; i &lt; monsterCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 关键!!! 满足怪物坐标与当前地图坐标相等 并且 该怪物的状态为存活的条件, 将怪物与怪物数组的下标记录并且当前地图怪物数量自增</span></span><br><span class=\"line\">        if(monsterArray[i].coord.X == X &amp;&amp; monsterArray[i].coord.Y == Y &amp;&amp; monsterArray[i].<span class=\"section\">state</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 记录下标</span></span><br><span class=\"line\">            monsterIndex[currMapMonsterCount] = i;</span><br><span class=\"line\">            currMapMonsterCount++;</span><br><span class=\"line\">            <span class=\"comment\">// 设定每个地图最多显示 9 个怪物</span></span><br><span class=\"line\">            if(currMapMonsterCount == <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打印怪物</span></span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">1</span>);</span><br><span class=\"line\">    if(currMapMonsterCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        SetColor(<span class=\"number\">7</span>, <span class=\"number\">0</span>);<span class=\"comment\">//白字黑底</span></span><br><span class=\"line\">        printf(<span class=\"string\">\"这里冷冷清清的什么也没有, 少侠还是到别处看看吧, 呆着也没银子给你!\"</span>);</span><br><span class=\"line\">        SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);<span class=\"comment\">//恢复颜色</span></span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*********以下语句为判定用户输入的编号来返回地图信息或进行打怪操作*******/</span></span><br><span class=\"line\">    int pkMonsterId = <span class=\"number\">0</span>;<span class=\"comment\">// 接收玩家输入的怪物编号, 定义在循环外部是因为循环外仍需使用进行判断是否打印地图信息</span></span><br><span class=\"line\">    while(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        pkMonsterId = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        Clear(MAXGIN_X,  INFORMATION_START_Y, <span class=\"number\">7</span>);   <span class=\"comment\">//清空信息区的所有内容</span></span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">20</span>, INFORMATION_START_Y + <span class=\"number\">0</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"少侠, 这儿有怪物! 要为百姓除暴安良吗?\"</span> );</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">2</span>);</span><br><span class=\"line\">        for(int i = <span class=\"number\">0</span>; i &lt; currMapMonsterCount; i++) &#123;</span><br><span class=\"line\">            if(i % <span class=\"number\">3</span> == <span class=\"number\">0</span> &amp;&amp; i != <span class=\"number\">0</span>)&#123;<span class=\"comment\">//每行打印三个怪物</span></span><br><span class=\"line\">                SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">2</span> + i / <span class=\"number\">3</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//打印怪物, 较为繁琐</span></span><br><span class=\"line\">            <span class=\"comment\">//monsterIndex[i]即为该怪物列表中的怪物编号</span></span><br><span class=\"line\">            SetColor(<span class=\"number\">4</span>, <span class=\"number\">0</span>);<span class=\"comment\">//红字怪物</span></span><br><span class=\"line\">            printf(<span class=\"string\">\"%d.%s(%s)<span class=\"subst\">\\t</span>  \"</span>, i + <span class=\"number\">1</span>, monsterArray[monsterIndex[i]].name, monsterlevelNames[monsterArray[monsterIndex[i]].level - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);<span class=\"comment\">//恢复颜色</span></span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"少侠想攻击几号怪物呢? (按0返回)\"</span>);</span><br><span class=\"line\">        scanf(<span class=\"string\">\"%d\"</span>, &amp;pkMonsterId);</span><br><span class=\"line\">        if(pkMonsterId == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//输入0, 退出循环来返回显示地图信息</span></span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if(pkMonsterId &lt; <span class=\"number\">0</span> || pkMonsterId &gt; currMapMonsterCount) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//输入的怪物标号在当前地图不存在</span></span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">//简易清屏</span></span><br><span class=\"line\">            printf(<span class=\"string\">\"                                                             \"</span>);</span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">            printf(<span class=\"string\">\"少侠选错了吧, 怪物不存在呢!(按任意键重新输入)\"</span>);</span><br><span class=\"line\">            char recoverKey = getch();</span><br><span class=\"line\">            if(recoverKey)&#123;<span class=\"comment\">//停顿直到接收任意键后重新显示怪物</span></span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;<span class=\"comment\">//编号对应地图所有的怪物时, 将怪物地址传入打怪方法</span></span><br><span class=\"line\">            MonsterFight(&amp;monsterArray[monsterIndex[pkMonsterId - <span class=\"number\">1</span>]]);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(pkMonsterId == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//输入0, 返回显示地图信息</span></span><br><span class=\"line\">        ShowMapInfo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>玩家与指定地图指定怪兽进行战斗</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 选定怪物进行对战 */</span></span><br><span class=\"line\">void MonsterFight(Monster *monster) &#123;</span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    printf(<span class=\"string\">\"                                                             \"</span>);<span class=\"comment\">//简易清屏(偷懒)</span></span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    srand(<span class=\"built_in\">time</span>(NULL));<span class=\"comment\">//以当前时间为种子</span></span><br><span class=\"line\">    <span class=\"comment\">/* random函数的用法(只能0 - 32767之间)</span></span><br><span class=\"line\"><span class=\"comment\">    * 随机一个a ~ b的数字, 即 rand() % (b - a + 1) + a; 例如0 ~ 5, 即rand() % 6;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    int playerAttact = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 玩家的实际攻击力</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">playerAttact</span> = rand() % (currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">weapon</span>.maxAttack - currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">weapon</span>.minAttack + 1) + currPlayer-&gt;</span>weapon.minAttack;</span><br><span class=\"line\">    int playerDeffence =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//玩家实际防御力</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">playerDeffence</span> = rand() % (currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">armor</span>.maxDefence - currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">armor</span>.minDefence + 1) + currPlayer-&gt;</span>armor.minDefence;</span><br><span class=\"line\">    <span class=\"comment\">//怪物实际掉落的金钱</span></span><br><span class=\"line\">    int monsterGold = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">monsterGold</span> = rand() % (monster-&gt;</span><span class=\"function\"><span class=\"title\">maxMoney</span> - monster-&gt;</span><span class=\"function\"><span class=\"title\">minMoney</span> + 1) + monster-&gt;</span>minMoney;</span><br><span class=\"line\">    int pkRound = <span class=\"number\">0</span>;    <span class=\"comment\">//记录战斗的轮次</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;<span class=\"comment\">//打斗循环, 任意一方死亡退出</span></span><br><span class=\"line\">        <span class=\"comment\">//玩家血量变化</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span><span class=\"function\"><span class=\"title\">hp</span> -= monster-&gt;</span>attact - playerDeffence;</span><br><span class=\"line\">        <span class=\"comment\">//怪物的血量变化</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">monster</span>-&gt;</span><span class=\"function\"><span class=\"title\">hp</span> -= playerAttact - monster-&gt;</span>defence;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">if</span>(monster-&gt;</span>hp &lt;= <span class=\"number\">0</span>) &#123;<span class=\"comment\">//怪物的血量少于等于0时退出</span></span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">if</span>(currPlayer-&gt;</span>hp &lt;= <span class=\"number\">0</span>) &#123;<span class=\"comment\">//玩家血量小于等于0时退出</span></span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//以下为打印战斗详情</span></span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"                                                                         \"</span>);<span class=\"comment\">//简易清屏(偷懒)</span></span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        pkRound++;</span><br><span class=\"line\">        <span class=\"comment\">//战斗详情使用白底红字</span></span><br><span class=\"line\">        SetColor(<span class=\"number\">4</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\">        <span class=\"comment\">//该语句较长......</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">printf</span>(\"第 %d 轮战斗详情:%s 对 %s 造成了 %d 伤害且受到 %s %d 的伤害\", pkRound, currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">name</span>, monster-&gt;</span><span class=\"function\"><span class=\"title\">name</span>, playerAttact - monster-&gt;</span><span class=\"function\"><span class=\"title\">defence</span>, monster-&gt;</span><span class=\"function\"><span class=\"title\">name</span>, monster-&gt;</span>attact - playerDeffence);</span><br><span class=\"line\">        <span class=\"comment\">//放慢过程</span></span><br><span class=\"line\">        usleep(<span class=\"number\">1000</span> * <span class=\"number\">800</span>);<span class=\"comment\">//1000毫秒*800</span></span><br><span class=\"line\">        SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    printf(<span class=\"string\">\"                                                                   \"</span>);<span class=\"comment\">//简易清屏(偷懒)</span></span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span>(currPlayer-&gt;</span>hp &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//玩家死亡输入完任意键后返回</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">printf</span>(\"江湖快讯: 大侠 %s 在与 %s 的对决中壮烈牺牲! (请按任意键返回)\", currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">name</span>, monster-&gt;</span><span class=\"keyword\">name</span>);</span><br><span class=\"line\">        <span class=\"comment\">//重置人物的金币与血量</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>hp = <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>gold = <span class=\"number\">100</span>;</span><br><span class=\"line\">        getch();</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//以下即为怪物死亡的情况</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">printf</span>(\"%s 轻而易举的便被 %s 大侠收拾了, 同时掉落了 \", monster-&gt;</span><span class=\"function\"><span class=\"title\">name</span>, currPlayer-&gt;</span><span class=\"keyword\">name</span>);</span><br><span class=\"line\">    <span class=\"comment\">//将怪物的状态调整至死亡</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">monster</span>-&gt;</span>state = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//设置金币的front color为黄色, background color为亮白色</span></span><br><span class=\"line\">    SetColor(<span class=\"number\">6</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">    printf(<span class=\"string\">\"%d 金币   \"</span>, monsterGold);</span><br><span class=\"line\">    <span class=\"comment\">// 设置经验的front color为黄色, background color为亮白色</span></span><br><span class=\"line\">    SetColor(<span class=\"number\">1</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">printf</span>(\"%d 经验  \", monster-&gt;</span><span class=\"built_in\">exp</span>);</span><br><span class=\"line\">    SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>); <span class=\"comment\">//颜色恢复</span></span><br><span class=\"line\">    <span class=\"comment\">//玩家获得金币与经验值的加成</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>gold += monsterGold;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span><span class=\"function\"><span class=\"title\">exp</span> += monster-&gt;</span><span class=\"built_in\">exp</span>;</span><br><span class=\"line\">    getch();</span><br><span class=\"line\">    ShowMonster();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>初始化游戏数据: 将地图, 玩家, 装备, 怪物置入, 测试各功能</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Player *currPlayer;</span><br><span class=\"line\">void PropInit() &#123;<span class=\"comment\">//初始化游戏数据 (测试用数据)</span></span><br><span class=\"line\">    currPlayer = &amp;playArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>weapon = propArray[<span class=\"number\">8</span>];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>armor = propArray[<span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>martial = martials[<span class=\"number\">4</span>];</span><br><span class=\"line\">    Bag bag = &#123;<span class=\"number\">95001</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>bag = bag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>交易, 玩家购买指定道具</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 交易</span></span><br><span class=\"line\"><span class=\"comment\">  * 参数1: 玩家的地址</span></span><br><span class=\"line\"><span class=\"comment\">  * 参数2: 商品的编号</span></span><br><span class=\"line\"><span class=\"comment\">  * 返回交易是否成功, 0 失败, 1 成功</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">int Trade(Player *player, int propsId) &#123;</span><br><span class=\"line\">    Prop *tradeProp = NULL;     <span class=\"comment\">//定义一个用于指向及交易商品的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(int i = <span class=\"number\">0</span>; i &lt; sizeof(propArray) / sizeof(Prop); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(propsId == propArray[i].id) &#123;<span class=\"comment\">//找到该商品, 并让tradeProp指向它</span></span><br><span class=\"line\">            tradeProp = propArray + i;  <span class=\"comment\">//即tradeProp = &amp;propArray[i]</span></span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断商品是否有库存</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span>(tradeProp-&gt;</span>stock &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Clear(MAXGIN_X, INFORMATION_END_Y - <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"地主家都没有余粮！商店都被买空啦！\"</span>);</span><br><span class=\"line\">        return <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断玩家是否金币足够支付</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span>(currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">gold</span> &lt; tradeProp-&gt;</span>price) &#123;</span><br><span class=\"line\">        Clear(MAXGIN_X, INFORMATION_END_Y - <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"钱包都是瘪的，这可是个看钱的江湖！！!\"</span>);</span><br><span class=\"line\">        return <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断玩家背包容量是否充足</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span>(currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.propsCount &gt; currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.maxCount &amp;&amp; currPlayer-&gt;</span>bag.propsCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//玩家的背包道具数量大于最大容量并且背包道具数不为0则判定为失败</span></span><br><span class=\"line\">        Clear(MAXGIN_X, INFORMATION_END_Y - <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"背包已满，交易失败！\"</span>);</span><br><span class=\"line\">        return <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//满足交易条件，执行交易的业务操作</span></span><br><span class=\"line\">    <span class=\"comment\">//1、商品库存-1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">tradeProp</span>-&gt;</span>stock--;</span><br><span class=\"line\">    <span class=\"comment\">//2、玩家金币-商品单价</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">player</span>-&gt;</span><span class=\"function\"><span class=\"title\">gold</span> -= tradeProp-&gt;</span>price;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//*****************************玩家背包道具增加*******************************//</span></span><br><span class=\"line\">    <span class=\"comment\">//判断玩家背包中是否已有该商品 !!!</span></span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">for</span>(i = 0; i &lt; currPlayer-&gt;</span>bag.propsCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">if</span>(propsId == currPlayer-&gt;</span>bag.props[i].id) &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>bag.props[i].stock++;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//若为循环正常结束, i = currPlayer-&gt;bag.propsCount, 即为背包无此商品, 需要给背包添加该商品!!!</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span>(i == currPlayer-&gt;</span>bag.propsCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//向背包中创建一个商品-复制一份要交易的商品信息到背包中</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.props[currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.propsCount].id = tradeProp-&gt;</span>id;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.props[currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.propsCount].price = tradeProp-&gt;</span>price;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.props[currPlayer-&gt;</span>bag.propsCount].stock = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">strcpy</span>(currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.props[currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.propsCount].<span class=\"keyword\">name</span>, tradeProp-&gt;</span><span class=\"keyword\">name</span>);</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">strcpy</span>(currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.props[currPlayer-&gt;</span><span class=\"function\"><span class=\"title\">bag</span>.propsCount].desc, tradeProp-&gt;</span>desc);</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">currPlayer</span>-&gt;</span>bag.propsCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//交易成功</span></span><br><span class=\"line\">    return <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>打印商品列表, 玩家选择购买道具调用该方法</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 展示游戏商品 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ShowProps</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//此方法应拆分为打印商品 以及用户输入并检验商品编号两个方法!!!!!!!!</span></span><br><span class=\"line\">    <span class=\"comment\">/*******************************/</span></span><br><span class=\"line\">    Clear(MAXGIN_X, INFORMATION_START_Y, <span class=\"number\">7</span>);</span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y);</span><br><span class=\"line\">    SetColor(<span class=\"number\">8</span>, <span class=\"number\">0</span>);     <span class=\"comment\">//灰字黑底</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"欢迎大侠 %s 来到 %s 童叟无欺的杂货铺, 瞧一瞧看一看可有需要的?\"</span>, currPlayer-&gt;name, mapArray[X][Y].name);</span><br><span class=\"line\">    SetColor(<span class=\"number\">6</span>, <span class=\"number\">0</span>);     <span class=\"comment\">//黄字黑底</span></span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> propCount = <span class=\"keyword\">sizeof</span>(propArray) / <span class=\"keyword\">sizeof</span>(Prop) &gt;= <span class=\"number\">9</span> ? <span class=\"number\">9</span> : <span class=\"keyword\">sizeof</span>(propArray) / <span class=\"keyword\">sizeof</span>(Prop);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; propCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i % <span class=\"number\">3</span> == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//打印商品, 每行 3 个, 且只打印最多 9 个</span></span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">2</span> + i / <span class=\"number\">3</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%-3d.%-10s(%-2d)%-4c\"</span>, propArray[i].id, propArray[i].name, propArray[i].stock, <span class=\"string\">' '</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);<span class=\"comment\">//恢复颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tradeId;<span class=\"comment\">//接收用户输入的商品编号</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于判断输入编号是否正确(此判断未包括检验玩家金币及商品库存及玩家背包是否已满等状态)</span></span><br><span class=\"line\">        Clear(MAXGIN_X, INFORMATION_END_Y - <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"大侠需要什么, 请输入编号立即购买(按 0 退出)\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;tradeId);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tradeId == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//输入0返回显示地图信息</span></span><br><span class=\"line\">            ShowMapInfo();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tradeId &lt; <span class=\"number\">0</span> || tradeId &gt; <span class=\"number\">9</span>) &#123;<span class=\"comment\">//输入的商品编号错误的情况, 重新输入</span></span><br><span class=\"line\">            Clear(MAXGIN_X, INFORMATION_END_Y - <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"少侠选错了吧, 商品不存在呢!(按任意键重新输入)\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">char</span> recoverKey = getch();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(recoverKey)&#123;<span class=\"comment\">//停顿直到接收任意键后重新显示怪物</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//输入在1 - 9的情况, 将编号传入交易函数</span></span><br><span class=\"line\">            showTrade(Trade(currPlayer, tradeId), tradeId);<span class=\"comment\">//******调用交易方法, 展示交易信息方法******//</span></span><br><span class=\"line\">            <span class=\"comment\">//以下为重新刷新商品列表, 应该封装为一个打印商品的方法, 该ShowProps()方法过于繁琐, 加入了打印以及检验两个功能</span></span><br><span class=\"line\">            <span class=\"comment\">/********************************/</span></span><br><span class=\"line\">            Clear(MAXGIN_X, INFORMATION_START_Y, <span class=\"number\">7</span>);</span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y);</span><br><span class=\"line\">            SetColor(<span class=\"number\">8</span>, <span class=\"number\">0</span>);     <span class=\"comment\">//灰字黑底</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"欢迎大侠 %s 来到 %s 童叟无欺的杂货铺, 瞧一瞧看一看可有需要的?\"</span>, currPlayer-&gt;name, mapArray[X][Y].name);</span><br><span class=\"line\">            SetColor(<span class=\"number\">6</span>, <span class=\"number\">0</span>);     <span class=\"comment\">//黄字黑底</span></span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> propCount = <span class=\"keyword\">sizeof</span>(propArray) / <span class=\"keyword\">sizeof</span>(Prop) &gt;= <span class=\"number\">9</span> ? <span class=\"number\">9</span> : <span class=\"keyword\">sizeof</span>(propArray) / <span class=\"keyword\">sizeof</span>(Prop);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; propCount; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i % <span class=\"number\">3</span> == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//打印商品, 每行 3 个, 且只打印最多 9 个</span></span><br><span class=\"line\">                    SetPosition(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_START_Y + <span class=\"number\">2</span> + i / <span class=\"number\">3</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%-3d.%-10s(%-2d)%-4c\"</span>, propArray[i].id, propArray[i].name, propArray[i].stock, <span class=\"string\">' '</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);<span class=\"comment\">//恢复颜色</span></span><br><span class=\"line\">            <span class=\"comment\">/********************************/</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回交易结束后的信息</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 接收Trade()返回的值, 判断交易是否成功 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">void</span> <span class=\"selector-tag\">showTrade</span>(int flag, int propId) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span>(flag == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">ShowMapInfo</span>();</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span>(flag == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">Clear</span>(MAXGIN_X, INFORMATION_END_Y - <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"selector-tag\">SetPosition</span>(MAXGIN_X + <span class=\"number\">5</span>, INFORMATION_END_Y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"selector-tag\">printf</span>(<span class=\"string\">\"交易成功, \"</span>);</span><br><span class=\"line\">        <span class=\"selector-tag\">SetColor</span>(<span class=\"number\">6</span>, <span class=\"number\">0</span>);     <span class=\"comment\">//打印装备为黑底黄字</span></span><br><span class=\"line\">        <span class=\"selector-tag\">printf</span>(<span class=\"string\">\"%s\"</span>, propArray[propId - <span class=\"number\">1</span>].name);</span><br><span class=\"line\">        <span class=\"selector-tag\">SetColor</span>(<span class=\"number\">2</span>, <span class=\"number\">0</span>);     <span class=\"comment\">//恢复黑底绿字</span></span><br><span class=\"line\">        <span class=\"selector-tag\">printf</span>(<span class=\"string\">\" 已经加入你的背包, 赶紧瞧一瞧吧!(按任意键继续)\"</span>);</span><br><span class=\"line\">        <span class=\"selector-tag\">getch</span>();            <span class=\"comment\">//暂停</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>验证登陆信息</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 玩家登陆(暂无注册) */</span></span><br><span class=\"line\">void Login() &#123;</span><br><span class=\"line\">    while(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        char id[<span class=\"number\">10</span>];</span><br><span class=\"line\">        char <span class=\"type\">key</span>[<span class=\"number\">10</span>];       <span class=\"comment\">//接收用户输入的id 和 passwd</span></span><br><span class=\"line\">        SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        Clear(MAXGIN_X, MAPSART_START_Y, <span class=\"number\">4</span>);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">24</span>, MAPSART_START_Y);</span><br><span class=\"line\">        printf(<span class=\"string\">\"请在下方输入您的用户名和密码\"</span>);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, MAPSART_START_Y + <span class=\"number\">1</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"用户名: \"</span>);</span><br><span class=\"line\">        scanf(<span class=\"string\">\"%s\"</span>, id);</span><br><span class=\"line\">        SetPosition(MAXGIN_X + <span class=\"number\">5</span>, MAPSART_START_Y  + <span class=\"number\">2</span>);</span><br><span class=\"line\">        printf(<span class=\"string\">\"密码(无回显哦回车确定): \"</span>);</span><br><span class=\"line\">        for(int i = <span class=\"number\">0</span>; <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">key</span>[i] = getch();<span class=\"comment\">//无回显输入密码</span></span><br><span class=\"line\">            if(<span class=\"type\">key</span>[i] == <span class=\"number\">13</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//接收到回车跳出循环</span></span><br><span class=\"line\">                <span class=\"comment\">//将回车字符重置为空字符</span></span><br><span class=\"line\">                <span class=\"type\">key</span>[i] = '\\<span class=\"number\">0</span>';</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断玩家输入的信息是否与玩家id, passwd匹配</span></span><br><span class=\"line\">        if(strcmp(currPlayer-&gt;id, id) == <span class=\"number\">0</span> &amp;&amp; strcmp(currPlayer-&gt;passwd, <span class=\"type\">key</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//只有玩家输入成功才跳出死循环</span></span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            SetPosition(MAXGIN_X + <span class=\"number\">5</span>, MAPSART_START_Y + <span class=\"number\">3</span>);</span><br><span class=\"line\">            SetColor(<span class=\"number\">12</span>, <span class=\"number\">0</span>);    <span class=\"comment\">//浅红色字体</span></span><br><span class=\"line\">            printf(<span class=\"string\">\"用户名或密码错误, 请检查后再次输入!(按任意键继续)\"</span>);</span><br><span class=\"line\">            getch();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//用户输入成功后</span></span><br><span class=\"line\">    SetColor(<span class=\"number\">12</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    SetPosition(MAXGIN_X, MAPSART_START_Y);</span><br><span class=\"line\">    Clear(MAXGIN_X, MAPSART_START_Y, <span class=\"number\">4</span>);</span><br><span class=\"line\">    SetPosition(MAXGIN_X + <span class=\"number\">15</span>, MAPSART_START_Y);</span><br><span class=\"line\">    printf(<span class=\"string\">\"欢迎 \"</span>);</span><br><span class=\"line\">    SetColor(<span class=\"number\">1</span>, <span class=\"number\">0</span>);      <span class=\"comment\">//蓝字显示玩家name</span></span><br><span class=\"line\">    printf(<span class=\"string\">\"%s\"</span>, currPlayer-&gt;name);</span><br><span class=\"line\">    SetColor(<span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    printf(<span class=\"string\">\" 成功登陆笑傲江湖的世界(按任意键继续)\"</span>);</span><br><span class=\"line\">    getch();    <span class=\"comment\">//暂停</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"拓展功能\"><a href=\"#拓展功能\" class=\"headerlink\" title=\"拓展功能\"></a>拓展功能</h2><p>以下的功能为此DEMO适合拓展的有趣功能:</p>\n<ul>\n<li>玩家的背包容量: 初始设定只有9, 可以通过充值元宝等方式扩充背包最大容量</li>\n<li>注册功能, 玩家设定任意符合指定规则的用户名及密码, 并且在下次可以继续使用</li>\n<li>NPC, 逻辑与怪物相似, 地图随机刷新NPC并且贩卖普通商店没有的道具</li>\n<li>打斗过程加入回复, 增益等功能(打斗前使用消耗品提升属性, 打斗过程回复血量, 内力)</li>\n<li>怪物指定时间刷新</li>\n<li>连接网络, 满足两个玩家在同一张地图进行, 怪物道具资源同步刷新, 并且玩家可以决斗(遥远的目标啊)</li>\n</ul>\n<h2 id=\"最后的吐槽\"><a href=\"#最后的吐槽\" class=\"headerlink\" title=\"最后的吐槽\"></a>最后的吐槽</h2><p>先说说为什么要写这个极小极小的DEMO吧, 寒假前半段在学数据结构, 时间较短, 仅仅实现了顺序表, 单链表, 循环链表等几个简单的数据结构的定义以及实现, 过程不算太美好: 虽然大二上讲过数据结构与算法, 但是非常的粗略, 对数据结构与算法的理解仅仅为有那么几种表, 有那么几种排序方式, 而且C是大一上学的, 早已忘得一干二净, 很多语法尤其是之前就不过关的指针的不熟悉, 应验了那句: 当C的指针指向你的时候, 菜鸡原形毕露! 被头指针头结点折腾的头皮发麻, 尽管磕磕绊绊用代码实现了, 但我深刻感受到了效率的低下, 进度十分缓慢, 遂觉得应该恶补以下C, 于是有了以上的DEMO</p>\n<p>前前后后一共花了十天, 四天的时间都是疯狂刷视频, 把指针, 结构体, 字符串, 数组这四个章节重点看了一到两遍, 然后六天把这个DEMO完成了, 跟着老九的视频, 每天看完示范再理解完敲代码实现, 慢慢的也完成了, 自己也没想到可以写出1000行的东西(可能是我注释比较多吧捂脸), 过程最难过的不是理解也不是一行一行敲出一个功能, 而是无穷无尽的BUG, 早期是用Clion + Cmake的环境, 第二天开始实现游戏的界面栏目并且改变控制台标题栏以及字体颜色时, 因为要在控制台检验, 但是发现Clion + Cmake不能调出Windows的Console, 一顿查阅亦未果, 因此使用了最早使用的Codeblocks(还是这个简单多了…), 嫌弃Cb丑陋UI的我又入坑了Atom, 用Atom码代码, Cb编译…..十分的奇葩, 但是也算是完成了</p>\n<p>总体来讲, 对我感触最深的东西应该就是封装以及设计了, 这次的初版的DEMO我总体时非常不满意的, 糟糕的代码, 凌乱的代码, 混乱的设计, 可能源于我过于追求速度, 也许我做出了和视频效果相似甚至更加花里胡哨的打印结果, 但是里面的东西差距时非常遥远的, 空有其表, 败絮其中. 这种代码在日后非常难以维护, 即使我加了非常多的代码, 缩进也尽量按照标准来, 但是我自己都很难找到一个方法在哪里, 非常难以修改, 修改了一个方法可能需要同时修改其他的很多地方, 或者是修改完出现各种各样的内存问题等等…我现在认为一个方法仅仅对于一个功能是非常重要的, 而且便于记忆以及修改的宏定义我也尝到了它的甜头, 还有对整体程序的逻辑设计, 在不考虑这些东西而仅仅根据几条需求如同大一考试对于问题对于解出来就完事儿了的态度去码代码, 码出来的程序可能是正常运行的, 但是接下来的维护呢, 况且随心所欲的写方法我现在感觉是非常可怕的, 乱码一时爽, 码完以后火葬场, 每次DEBUG的时间都与真实写代码的时间一样长了, 每次改完以后心里憔悴, 这都是不好好规划设计, 拿起手就是敲的后果, 正所谓: 代码千万条, 规范第一条, 代码不规范, 亲人两行泪!写完这个DEMO也让我更加深入理解了一些数据结构, 如同此DEMO中的玩家结构, 玩家中有背包, 背包中有道具, 道具中有类别对应不同属性, 武器对应攻击力, 防具对应防御力等等, 现在我可能会思考, 需要经常插入而又很少需要随机读取的类型会不使用链表更加好一些等等的问题, 看来这波不亏</p>\n<p>最后, 可能我不会再继续修改这个DEMO了, 要么也是重写了(实在太烂了…) 感谢这个DEMO, 感谢老九, 用这样一种方式让我认识到了上课所无法理解的思想, 让我对未来的代码有了期待, 但是这只是一个极小的开始, 这只是站在了一个小石子儿看世界, 要想看到真正的世界, 还需走的更远, 爬到更高的地方去眺望, 去欣赏, 去体味)</p>\n</h1></h1>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck5dbbihd000asmjbzofng2om","category_id":"ck5dbbih90006smjbg7mt3dyj","_id":"ck5dbbihi000gsmjbu7pctz1y"},{"post_id":"ck5dbbih40002smjb1ucyiiq4","category_id":"ck5dbbih90006smjbg7mt3dyj","_id":"ck5dbbihj000lsmjbbwazodj2"},{"post_id":"ck5dbbihe000bsmjbyn22w62w","category_id":"ck5dbbih90006smjbg7mt3dyj","_id":"ck5dbbihk000osmjblf28e9r9"},{"post_id":"ck5dbbihg000esmjblpy5gh32","category_id":"ck5dbbih90006smjbg7mt3dyj","_id":"ck5dbbihl000ssmjbvadi4shv"},{"post_id":"ck5dbbih70004smjbo7o7hjmm","category_id":"ck5dbbih90006smjbg7mt3dyj","_id":"ck5dbbihm000vsmjb5esf5d3l"},{"post_id":"ck5dbbihh000fsmjb484v4xj0","category_id":"ck5dbbih90006smjbg7mt3dyj","_id":"ck5dbbiho000zsmjb9055ewrq"},{"post_id":"ck5dbbihj000ksmjb45lu6g5b","category_id":"ck5dbbih90006smjbg7mt3dyj","_id":"ck5dbbiho0012smjbv9pzp3jp"},{"post_id":"ck5dbbihb0008smjbhi1uuce4","category_id":"ck5dbbih90006smjbg7mt3dyj","_id":"ck5dbbihq0017smjb11h8bypm"},{"post_id":"ck5dbbihk000nsmjbbe6g226y","category_id":"ck5dbbih90006smjbg7mt3dyj","_id":"ck5dbbihr0019smjbw7ahhysm"},{"post_id":"ck5dbbiho0011smjbs01d1lxc","category_id":"ck5dbbihn000xsmjb834n7ajp","_id":"ck5dbbihs001dsmjbtih3vnre"},{"post_id":"ck5dbbihl000rsmjbxart2uxt","category_id":"ck5dbbihn000xsmjb834n7ajp","_id":"ck5dbbiht001gsmjbeim0auzl"},{"post_id":"ck5dbbihp0015smjb8ey7co8j","category_id":"ck5dbbihn000xsmjb834n7ajp","_id":"ck5dbbihu001ksmjb9nnfupu0"},{"post_id":"ck5dbbihq0018smjbwuz1cbpe","category_id":"ck5dbbihn000xsmjb834n7ajp","_id":"ck5dbbihv001nsmjbk43smrpg"},{"post_id":"ck5dbbihm000usmjbgnblt3yg","category_id":"ck5dbbihn000xsmjb834n7ajp","_id":"ck5dbbihx001rsmjb3j5vamje"},{"post_id":"ck5dbbihr001bsmjbyed83rze","category_id":"ck5dbbihn000xsmjb834n7ajp","_id":"ck5dbbihy001vsmjb9gunvq2x"},{"post_id":"ck5dbbihs001fsmjbssyd9dpi","category_id":"ck5dbbihn000xsmjb834n7ajp","_id":"ck5dbbihy001ysmjbedfqkidd"},{"post_id":"ck5dbbihn000ysmjb9uzw9zpa","category_id":"ck5dbbihn000xsmjb834n7ajp","_id":"ck5dbbihz0021smjbrcf6qe01"},{"post_id":"ck5dbbihu001jsmjbzt7bnd9i","category_id":"ck5dbbihn000xsmjb834n7ajp","_id":"ck5dbbihz0024smjbxzaepv6f"},{"post_id":"ck5dbbihx001usmjbtf6901jo","category_id":"ck5dbbih90006smjbg7mt3dyj","_id":"ck5dbbii00026smjbnxw2sg5r"},{"post_id":"ck5dbbihv001msmjbvdgt9q7h","category_id":"ck5dbbihx001tsmjbkvyv9du5","_id":"ck5dbbii00029smjbee9lmmnt"},{"post_id":"ck5dbbihw001qsmjbkn80gks0","category_id":"ck5dbbihx001tsmjbkvyv9du5","_id":"ck5dbbii0002bsmjbfo278vh3"}],"PostTag":[{"post_id":"ck5dbbihg000esmjblpy5gh32","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbihj000jsmjbzg9lt4ji"},{"post_id":"ck5dbbihg000esmjblpy5gh32","tag_id":"ck5dbbihf000dsmjby6ebany4","_id":"ck5dbbihk000msmjbkwxhz9du"},{"post_id":"ck5dbbih40002smjb1ucyiiq4","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbihl000qsmjbeacc911u"},{"post_id":"ck5dbbih40002smjb1ucyiiq4","tag_id":"ck5dbbihf000dsmjby6ebany4","_id":"ck5dbbihm000tsmjbflsamij6"},{"post_id":"ck5dbbih70004smjbo7o7hjmm","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbiho0010smjbkatm3ch4"},{"post_id":"ck5dbbih70004smjbo7o7hjmm","tag_id":"ck5dbbihf000dsmjby6ebany4","_id":"ck5dbbiho0013smjbtakircn5"},{"post_id":"ck5dbbihb0008smjbhi1uuce4","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbihs001esmjbh4hzhpv1"},{"post_id":"ck5dbbihb0008smjbhi1uuce4","tag_id":"ck5dbbihf000dsmjby6ebany4","_id":"ck5dbbiht001hsmjb09ojtw5e"},{"post_id":"ck5dbbihd000asmjbzofng2om","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbihu001lsmjbiyn5r60w"},{"post_id":"ck5dbbihd000asmjbzofng2om","tag_id":"ck5dbbihf000dsmjby6ebany4","_id":"ck5dbbihw001osmjbimxzm4o7"},{"post_id":"ck5dbbihe000bsmjbyn22w62w","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbihx001ssmjbzegc8q53"},{"post_id":"ck5dbbihe000bsmjbyn22w62w","tag_id":"ck5dbbihf000dsmjby6ebany4","_id":"ck5dbbihy001wsmjbpli67qle"},{"post_id":"ck5dbbihh000fsmjb484v4xj0","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbihy001zsmjbmdudz351"},{"post_id":"ck5dbbihh000fsmjb484v4xj0","tag_id":"ck5dbbihf000dsmjby6ebany4","_id":"ck5dbbihz0022smjb2bvueqfx"},{"post_id":"ck5dbbihh000fsmjb484v4xj0","tag_id":"ck5dbbihw001psmjbt8chtnbw","_id":"ck5dbbii00025smjbbwwnqbwj"},{"post_id":"ck5dbbihj000ksmjb45lu6g5b","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbii00027smjbdhm6m6jy"},{"post_id":"ck5dbbihj000ksmjb45lu6g5b","tag_id":"ck5dbbihf000dsmjby6ebany4","_id":"ck5dbbii0002asmjbuigbbmec"},{"post_id":"ck5dbbihj000ksmjb45lu6g5b","tag_id":"ck5dbbihw001psmjbt8chtnbw","_id":"ck5dbbii1002csmjbpiyz4gil"},{"post_id":"ck5dbbihk000nsmjbbe6g226y","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbii1002esmjb4d4v1j7j"},{"post_id":"ck5dbbihk000nsmjbbe6g226y","tag_id":"ck5dbbihf000dsmjby6ebany4","_id":"ck5dbbii1002fsmjbl7u1unu2"},{"post_id":"ck5dbbihk000nsmjbbe6g226y","tag_id":"ck5dbbihw001psmjbt8chtnbw","_id":"ck5dbbii2002hsmjbiw8tnzri"},{"post_id":"ck5dbbihl000rsmjbxart2uxt","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbii2002ismjb7lzewpln"},{"post_id":"ck5dbbihl000rsmjbxart2uxt","tag_id":"ck5dbbii00028smjbsbtqcovi","_id":"ck5dbbii2002ksmjbcs4gwipe"},{"post_id":"ck5dbbihm000usmjbgnblt3yg","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbii2002lsmjbqtpza1xb"},{"post_id":"ck5dbbihm000usmjbgnblt3yg","tag_id":"ck5dbbii00028smjbsbtqcovi","_id":"ck5dbbii3002nsmjb9gktjron"},{"post_id":"ck5dbbihn000ysmjb9uzw9zpa","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbii3002osmjbsx5tn3i1"},{"post_id":"ck5dbbihn000ysmjb9uzw9zpa","tag_id":"ck5dbbii00028smjbsbtqcovi","_id":"ck5dbbii3002qsmjbsnujqrht"},{"post_id":"ck5dbbiho0011smjbs01d1lxc","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbii4002rsmjbvi18sle8"},{"post_id":"ck5dbbiho0011smjbs01d1lxc","tag_id":"ck5dbbii00028smjbsbtqcovi","_id":"ck5dbbii4002tsmjb8y8zmnbw"},{"post_id":"ck5dbbihp0015smjb8ey7co8j","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbii4002usmjbjk5lab2g"},{"post_id":"ck5dbbihp0015smjb8ey7co8j","tag_id":"ck5dbbii00028smjbsbtqcovi","_id":"ck5dbbii5002wsmjb6jkps9gj"},{"post_id":"ck5dbbihq0018smjbwuz1cbpe","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbii5002xsmjb48vbc0pj"},{"post_id":"ck5dbbihq0018smjbwuz1cbpe","tag_id":"ck5dbbii00028smjbsbtqcovi","_id":"ck5dbbii5002zsmjb0khvna41"},{"post_id":"ck5dbbihr001bsmjbyed83rze","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbii50030smjbqp6jpxkp"},{"post_id":"ck5dbbihr001bsmjbyed83rze","tag_id":"ck5dbbii00028smjbsbtqcovi","_id":"ck5dbbii60032smjbxjpuhvhi"},{"post_id":"ck5dbbihs001fsmjbssyd9dpi","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbii60033smjb6590bg8v"},{"post_id":"ck5dbbihs001fsmjbssyd9dpi","tag_id":"ck5dbbii00028smjbsbtqcovi","_id":"ck5dbbii60035smjb0knmbbr2"},{"post_id":"ck5dbbihu001jsmjbzt7bnd9i","tag_id":"ck5dbbihb0007smjbt7jto3yo","_id":"ck5dbbii60036smjbr46lmfx4"},{"post_id":"ck5dbbihu001jsmjbzt7bnd9i","tag_id":"ck5dbbii5002ysmjbfviodt9c","_id":"ck5dbbii70038smjb5jpr2zcv"},{"post_id":"ck5dbbihu001jsmjbzt7bnd9i","tag_id":"ck5dbbii00028smjbsbtqcovi","_id":"ck5dbbii70039smjbjn7kgo1d"},{"post_id":"ck5dbbihv001msmjbvdgt9q7h","tag_id":"ck5dbbii60034smjb4waou7p8","_id":"ck5dbbii8003bsmjbi2wzsr46"},{"post_id":"ck5dbbihv001msmjbvdgt9q7h","tag_id":"ck5dbbii70037smjbkdibpsdg","_id":"ck5dbbii8003csmjbqyuwpnz9"},{"post_id":"ck5dbbihw001qsmjbkn80gks0","tag_id":"ck5dbbii60034smjb4waou7p8","_id":"ck5dbbii9003fsmjbnyhp221t"},{"post_id":"ck5dbbihw001qsmjbkn80gks0","tag_id":"ck5dbbii70037smjbkdibpsdg","_id":"ck5dbbii9003gsmjba5zf64q3"},{"post_id":"ck5dbbihx001usmjbtf6901jo","tag_id":"ck5dbbihf000dsmjby6ebany4","_id":"ck5dbbiia003ismjb9dr0sf8a"},{"post_id":"ck5dbbihx001usmjbtf6901jo","tag_id":"ck5dbbii9003esmjbqytx3m3t","_id":"ck5dbbiia003jsmjbqjkx3cea"},{"post_id":"ck5dbbihx001usmjbtf6901jo","tag_id":"ck5dbbiia003hsmjb7iuo8oye","_id":"ck5dbbiib003ksmjbgptvl7sd"}],"Tag":[{"name":"Note","_id":"ck5dbbihb0007smjbt7jto3yo"},{"name":"C","_id":"ck5dbbihf000dsmjby6ebany4"},{"name":"DataStructure","_id":"ck5dbbihw001psmjbt8chtnbw"},{"name":"C++","_id":"ck5dbbii00028smjbsbtqcovi"},{"name":"STL","_id":"ck5dbbii5002ysmjbfviodt9c"},{"name":"Time","_id":"ck5dbbii60034smjb4waou7p8"},{"name":"Life","_id":"ck5dbbii70037smjbkdibpsdg"},{"name":"DEMO","_id":"ck5dbbii9003esmjbqytx3m3t"},{"name":"Game","_id":"ck5dbbiia003hsmjb7iuo8oye"}]}}