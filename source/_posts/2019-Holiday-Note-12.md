---
title: Holiday Note_12
date: 2019-07-24 20:37:38
categories: C++
tags: [Note,C++]
---

# Holiday Note_12

**对象的构造与析构**这块的知识点有点多的，不难但细节特别多。**构造函数**，**析构函数**，**拷贝函数**，**浅拷贝和深拷贝**，**new**和**delete**运算符，**explicit**，**静态成员**。看完了剑谱大佬的大学学习经历：惊为天人，膜拜。

 <!-- more -->

---

## 对象的构造和析构

**对象的初始化和清理**也是两个非常重要的安全问题，一个对象或者变量没有初始时，对其使用后果是未知，同样的使用完一个变量，没有及时清理，也会造成一定的安全问题。

C++提供**构造函数**和**析构函数**，这两个函数将会被编译器**自动调用**，完成对象初始化和对象清理工作。系统会默认调用构造函数和析构函数，而且只会**调用一次**。如果我们没有提供构造和析构，系统会默认提供，**空实现**。


### 构造函数和析构函数

构造函数语法：
-	构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数(即**可以重载**)。
-	ClassName(){}

析构函数语法：
-	析构函数函数名是在类名前面加' ~ '组成,没有返回值，不能有void,不能有参数，**不能重载**。
-	~ClassName(){}

### 构造函数的分类及调用

-	按参数类型：分为无参构造函数和有参构造函数
-	按类型分类：普通构造函数和拷贝构造函数(复制构造函数)

**注意拷贝构造函数参数类型(const Class&)**
~~~
class Person{
public:
	//拷贝构造函数(复制构造函数) 使用另一个对象初始化本对象
	Person(const Person& person){		
		mAge = person.mAge;
	}

private:
	int mAge;
};
~~~

### 构造函数的调用方法注意

1.	无参构造写法和调用

- Person p1 ; 注意不能写 Person p1() ，因为编译器认为这个是函数声明

2.	有参构造写法和调用

- Person p2(10)  或者 Person p2 = Person(10)

- Person(10) 匿名对象 ，执行当前行后就会释放即析构这个对象

3.	拷贝构造函数
-	Person( const Person & p )
-	可以使用Perons p1( p2) 或者 Person p1 = Person(p2)

-	不能用拷贝构造函数初始化匿名对象
-	如果写成 Person (p1)  这种写法等价于 Person p1，写到右值可以做拷贝构造函数
		

4.	Person P = 100 隐式类型转换（使用explicit关键字可以禁止使用隐式类型转换） 相当于调用 Person p = Person(100)


### 拷贝构造函数的调用时机

1. 对象以值传递的方式传给函数参数
~~~
// 传递的参数是普通对象，函数参数也是普通对象，传递将会调用拷贝构造
void doBussiness(Person p){}

void test02(){
	Person p(10);
	doBussiness(p);
}
~~~

2.	函数局部对象以值传递的方式从函数返回(vs debug模式下调用一次拷贝构造，qt不调用任何构造)
~~~
函数返回局部对象
Person MyBusiness(){
	Person p(10);
	return p;
}
void test03(){
	//vs release、qt下没有调用拷贝构造函数
	//vs debug下调用一次拷贝构造函数
	Person p = MyBusiness();
~~~

3.	用一个对象初始化另一个对象
~~~
Person p(10);
Person p1(p);
~~~


### 构造函数调用规则

默认情况下，C++编译器至少为我们写的类增加3个函数
1. 默认构造函数(无参，函数体为空)
2. 默认析构函数(无参，函数体为空)
3. 默认拷贝构造函数，对类中**非静态成员属性简单值拷贝**
-	如果**用户定义拷贝构造函数，C++不会再提供任何默认构造函数**
-	如果**用户定义了普通构造(非拷贝)，C++不在提供默认无参构造，但是会提供默认拷贝构造**


### 浅拷贝和深拷贝

当**类中有指针**，并且指针指向**动态分配的内存空间**，析构函数做了动态**内存释放**的处理，会导致内存问题。(即内存重复释放导致程序出错)

因为浅拷贝只是拷贝了内存的地址，而当被拷贝的类析构时完成释放内存后，拷贝的类析构时再次对该内存进行释放因而会产生错位。

因此当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要**自定义拷贝构造函数**，自行给指针动态分配空间，深拷贝。

### 多个对象的构造和析构

传统方式初始化，即进行有参构造
~~~
Person(int a,int b,int c){
	mA = a;
	mB = b;
	mC = c;
}
~~~
**初始化列表**方式初始化方法。(:)
~~~
Person(int a, int b, int c):mA(a),mB(b),mC(c){}
~~~


> 注意：在**类对象作为成员的情况下**：当调用构造函数时，首先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体。也就是说，**先调用对象成员的构造函数**，**再调用本身的构造函数**。**析构函数和构造函数调用顺序相反**，先构造，后析构


### explicit关键字
 
声明为explicit的构造函数不能在隐式转换中使用，防止构造时寓意不明。

---

## 动态分配内存

使用C的动态内存分配函数在堆上创建类的问题(麻烦)
-	程序员必须确定对象的长度。
-	malloc返回一个万能指针，c++不允许将万能赋值给其他任何指针，必须强转。
-	malloc可能申请内存失败，所以必须判断返回值来确保内存分配成功。
-	用户在使用对象之前必须记住对他初始化，构造函数不能显示调用初始化(构造函数是由编译器调用)，用户有可能忘记调用初始化函数。

> C的动态内存分配函数太复杂，容易令人混淆，是不可接受的。

### new 运算符(operator)
当用new创建一个对象时，它就**在堆里为对象分配内存**并**调用构造函数完成初始化**。
~~~
Person* person = new Person;
~~~
相当于:为对象分配内存
~~~
Person* person = (Person*)malloc(sizeof(Person));
	if(person == NULL){
		return 0;
	}
~~~
以及对象初始化
~~~
person->Init();
~~~

new操作符能确定在调用构造函数初始化之前内存分配是成功的，所有不用显式确定调用是否成功。

### delete 运算符(operator)

delete表达式**先调用析构函数**，然后**释放内存**。正如new表达式返回一个指向对象的指针一样，delete需要一个对象的**地址**。

### 注意
1. **new的对象用万能指针去接收会导致无法释放对象**
2. 使用new和delete在堆上创建数组时，**delete的格式[]**！！！
~~~
//创建字符数组
char* pStr = new char[100];
//创建整型数组
int* pArr1 = new int[100]; 
//创建整型数组并初始化
int* pArr2 = new int[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

//释放数组内存
delete[] pStr;
delete[] pArr1;
delete[] pArr2;
~~~

---

## 静态成员

### 静态成员变量

在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。

不管这个类创建了多少个对象，静态成员**只有一个拷贝**，这个拷贝被所有属于这个类的对象共享。

注意：
- **静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。**
- 静态成员变量必须在**类中声明，在类外定义**。
- 静态数据成员不属于某个对象，在**为对象分配空间中不包括静态成员所占空间**。
- 静态数据成员可以通过**类名或者对象名来引用**。
- 静态成员也有**访问权限**，**类外不能访问私有成员**

静态成员变量的**初始化**
~~~
class Person{
public:
	//类的静态成员属性
	static int sNum;
private:
	static int sOther;
};

//类外初始化，初始化时不加static
int Person::sNum = 0;
int Person::sOther = 0;
~~~
**访问**静态成员变量的**两种方式**。
~~~
//1. 通过类名直接访问
	Person::sNum = 100;

//2. 通过对象访问
	Person p1, p2;
	p1.sNum = 200;
~~~


### 静态成员函数 
和静态变量一样，同样**在对象没有创建前，即可通过类名调用**。静态成员函数主要为了访问静态变量，但是，不能访问普通成员变量。

静态成员函数的意义，不在于信息共享，数据沟通，而在于**管理静态数据成员，完成对静态数据成员的封装**。

注意:
-	**静态成员函数只能访问静态变量，不能访问普通成员变量**
-	静态成员函数的使用和静态成员变量一样
-	静态成员函数也有访问权限
-	普通成员函数可访问静态成员变量、也可以访问非经常成员变量

PS:今晚花了一个小时看完了剑谱大佬写的大学学习经历，特别是大二下加进实验室之后的学习之路，震惊了。买张床直接住里边，学到超神！



