---
title: Holiday Note_13
date: 2019-07-25 21:17:40
categories: C++
tags: [Note,C++]
---

# Holiday Note_13

稍微接触了以下**单例(Singleton)模式**的思想，主要学习的是**类中成员函数和成员变量的关系**，**常函数和常对象**，**this指针**，**友元**。**单例模式**作为一种常见的软件设计模式，实现起来并不是很好理解，核心是通过**静态成员**实现系统中**一个类只有一个实例**而且该实例易于外界访问来达到节约系统资源的目的。

> 《Thinking in C++》：如果一个类被声明为friend,意味着它不是这个类的成员函数，却可以修改这个类的私有成员，而且必须列在类的定义中，因此他是一个特权函数。C++不是完全的面向对象语言，而只是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟C++设计的目的是为了实用性，而不是追求理想的抽象。
 
<!-- more -->

---

## 单例模式

[![singletonpatternd5aaa.md.jpg](https://miao.su/images/2019/07/25/singletonpatternd5aaa.md.jpg)](https://miao.su/image/Tm6w3)

单例模式的核心结构中只包含一个被称为单例的特殊类。**通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源**。

Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；**为了防止在外部对其实例化，将其默认构造函数和拷贝构造函数设计为私有**；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。

要点为：
-	将 **默认构造**  和 **拷贝构造** **私有化**
-	内部维护一个 **对象指针**
-	**私有化唯一指针**
-	对外提供 getInstance方法来访问这个指针
-	保证类中只能实例化唯一一个对象

打印机
~~~
class Printer{

public:
	static Printer* getInstance() { 
		return pPrinter;
	}
	
private:

	Printer(){}
	Printer(const Printer&){}

	static Printer* pPrinter;
	int mTimes;
};

Printer* Printer::pPrinter = new Printer;

void test(){

	Printer* printer = Printer::getInstance();

}

~~~

---

## 类中成员函数和变量的关系
**C++类对象中的变量和函数是分开存储。**

- 	每一个非内联成员函数只会诞生一份函数实例
-	成员变量和成员函数是分开存储的
-	空类的大小 1
-	只有**非静态数据成员**直接内含在类对象中



---
## this指针

C++通过提供特殊的对象指针: this指针，解决多个同类型的对象共用一块代码(**每一个非内联函数仅会生成一份函数实例**)导致难以**区分是哪一个对象调用**的问题。
	
**this指针永远指向当前对象**，是一种隐含指针，隐含于每个类的**非静态成员函数中**。This指针**无需定义**，直接使用即可。

> 静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。

两种使用场景：
-	当**形参和成员变量同名**时，可用this指针来区分
-	在类的非静态成员函数中**返回对象本身**，可使用👇
~~~ 
return *this;（链式编程)
//p1.m_A = p2.Add(p3).Add(p4).Add(p5);
~~~


---
## 常函数和常对象

### 常函数

-	用const修饰的成员函数时，const修饰this指针指向的内存区域，成员函数体内**不可以修改本类中的任何普通成员变量**，
- 当成员变量类型符前用**mutable**修饰时例外。

注意const写在函数的括号后的位置
~~~
public:
	void sonmeOperate() const {
		//this->mAge = 200; //mAge不可修改
		this->mID = 10;
	}
	
private:
	int mAge;
	mutable int mID;
};

~~~

### 常对象

-	常对象**只能调用const的成员函数**
-	常对象**可访问** const 或非 const 数据成员，**不能修改**，除非成员用**mutable**修饰

创建方法
~~~
const Person person;
~~~

---

## 友元
友元函数是一种特权函数，C++**允许**这个特权函数**访问私有成员**。

- 	友元函数可访问对象任意成员属性，包括私有属性
-	friend关键字只出现在声明处
-	其他类、类成员函数、全局函数都可声明为友元
-	友元函数不是类的成员，不带this指针

语法很简单，定义友元类，友元函数都只需要在类中进行声明且声明前加friend关键字即可。

注意：
1. 友元关系**不能被继承**。
2. 友元关系是**单向**的，类A是类B的朋友，但类B不一定是类A的朋友。
3. 友元关系**不具有传递性**。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。

PS: 买了盒速冻馄饨，就是个mini水饺啊🙃