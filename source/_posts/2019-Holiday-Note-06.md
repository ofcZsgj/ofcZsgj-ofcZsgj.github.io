---
title: Holiday Note_05
date: 2019-07-18 16:53:07
categories: C
tags: [Note,C]
---

# Holiday Note_05

放假第六天。今天的内容内容不多，重点是**链表反转**，**函数递归**。然后就是简单了解了下**预处理**，**静态库和动态库**以及**面向接口编程**的内容了。

<!-- more -->

---

## 链表反转

跟昨天重学链表一样，又是豁然开朗的感觉。之前看到链表反转的题目，想了半天做不出，看别人博客的解题思路还看不懂**定义三指针**的作用何在。其实三个指针就是记录位置，一个中间的用来判断是不是NULL，另外两个一前一后保证链表地址不丢失可以重新进行连接，画个图，把指针的指向画出来就明白为什么要三个指针了。


![20180407202437512045a5.png](https://miao.su/images/2019/07/18/20180407202437512045a5.png)
~~~
void Reserve_LinkList(struct LinkListNode* header) {

	if (NULL == header)
		return;

    //header是头结点
	struct LinkListNode* pHead = header->next;
	struct LinkListNode* pPrev = NULL;
	struct LinkListNode* pNext = NULL;

	while (pHead != NULL) {

        //记录下来后结点的地址
		pNext = pHead->next;
        //该结点指向前结点，第一次执行是指向NULL
		pHead->next = pPrev;
        //更新前结点指向的地址-->
		pPrev = pHead; 
        //更新当前结点的地址 -->
		pHead = pNext;

	}
    
    //当前 结点指向空时退出循环，此时 前 结点指向的是该链表的最后一个结点
	header->next = pPrev;

}
~~~

---

## 函数递归

C通过运行时**堆栈**来支持递归函数的实现。递归函数就是直接或间接调用自身的函数。若递归没有退出条件则会使得栈移除从而程序挂掉。因此**写递归最重要的就是设置退出条件！**

### 普通函数调用
~~~
void funB(int b){

	printf("b = %d\n", b);

}

void funA(int a){

	funB(a - 1);
	printf("a = %d\n", a);

}

int main(void){

	funA(2);

}
~~~

![142374.png](https://miao.su/images/2019/07/18/142374.png)

---

### 递归函数调用
~~~
void fun(int a){
	
	if (a == 1){
		printf("a = %d\n", a);
		return; //中断函数很重要
	}

	fun(a - 1);
	printf("a = %d\n", a);

}

int main(void){

	fun(2);

}
~~~
![23879c.png](https://miao.su/images/2019/07/18/23879c.png)

---

### 递归逆序打印链表(不改变数据位置)

只要结点不为NULL，继续调用直到为空，此时执行的第一个打印是的链表最后的一个数据，再不断的返回直到反向打印完所有数据退出函数。
~~~
void ReservePrint_LinkList(struct LinkListNode* header) {

	if (NULL == header)
		return;

	ReservePrint_LinkList(header->next);

	printf("%d ", header->data);

}
~~~

---

## 预处理

### 文件包含指令#incude<>和#include""区别

- "" 表示系统先在file1.c所在的当前目录找file1.h，如果找不到，再按系统指定的目录检索。
- < > 表示系统直接按系统指定的目录检索。

注意：
1. #include <>常用于包含库函数的头文件；
2. #include ""常用于包含自定义的头文件；
3. 理论上#include可以包含任意格式的文件(.c .h等) ，但一般用于头文件的包含；

### 宏定义

1.	宏名一般用大写，以便于与变量区别；
2.	宏定义可以是常数、表达式等；
3.	**宏定义不作语法检查**，只有在编译被宏展开后的源程序才会报错；
4.	**宏定义不是C语言**，不在行末加分号；
5.	宏名有效范围为**从定义到本源文件结束**；
6.	可以用#undef命令终止宏定义的作用域；
7.	在宏定义中，可以引用已定义的宏名；
8.  在预编译时将宏名替换成字符串的过程称为“宏展开”


#### 一些特殊的预定宏

C编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。

~~~
__FILE__	    宏所在文件的源文件名 
__LINE__	    宏所在行的行号
__DATE__	    代码编译的日期
__TIME__	    代码编译的时间

void test()
{
	printf("%s\n", __FILE__);
	printf("%d\n", __LINE__);
	printf("%s\n", __DATE__);
	printf("%s\n", __TIME__);
}
~~~

---

## 静态库和动态库

**库是已经写好的、成熟的、可复用的代码**。库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。

感觉挺简单的，也就了解了一下静态库和动态库怎么创建和使用，我也就没有自己写了，偷了回懒。

### 静态库的缺点
>浪费空间，不方便更新和移植。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间。一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序。
- 静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；
- 程序在运行时与函数库再无瓜葛，移植方便。
- 浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。

### 动态链接的思想
> 要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，**就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接**。也就是说，把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想。

---

## 面向接口编程

案列比较简单，主要就是函数回调的思想，客户和企业沟通完接口后，根据接口所定义的参数和函数指针，分别开发业务代码和被调用的实现代码。

> 模块要求松、接口要求紧。


PS:天津今天下了点小雨，最近天气都很不好，每天都灰蒙蒙的挺压抑的。