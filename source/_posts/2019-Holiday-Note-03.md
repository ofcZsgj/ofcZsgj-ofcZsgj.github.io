---
title: Holiday Note_03
date: 2019-07-15 17:06:15
categories: C
tags: [Note,C]
---

# Holiday Note_03

放假第三天。今天学习的主要内容是：1、**位运算**(感觉目前只有位异或和移位运算符挺实用的还能玩个骚操作，按位取反，位与，位或这些改变二进制位的运算初次接触还是挺晕的)。2、**数组的深入学习**(记住一句话，无论是几维数组，在除了sizeof和&这两种情况，数组名表示的是指向该数组第一个元素的指针，难点是理解数组类型指针解引用为指向数组首元素指针这一操作逻辑)。3、**结构体的深入学习**(重点理解结构体赋值的深拷贝，浅拷贝的内存模型，以及结构体嵌套指针)。
对了，《C和指针》提到了两句话：
> 源代码的可读性几乎总是比程序的运行时效率更为重要。
> 
> 只要有可能，函数的指针形参都应该声明为const。

我认为这是值得我去思考去实践的。BUT思考前，今晚先去好好去撸个串🍖放松一下

<!-- more -->

---

## 位运算
众所周知，C中最小的类型是char类型，占一个字节，而一个字节占八位，例如00011001这样八个字节的二进制数，代表的其实是25，而位运算便是对位进行操作，在一些场景下能提高程序运行效率。

### 按位取反 ~
一元运算符~将每个1变为0，将每个0变为1，如下所示
~~~
~(10011010)
  01100101
~~~

### 位与(AND) &
二进制运算符&通过对两个操作数逐位进行比较产生一个新值。对于每个位，*只有两个操作数的对应位都是1时结果才为1*。 有一个用途便是用位与运算符来判断一个数字的奇偶性，因为基数的最后一位一定是1，偶数最后一位一定是0，因此可以通过 &= 进行运算后的值进行判断。
~~~
   (10010011) 
 & (00111101) 
 = (00010001)
~~~

### 位或(OR) |
二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1。
~~~
    (10010011)
  | (00111101)
  = (10111111)
~~~

### 位异或 ^
二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0。这是个十分有意思的位逻辑运算符，可以完成不创建临时变量从而互换两值的操作。
~~~
    (10010011)
  ^ (00111101)
  = (10101110)
~~~
骚操作如下(需要理解)😜：
~~~
//原理如下
// A ^ B = R
// R ^ B = A
// R ^ A = B
// 即 A ^ B ^ B = A; A ^ B ^ A = B

int num1 = 7, num2 = 9;
num1 = num1 ^ num2;//R = A ^ B
num2 = num1 ^ num2;//B = R ^ B 将num1赋给num2
num1 = num1 ^ num2;//R = R ^ A 将num2赋给num1

~~~

### 左移/右移运算符 <<  >>
左移运算符<<将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。

总的来说就是左移n位，就相当于乘以2的n次幂；右移运算符 >>，右移n位，就相当于除以2的n次幂（但是，进对于非负数适用，负数在不同机器结果可能不同）
~~~
(10001010) << 2
(00101000)
~~~

---

## 深入理解数组
该部分不容易理解！

最重要记住：**在C中，在几乎所有数组名的表达式中，数组名的值是一个指针常量，也就是数组第一个元素的地址。**

只有在以下两种情况下，数组名不作为指针常量！
- 当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。
- 当数组名作为&操作符的操作数的时候，此时返回的是一个指向数组的指针(重难点，理解指向数组的指针)，而不是指向某个数组元素的指针常量。

*务必理解以下代码*
~~~
int arr[10];
//arr = NULL; //arr作为指针常量，不可修改
int *p = arr; //此时arr作为指针常量来使用
printf("sizeof(arr):%d\n", sizeof(arr)); //此时sizeof结果为整个数组的长度即40而不是4
printf("&arr type is %s\n", typeid(&arr).name()); //int(*)[10]而不是int*
~~~

---
### 定义指向整个数组类型的指针
对于这个指向整个数组类型的指针，解引用后结果为指向数组首元素的指针

~~~
int arr[] = { 1, 2, 3, 4 };

int* p = &arr;//warning C4047:  “初始化”:“int *”与“int (*)[4]”的间接级别不同

printf("%d\n", *(p+1));//打印结果为2，可见上一步骤int* p = &arr 失败，仅将p指向了arr
~~~

typedef定义数组类型的写法
~~~
//以下为正确定义方式
//1、先定义数组类型 ，再定义数组指针类型

typedef int (ARRAY_TYPE)[4];//即ARRAY_TYPE为int [4]类型的数组
ARRAY_TYPE myArray;//等价于int myArray[4];

//对数组名取地址即指向整个数组的指针
ARRAY_TYPE* pArray = &arr;

//重难点：*pArray表示拿到了pArray指向的整个数组！
//即*pArray类型就是数组名，指向数组首元素的指针类型

printf("*(*pArray + 1)= %d\n", *(*pArray + 1));//打印结果为2
~~~

~~~
//2、定义数组指针类型
typedef int(*ARRAY_POINTER)[4];
ARRAY_POINTER arrPointer = &arr;
~~~

~~~
//3、直接定义数组指针变量
int(*pArrParam)[4] = &arr;
~~~

### 二维数组数组名作为实参传递
二维数组数组名作为实参传递时，由于二维数组的数组名也是指向数组首元素的指针，而二维数组的首元素是一维数组，因此形参类型为**指向整个一维数组的指针类型**！

被调函数
~~~
typedef int(*ARR_TYPE)[3];
//形参也可以直接写int(*p)[3]
void printArray(ARR_TYPE p, int len,int width) {
	for (int i = 0; i < len; ++i) {
		for (int j = 0; j < width; ++j) {
			printf("arr[i][j] = %d\n", *(*(p + i) + j));//等价于p[i][j]
		}
	}
}
~~~
主调函数
~~~
int arr[3][3] = {
    {1,2,3},
    {4,5,6},
    {7,8,9}
};

//与一维数组类似,二维数组的数组名在使用sizeof()和取地址的情况下不再是指向数组首元素的指针了
// 二维数组的首元素为一维数组，因此指向二维数组首元素的指针为数组类型指针
int(*aPointer)[3] = arr;

// aPointer + 1为跳过二维数组的第一个一维数组，而指向二维数组中的第二个一维数组
// *(aPointer + 1)则是解引用使得指向表示该一维数组的一维数组首元素指针。aPointer是数组类型指针，解引用为该数组的首元素指针。
//printf("*(*(aPointer + 1) +2 )= %d\n", *(*(aPointer + 1) + 2));//打印结果为6


//二维数组作为参数传递时,注意接收二维数组数组名的形参类型是数组指针类型！！
printArray(arr, 3, 3);
~~~

---

### 字符串的选择排序
选择排序相比于冒泡排序来说，交换次数更少，因为选择排序最多交换排序元素个数-1次。思路为，每次循环以一个元素为标准，并将定义一个最小元素下标变量记录它的下标，通过循环遍历除这个元素之外所有元素与之进行比较，若比它小，则记录其下标并更新最小元素下标，若最小元素下标正常更新，循环完毕将此时最小元素小标的那个元素与标准元素互换，如此反复即可完成从小到大的选择排序。

~~~
void selectSort(char** p, int len) {//需要理解形参为char**
	for (int i = 0; i < len; ++i) {
		int min = i;// 记录下标

		for (int j = i + 1; j < len; ++j) {
			if(strcmp(p[j], p[min]) < 0) {
				min = j;
			}
		}

		if (min != i) {
			char *temp = p[i];
			p[i] = p[min];
			p[min] = temp;
		}

	}
}


void test() {
    char* p[] = { "eee","bbb","ppp","KKK","RRR" };

    selectSort(p, 5);
}


int main() {
    test();
}
~~~

---

## 深入理解结构体
### 结构体深拷贝与浅拷贝
深拷贝的示意图
![222141a0.png](https://miao.su/images/2019/07/15/222141a0.png)


切记如果结构体内部有指针指向堆空间，那么就不能使用编译器默认的赋值行为，而应当**手动控制赋值过程**!否则将会产生两个致命错误

- 同一块空间释放两次
- 内存泄露

~~~
上述所说错误具体可以表现为，一个包含char *类型等到结构体，定义两个结构体变量
且均使用malloc等内存分配函数为char *分配了空间，则进行拷贝操作即结构体变量1直接写等于结构体变量2，将会产生以上错误。

若要避免，应当先释放一个char *分配的内存，再实际为其分配将要拷贝数据大小的空间，使用strcpy进行拷贝char *的数据。
~~~
浅拷贝的示意图
![11110a763.png](https://miao.su/images/2019/07/15/11110a763.png)


### 结构体嵌套指针

以下为该练习的内存分配示意图
![2d508273fe91945095cdc.png](https://miao.su/images/2019/07/15/2d508273fe91945095cdc.png)


定义结构体
~~~
struct Person {
	int age;
	char* name;
};
~~~

分配空间
~~~
struct Person** allocateSpace() {

	struct Person** temp;
	temp = malloc(sizeof(struct Person*) * 3);

	for (int i = 0; i < 3; ++i) {

		temp[i] = malloc(sizeof(struct Person));

		temp[i]->name = malloc(sizeof(char) * 64);

		sprintf(temp[i]->name, "Name_%d", i + 1);

	}

	return temp;
}
~~~
释放空间(今天的写法更加优雅更加专业😁)
先判断最外层指针是否为空，再判断中间层指针是否为空，为空continue，最后判断内层指针是否为空并对其操作，这样对中层的指针进行操作便不用再写if条件了。
~~~
void freeSpace(struct Person** person) {

	if (NULL == person)
		return;

	for (int i = 0; i < 3; ++i) {

		if (person[i] == NULL)
			continue;

		if (person[i]->name != NULL) {

			free(person[i]->name);
			person[i]->name = NULL;

		}

		free(person[i]);
		person[i] = NULL;

	}

	if (person != NULL) {
		free(person);
		person = NULL;
	}

}
~~~
调用函数
~~~
void test() {
	struct Person** person = NULL;

	person = allocateSpace();

	freeSpace(person);
}

int main() {
	test();
}
~~~

PS：前半段撸串前写的，后半段撸串完了写的。太久没出去过了，从电梯走到小区门口等滴滴都有些累。。。看来每天需要锻炼锻炼身体了。今天还有件说不上让我开心的事儿，但是确实是让我压抑了很久的纠结解脱了。